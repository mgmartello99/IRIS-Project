//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "ClassReader"
	Revision           = "0.0"
	GUID               = "{93ADF217-D1FE-499E-BD2F-F78FD697A0AD}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Server0" GUID="NULL" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
</Class>
*)
ClassReader : CLASS
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		pTable 	: ^void;
		pClsName 	: ^CHAR;
  //Functions:
	
	FUNCTION GLOBAL ReadClass
		VAR_INPUT
			pTab 	: ^void;
			ppCls 	: ^pClsHdr;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL CheckClsSyntax
		VAR_INPUT
			pCls 	: ^ClsHdr;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL NewCls
		VAR_INPUT
			pName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			pCls 	: ^ClsHdr;
		END_VAR;
	
	FUNCTION CheckFormat
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetTable
		VAR_INPUT
			pTab 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL CheckOsiClass
		VAR_INPUT
			pCls 	: ^ClsHdr;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ClassReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CLASSREADER
0$UINT, 0$UINT, (SIZEOF(::ClassReader))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(768857726), "ClassReader", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::ClassReader.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
END_FUNCTION


#define USER_CNT_ClassReader 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ClassReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ClassReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma using ObjectReader
#pragma using ProjectReader

#define _SIZE_CLS_HDR 	TO_UDINT(ClsHdr.aDscChs)

#ifdef OTTOSPEED
#include "lsl_st_iflinker.h"
#endif

VAR_EXTERNAL
	pLastCls			: ^ClsHdr;
	pOsiMeths			: ^CmdMeth;
END_VAR

VAR_GLOBAL
	pOsiMeths			: ^CmdMeth;	// Zeiger auf die OS - Funktions-Tabellen
END_VAR

FUNCTION _InsertClass
VAR_INPUT
	pNewCls		: ^ClsHdr;
END_VAR
VAR_OUTPUT
	pCls		: ^ClsHdr;
END_VAR;
FUNCTION _UpdateOldObjects
VAR_INPUT
	pNewCls			: ^ClsHdr;
END_VAR
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR;

#include "RTOS_MemIntern.h"
#include ".\RTOS_PrivHeader.h"

//    
//     ret_code := ReadClass();
//    
//     This function reads the definition of one class from
//     the text buffer.
//    
//    -> == C_OK if function succeeded
//       <> C_OK if an error occured
//

FUNCTION GLOBAL ClassReader::ReadClass
	VAR_INPUT
		pTab 	: ^void;
		ppCls 	: ^pClsHdr;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
VAR
	pNewCls			: ^CLSHDR;
	pChDsc			: ^ChDscEntry;
	uiChs       : uint;
	pDsc			: ^ClsHdrConst;
	ppCD			: ^ChDsc;
	udSize			: UDINT;
	name			: ARRAY [0..NLNG*2] OF Char;
	pBasis			: ^CLexem;
 #ifdef OTTOSPEED 
  pnc     : ^char;
  udCno   : udint;
  isExe   : char;
 #else
	uiCh    : uint;
  udLen   : udint;
 #endif
END_VAR

  ret_code  := C_SYNTAX_ERROR;
	ppCls^		:= NIL;
	pTable		:= pTab;

	IF CheckFormat() = FALSE THEN
		ret_code	:= C_INCOMPATIBLE;
		RETURN;
	END_IF;

	pDsc	:= pTable $ ^ClsHdrConst;
	pTable	+= sizeof(ClsHdrConst) + pDsc^.Name.Length();

	                     // allocate channel and descriptor
	uiChs	:= pDsc^.nSvrChs + pDsc^.nCltChs;
	udSize	:= _SIZE_CLS_HDR + SIZEOF(ChDsc) * uiChs;
	pNewCls := LDR_alloc_descr( udSize ) $ pClsHdr;

	IF pNewCls = NIL THEN
		ret_code := C_OUTOF_FAR;
		RETURN;
	END_IF;

	_memset(pNewCls, 0, udSize);
	pBasis	:= pTable $ ^CLexem;
	udSize	:= pBasis^.Size();
	IF udSize = sizeof(CLexem) THEN
		pBasis	:= NIL;
	END_IF;
	pNewCls^.pBaseCls	:= pBasis $ ^ClsHdr;	// file offset is used later
	pNewCls^.pDsc		:= pDsc;

	pTable	+= udSize + sizeof(Revision);

	pNewCls := _InsertClass(pNewCls);
	IF pNewCls <> NIL THEN						// the class was already read

		pNewCls^.ClsState	:= CTY_NEWEST_CLS;

		ppCD	:= #pNewCls^.aDscChs[0];

   #ifdef OTTOSPEED
    udCno := uiChs;
    WHILE udCno DO			// for all channels...
      udCno -= 1;

      pChDsc     := pTable $ ^ChDscEntry;
      ppCD^.pDsc := pChDsc;
      pTable     += sizeof(ChDscEntry) + pChDsc^.Name.Length();

      CASE pChDsc^.uiMode OF
        //_CH_SVR_OBJ,
        _CH_CLT_OBJ,
        _CH_CLT_EMB:
          ppCD^.pCls := pTable$^ClsHdr; // file offset used later
          pTable     += pTable$^CLexem^.Size() + sizeof(Revision); // basis + crc + rev
        ELSE
          ppCD^.pCls := NIL;
      END_CASE;

      ppCD += SIZEOF(ChDsc);
    END_WHILE;
   
    pnc           := _GetClsName(pNewCls);
    name[0]$UDINT := 16#44545340; // "@STD"
    name[4]       := 16#40;       // '@'
    _strcpy(#name[5], pnc);       // "@STD@ClsName"
     
    //pNewCls^.pConstructor := _FindFctName(#name[0]);
    pNewCls^.pConstructor := OS_LNK_GetAddress_Function(#name[0], #isExe);

    IF pNewCls^.pConstructor = NIL THEN
      udCno := _strlen(pnc);
      _memcpy(#name[0], pnc, udCno);
      name[udCno] := '@';
      _strcpy(#name[udCno+1], pnc);
      
//      _strcpy(#name[0], pnc);
//      _strcat(#name[0], "@");
//      _strcat(#name[0], pnc);   // Syntax: <ClsName>::<ClsName>
		  //pNewCls^.pConstructor := _FindFctName(#name[0]);
      pNewCls^.pConstructor := OS_LNK_GetAddress_Function(#name[0], #isExe);
    END_IF;
   #else
		uiCh := 0;
		WHILE uiCh < uiChs DO			// for all channels...

			pChDsc     := pTable $ ^ChDscEntry;
			ppCD^.pDsc := pChDsc;
      udLen      := sizeof(ChDscEntry) + pChDsc^.Name.Length();
			pTable     += udLen;

			CASE pChDsc^.uiMode OF
//			_CH_SVR_OBJ,
			_CH_CLT_OBJ,
			_CH_CLT_EMB:
				ppCD^.pCls := pTable $ ^ClsHdr;		// file offset used later
				pTable	+= pTable $ ^CLexem^.Size()  + sizeof(Revision);	// basis + crc + rev
			ELSE
				ppCD^.pCls	:= NIL;
			END_CASE;

			ppCD		+= SIZEOF(ChDsc);

			uiCh += 1;

		END_WHILE;

		FOR uiCh := 0 TO 1 DO	// try to find std - constructor first, then user ctor
			IF uiCh = 0 THEN	// build constructor name from the class name
				_strcpy(#name[0], "@STD");
			ELSE
				_strcpy(#name[0], _GetClsName(pNewCls));
			END_IF;
      
			_strcat(#name[0], "@");
			_strcat(#name[0], _GetClsName(pNewCls));   // Syntax: <ClsName>::<ClsName>
     
			pNewCls^.pConstructor := _FindFctName(#name[0]);
      
      

			IF pNewCls^.pConstructor THEN
				EXIT;
			END_IF;

		END_FOR;
   #endif

		ret_code := C_OK;
		ppCls^	:= pNewCls;

	END_IF;

END_FUNCTION
// In the 1st run through the config-tables, CreateCls initializes
// the class descriptors and its channel descriptors. Now in the 2nd run, 
// when all classes already exist, the pointers to the base classes
// and to the classes of typed object channels are initialized.
//
// ->	pFile:	pointer to the configuration table
// ->	uiCls:	index of the class
// <-	ret_code:	UNKNOWN_CID	.. class or base class not found
//					OK
//
FUNCTION GLOBAL ClassReader::CheckClsSyntax
	VAR_INPUT
		pCls 	: ^ClsHdr;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
VAR
	pBase		  : ^CLexem;
	pBaseCls	: ^ClsHdr;
	uiCh			: UINT;
	ppCD			: ^ChDsc;	
	pDsc			: ^ClsHdrConst;
  pRev      : ^Revision;
END_VAR

	pDsc		  := pCls^.pDsc;
	pBase	    := pCls^.pBaseCls $ ^CLexem;

	IF pBase <> NIL THEN
    pRev     := pBase + pBase^.Size();
		pBaseCls := _LookUpClsIDExact(NIL, pBase, pRev^, 1);
		IF pBaseCls = NIL THEN
      TRACE1_ERR("Baseclass '{1}' of class '{0}' not found", _GetClsName(pCls), #pBase^.Text[0]);
      LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
			ret_code := C_UNKNOWN_CID;
			RETURN;
		END_IF;
		pCls^.pBaseCls	:= pBaseCls;
	//ELSE
	// there is no base class pointer to set
	END_IF;

	// check if the classes for typed channels are valid
	uiCh 	:= pDsc^.nSvrChs + pDsc^.nCltChs;
	ppCD	:= #pCls^.aDscChs[0];

	WHILE uiCh DO

		CASE ppCD^.pDsc^.uiMode OF
//		_CH_SVR_OBJ,
		_CH_CLT_EMB,
		_CH_CLT_OBJ:
			pBase	    := ppCD^.pCls $ ^CLexem;
      pRev      := pBase + pBase^.Size();
			pBaseCls  := _LookUpClsIDExact(NIL, pBase, pRev^, 1);
			IF pBaseCls = NIL THEN
      
        // install the client class of this channel
        ret_code  := ProjectReader::CreateClass(pBase, pRev^, #pBaseCls);
        IF ret_code <> C_OK | pCls = NIL THEN
          TRACE2_ERR("Unknown class '{0}' for channel '{1}::{2}'", #pBase^.Text[0], _GetClsName(pCls), #ppCD^.pDsc^.Name.Text[0]);
          LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
          RETURN;
        END_IF;
			END_IF;
			ppCD^.pCls := pBaseCls;

		END_CASE;

		ppCD	+= sizeof(ChDsc);
		uiCh 	-= 1;

	END_WHILE;

	ret_code := C_OK;

END_FUNCTION

(*
  Prüft, ob es sich bei der angegebenen Klasse um eine OSI Klasse handelt. 
  Wenn das der Fall ist, dann wird der Konstruktor aufgerufen und ein Dummy 
  Server Objekt angelegt, das nur dazu dient, einen Zeiger auf die Methodentabelle 
  bereitzustellen. 
  
  Der Zeiger auf die Methodentabelle wird im Konstruktor der OSI Klasse auf 
  die globale Variable pOsiMeths geschrieben (indem die Funktion InitOsiM_new 
  aufgerufen wird). Der Inhalt von pOsiMeths wird dann in das Dummy Server Objekt 
  eingetragen.
 *)
FUNCTION GLOBAL ClassReader::CheckOsiClass
	VAR_INPUT
		pCls 	: ^ClsHdr;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
VAR
	pDummySvr	: ^SvrChCmd;
	pDsc			: ^ClsHdrConst;
END_VAR

	pDsc		  := pCls^.pDsc;

	// call constructor for OS-Interface-classes to create
	// dummy objects, pointer to method table must be
	// returned in pOsiMeths.
	IF pDsc^.ClsType AND CTY_OSI_CLASS THEN
		pOsiMeths	:= NIL;	// should be set
		ret_code	:= ObjectReader::CallConstructor(pCls, NIL);
		IF ret_code <> C_OK | pOsiMeths = NIL | 
		// just any number to distinguish between old 
		// and new version of OSI-classes
			pOsiMeths^.nCmds > 1024 THEN
		// Please try to fix this error by reimporting
		// of the OSI - classes (i.e graphic, system ...)
			TRACE0_WARN("OSI - class '{0}' too old?", _GetClsName(pCls));
      LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
			ret_code	:= C_UNKNOWN_CONSTR;
      RETURN;
		END_IF;

		// this object can never be accessed by the user
		pDummySvr	:= _alloc_align(sizeof(SvrChCmd)) $ ^SvrChCmd;

		IF pDummySvr THEN
			pDummySvr^.pMeth 	:= pOsiMeths;
			pDummySvr^.dData	:= 0;
			pDummySvr^.pSvrDsc	:= NIL;
			pCls^.pFirstObj 	:= LSL_GetHdr(pDummySvr);
		ELSE
			ret_code			:= C_OUTOF_NEAR;
		END_IF;

		RETURN;
	END_IF;

	ret_code := C_OK;

END_FUNCTION

FUNCTION GLOBAL ClassReader::NewCls
	VAR_INPUT
		pName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		pCls 	: ^ClsHdr;
	END_VAR
VAR
	pNew		: ^ClsHdr;
  udRev   : Revision;
  Name    : CLocLex;
END_VAR

  udRev.Hi  := udRev.Lo := 16#FFFF;   // Revision ist egal
  Name.InitText(pName);
  
	// search for the global function CT_<class>
	IF ProjectReader::CreateClass(#Name $ CLexem, udRev, #pNew) = C_OK &
     pNew <> NIL &
		 CheckClsSyntax(pNew) = C_OK THEN
    pCls	:= pNew;
  ELSE
    pCls  := NIL;
	END_IF;

END_FUNCTION

FUNCTION GLOBAL ClassReader_NewCls
	VAR_INPUT
		pName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		pCls 	: ^ClsHdr;
	END_VAR
  
  pCls := ClassReader::NewCls(pName);
  
END_FUNCTION

//[#DEUTSCH]
//Passt das Format der CT - Tabelle?

FUNCTION  ClassReader::CheckFormat
VAR_OUTPUT
	ok		: BOOL;
END_VAR

	ok		:= pTable^ $ UINT = 0;
	pTable	+= sizeof(UINT);

END_FUNCTION // ClassReader::CheckFormat

FUNCTION ClassReader::SetTable
VAR_INPUT
	pTab		: ^void;
END_VAR

	pTable	:= pTab;

END_FUNCTION //GLOBAL ClassReader::SetTable
//}}LSL_IMPLEMENTATION
