//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_AI084 1026    // TODO Anpassen

#define AI084_ADDR_CYC_WRITE        16#000
#define AI084_ADDR_CYC_READ         16#080
#define AI084_ADDR_CFG_FIRMWARE     16#100
#define AI084_ADDR_STATE_FIRMWARE   16#180

#define AI084_SDO_RESPONSE_TIMEOUT  SDIAS_SDO_TIMEOUT * 2

#define AI084_LENGTH_STATE_FIRMWARE 2 // TODO Check
#define AI084_NUMBER_OF_ANALOG_IN   8
#define AI084_INVALID_VALUE         16#80000010$DINT

#define AI084_FIRMWARE_MIN          0  // Check 0 - 20000
#define AI084_FIRMWARE_MIN_4000     4000 //For config mode 1
#define AI084_FIRMWARE_MAX          20000   // Check 0 - 20000
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "AI084"
	Revision           = "1.18"
	GUID               = "{0A4E46EE-50D2-4270-864D-4DAE047B451F}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(502,120)"
	Comment            = "SDIAS Analog In Module&#13;&#10;8x Analog In for 0-20mA or 4-20mA">
	<Channels>
		<Server Name="AI1" GUID="{3DDD45E8-8F40-4C75-8643-4F5FFE6AA6FC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input 1. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI2" GUID="{A783708B-FC4E-416A-8DBA-6404F78B5039}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input 2. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI3" GUID="{736920CA-3756-4286-9B02-597DEC5F5C49}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input 3. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI4" GUID="{D7FB5F52-E925-44E2-B214-4725284B9746}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input 4. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI5" GUID="{256E2BDF-BBA9-4044-9B0C-C2AE43613704}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input 5. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI6" GUID="{CA12B784-0581-4326-A20C-B22BFEFCAE3D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input 6. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI7" GUID="{3510AF07-3D7F-4A4E-BB8A-9E21439A123E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input 7. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="AI8" GUID="{035078AF-4A96-459B-9CD0-531CD13091F2}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input 8. Status query over read().&#13;&#10;The invalid value in case of cable break or short circuit is 16#80000010."/>
		<Server Name="CableBreak" GUID="{AD0EA49F-F9BE-4F86-9559-3265DAE30E96}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="low range detection (cablebreak):&#13;&#10;Bit0...low range on AI1&#13;&#10;Bit1...low range on AI2&#13;&#10;Bit2...low range on AI3&#13;&#10;Bit3...low range on AI4&#13;&#10;Bit4...low range on AI5&#13;&#10;Bit5...low range on AI6&#13;&#10;Bit6...low range on AI7&#13;&#10;Bit7...low range on AI8&#13;&#10;&#13;&#10;0 - 20mA Mode:&#13;&#10;cable break is detected if value &lt; -0,25mA.&#13;&#10;&#13;&#10;4 - 20mA Mode:&#13;&#10;Firmware &gt;= 1.10:&#13;&#10;The client LowRangeLimit is used as limit. &#13;&#10;Firmware &lt; 1.10:&#13;&#10;The value 4mA is used as limit.&#13;&#10;&#13;&#10;High range detection:&#13;&#10;Bit8...high range on AI1&#13;&#10;Bit9...high range on AI2&#13;&#10;Bit10...high range on AI3&#13;&#10;Bit11...high range on AI4&#13;&#10;Bit12...high range on AI5&#13;&#10;Bit13...high range on AI6&#13;&#10;Bit14...high range on AI7&#13;&#10;Bit15...high range on AI8&#13;&#10;&#13;&#10;Firmware &gt;= 1.10:&#13;&#10;The high range is detected if the value &gt; 20,25mA. &#13;&#10;Firmware &lt; 1.10:&#13;&#10;No high range detection."/>
		<Server Name="FirmwareVersion" GUID="{07B18282-D6C1-41F3-B3A4-557740B374E9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Version of the used firmware&#13;&#10;&#13;&#10;e.g. 16#100 means v1.00"/>
		<Server Name="FWErrorBits" GUID="{66CA5D73-89EF-4250-BECB-ED621C26BAF3}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Firmware Status:&#13;&#10;Bit0...DC not Ok&#13;&#10;Bit1...No Sync&#13;&#10;Bit2...Flash data CRC error&#13;&#10;Bit3...Ram data CRC error&#13;&#10;Bit4...No valid EEPROM Version"/>
		<Client Name="AI1_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI1_Max" Required="false" Internal="false" DefValue="20000" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI1_Min" Required="false" Internal="false" DefValue="0" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI1Config" Required="false" Internal="false" Comment="0 = AI1 used as analog in (Range: 0mA...+20mA)&#13;&#10;1 = AI1 used as analog in (Range: +4mA...+20mA)"/>
		<Client Name="AI2_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI2_Max" Required="false" Internal="false" DefValue="20000" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI2_Min" Required="false" Internal="false" DefValue="0" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI2Config" Required="false" Internal="false" Comment="0 = AI2 used as analog in (Range: 0mA...+20mA)&#13;&#10;1 = AI2 used as analog in (Range: +4mA...+20mA)"/>
		<Client Name="AI3_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI3_Max" Required="false" Internal="false" DefValue="20000" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI3_Min" Required="false" Internal="false" DefValue="0" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI3Config" Required="false" Internal="false" Comment="0 = AI3 used as analog in (Range: 0mA...+20mA)&#13;&#10;1 = AI3 used as analog in (Range: +4mA...+20mA)"/>
		<Client Name="AI4_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI4_Max" Required="false" Internal="false" DefValue="20000" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI4_Min" Required="false" Internal="false" DefValue="0" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI4Config" Required="false" Internal="false" Comment="0 = AI4 used as analog in (Range: 0mA...+20mA)&#13;&#10;1 = AI4 used as analog in (Range: +4mA...+20mA)"/>
		<Client Name="AI5_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI5_Max" Required="false" Internal="false" DefValue="20000" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI5_Min" Required="false" Internal="false" DefValue="0" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI5Config" Required="false" Internal="false" Comment="0 = AI5 used as analog in (Range: 0mA...+20mA)&#13;&#10;1 = AI5 used as analog in (Range: +4mA...+20mA)"/>
		<Client Name="AI6_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI6_Max" Required="false" Internal="false" DefValue="20000" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI6_Min" Required="false" Internal="false" DefValue="0" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI6Config" Required="false" Internal="false" Comment="0 = AI6 used as analog in (Range: 0mA...+20mA)&#13;&#10;1 = AI6 used as analog in (Range: +4mA...+20mA)"/>
		<Client Name="AI7_Freq" Required="true" Internal="false" DefValue="0" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI7_Max" Required="true" Internal="false" DefValue="20000" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI7_Min" Required="true" Internal="false" DefValue="0" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI7Config" Required="true" Internal="false" DefValue="0" Comment="0 = AI7 used as analog in (Range: 0mA...+20mA)&#13;&#10;1 = AI7 used as analog in (Range: +4mA...+20mA)"/>
		<Client Name="AI8_Freq" Required="true" Internal="false" DefValue="0" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI8_Max" Required="true" Internal="false" DefValue="20000" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI8_Min" Required="true" Internal="false" DefValue="0" Comment="The scale of the analog input can be selected by this client (corresponds 0mA to 20mA or 4mA to 20mA if AIx_Config is set to 1).&#13;&#10;As initvalue."/>
		<Client Name="AI8Config" Required="true" Internal="false" DefValue="0" Comment="0 = AI8 used as analog in (Range: 0mA...+20mA)&#13;&#10;1 = AI8 used as analog in (Range: +4mA...+20mA)"/>
		<Client Name="LowRangeLimit" Required="false" Internal="false" DefValue="3000" Comment="Limit for low range detection (cablebreak) [µA] if configuration for 4mA..20mA is used.&#13;&#10;(range: 0 - 4 mA = 0 - 4000)&#13;&#10;Firmware version &gt;= 1.10 is needed.&#13;&#10;&#13;&#10;For firmware versions &lt; 1.10 a fixed value of 4mA is used."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="LanSte"/>
		<Dokumentation Revision="1.18" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.17" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.16" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.15" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.14" Date="11.10.2017" Author="FurDom" Company="Sigmatek" Description="Added Flag &quot;ScaleAIx&quot; for check if a new calculation is necessary for AI1-8. -&gt; Realtime optimization. &#13;&#10;New calculation if Client AI_Min or AI_Max is not default."/>
		<Dokumentation Revision="1.13" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.12" Date="19.04.2017" Author="RamAnd" Company="Sigmatek" Description="Removed masking of error bits which prevented high range errors from being shown at the Cablebreak server."/>
		<Dokumentation Revision="1.11" Date="07.04.2017" Author="ZoePat" Company="Sigmatek" Description="For Firmware version &gt;= 1.10 the low range detection (CableBreak) is changed to 3mA (instead of 4mA) as default. Also it is possible to change the limit between 0 and 4mA, and a high range information is shown."/>
		<Dokumentation Revision="1.10" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.9" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.8" Date="24.02.2016" Author="PieSte&#13;&#10;EisMic" Company="Sigmatek" Description="Add support for min range greater max range.&#13;&#10;Corrected scale if client AI[x]_Config is set to 1."/>
		<Dokumentation Revision="1.7" Date="17.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.6" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.5" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.4" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.3" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.2" Date="04.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.1" Date="11.04.2014" Author="LanSte" Company="Sigmatek" Description="Corrected Min/Max Value calculation for AI1."/>
		<Dokumentation Revision="1.0" Date="19.02.2014" Author="LanSte" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="AI084">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{134F0961-BD18-4F7F-A8A4-07C87D06A8CA}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

AI084 : CLASS
: SdiasBase
	TYPE
	  t_SpecialPurpose : BSINT
	  [
	    1 PmbModus,
	    2 BootloaderUpdateRequ,
	  ];
	  t_Selection : BINT
	  [
	    1 AI1_Analog_4mA,
	    2 AI2_Analog_4mA,
	    3 AI3_Analog_4mA,
	    4 AI4_Analog_4mA,
	    5 AI5_Analog_4mA,
	    6 AI6_Analog_4mA,
	    7 AI7_Analog_4mA,
	    8 AI8_Analog_4mA,
	    9 TI_Kty0_Pt1,
	  ];
#pragma pack(push, 1)
	  t_StandardModus : STRUCT
	    Selection : t_Selection;  //! <Type Comment="Analog input settings" Name="t_StandardModus.Selection"/>
	    AI1_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI1_Freq"/>
	    AI2_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI2_Freq"/>
	    AI3_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI3_Freq"/>
	    AI4_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI4_Freq"/>
	    AI5_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI5_Freq"/>
	    AI6_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI6_Freq"/>
	    AI7_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI7_Freq"/>
	    AI8_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_StandardModus.AI8_Freq"/>
	    LowRangeLimit : UINT;
	    MessageCounter : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_CfgFirmware : STRUCT
	    CRC : UINT;
	    DataLength : UINT;
	    Info : t_SpecialPurpose;
	    ConfigBits : BSINT
	    [
	      1 NewThesholdEnable,
	      2 Bit2,
	      3 Bit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	    ];
	    StandardModus : t_StandardModus;
	  END_STRUCT;
#pragma pack(pop)
	  t_Error : BINT
	  [
	    1 CableBreakAI1,
	    2 CableBreakAI2,
	    3 CableBreakAI3,
	    4 CableBreakAI4,
	    5 CableBreakAI5,
	    6 CableBreakAI6,
	    7 CableBreakAI7,
	    8 CableBreakAI8,
	    9 OverRangeAI1,
	    10 OverRangeAI2,
	    11 OverRangeAI3,
	    12 OverRangeAI4,
	    13 OverRangeAI5,
	    14 OverRangeAI6,
	    15 OverRangeAI7,
	    16 OverRangeAI8,
	  ];
	  t_InitSSW :
	  (
	    _InitVariables,
	    _ConfigModule,
	    _ReadState,
	    _Finish,
	    _InitError
	  )$UDINT;
#pragma pack(push, 1)
	  t_ReadData : STRUCT
	    Status : t_b_SdiasFWState;
	    AnalogIn1 : INT;
	    AnalogIn2 : INT;
	    AnalogIn3 : INT;
	    AnalogIn4 : INT;
	    AnalogIn5 : INT;
	    AnalogIn6 : INT;
	    AnalogIn7 : INT;
	    AnalogIn8 : INT;
	    Error : t_Error;
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
#pragma pack(push, 1)
	  t_StateFirmware : STRUCT
	    CRC : UINT;
	    DataLength : UINT;
	    FirmwareVersion : UINT;
	    MessageCounter : UINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	FirmwareVersion 	: SvrCh_HDINT;
	FWErrorBits 	: SvrCh_t_s_SdiasFWStateStandard_PTofCls_SdiasBase;
	AI1 	: SvrCh_DINT;
	AI2 	: SvrCh_DINT;
	AI3 	: SvrCh_DINT;
	AI4 	: SvrCh_DINT;
	AI5 	: SvrCh_DINT;
	AI6 	: SvrCh_DINT;
	AI7 	: SvrCh_DINT;
	AI8 	: SvrCh_DINT;
	CableBreak 	: SvrCh_BDINT;
  //Clients:
	LowRangeLimit 	: CltCh_DINT;
	AI1Config 	: CltCh_DINT;
	AI1_Freq 	: CltCh_UDINT;
	AI1_Min 	: CltCh_DINT;
	AI1_Max 	: CltCh_DINT;
	AI2Config 	: CltCh_DINT;
	AI2_Freq 	: CltCh_UDINT;
	AI2_Min 	: CltCh_DINT;
	AI2_Max 	: CltCh_DINT;
	AI3Config 	: CltCh_DINT;
	AI3_Freq 	: CltCh_UDINT;
	AI3_Min 	: CltCh_DINT;
	AI3_Max 	: CltCh_DINT;
	AI4Config 	: CltCh_DINT;
	AI4_Freq 	: CltCh_UDINT;
	AI4_Min 	: CltCh_DINT;
	AI4_Max 	: CltCh_DINT;
	AI5Config 	: CltCh_DINT;
	AI5_Freq 	: CltCh_UDINT;
	AI5_Min 	: CltCh_DINT;
	AI5_Max 	: CltCh_DINT;
	AI6Config 	: CltCh_DINT;
	AI6_Freq 	: CltCh_UDINT;
	AI6_Min 	: CltCh_DINT;
	AI6_Max 	: CltCh_DINT;
	AI7Config 	: CltCh_DINT;
	AI7_Freq 	: CltCh_UDINT;
	AI7_Min 	: CltCh_DINT;
	AI7_Max 	: CltCh_DINT;
	AI8Config 	: CltCh_DINT;
	AI8_Freq 	: CltCh_UDINT;
	AI8_Min 	: CltCh_DINT;
	AI8_Max 	: CltCh_DINT;
  //Variables:
		aAIRange : ARRAY [0..AI084_NUMBER_OF_ANALOG_IN-1] OF DINT;
			//! <Variable Comment="RangeInformations for the Inputs." Name="aAIRange"/>
		eInitSSW 	: t_InitSSW;			//! <Variable Comment="Initialisation Statemachine." Name="eInitSSW"/>
		eInitSSWErrorStep 	: t_InitSSW;			//! <Variable Comment="Initialisation Statemachine in case of an Error." Name="eInitSSWErrorStep"/>
		eResponseState 	: t_ResponseState;			//! <Variable Comment="Actual Response State of the SDO Communication." Name="eResponseState"/>
		pReadData 	: ^t_ReadData;			//! <Variable Comment="Read-Data from the Module." Name="pReadData"/>
		sCfgFirmware 	: t_CfgFirmware;			//! <Variable Comment="Configuration Data for the Firmware." Name="sCfgFirmware"/>
		sStateFirmware 	: t_StateFirmware;			//! <Variable Comment="FW Informations of the Module." Name="sStateFirmware"/>
		udSDOTimeout 	: UDINT;			//! <Variable Comment="Timeout for SDO-Communication." Name="udSDOTimeout"/>
		aAIMinValue : ARRAY [0..AI084_NUMBER_OF_ANALOG_IN-1] OF DINT;
			//! <Variable Comment="Minvalue of the firmware depending on the config settings." Name="aAIMinValue"/>
		ScaleAI1 	: BOOL;
		ScaleAI2 	: BOOL;
		ScaleAI3 	: BOOL;
		ScaleAI4 	: BOOL;
		ScaleAI5 	: BOOL;
		ScaleAI6 	: BOOL;
		ScaleAI7 	: BOOL;
		ScaleAI8 	: BOOL;
  //Functions:
				//! <Function Comment="Constructor of Class." Name="AI084"/>
	FUNCTION AI084
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode is used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetFWVersion
		VAR_INPUT
			pData 	: ^CHAR;
			Length 	: UDINT;
		END_VAR;
				//! <Function Comment="Lookup-Methode to get the Frequency-Setting for the uC." Name="SetFrequency"/>
	FUNCTION SetFrequency
		VAR_INPUT
			ClientValue 	: UDINT;			//! <Variable Comment="Input-Value for the uC" Name="SetFrequency.ClientValue"/>
		END_VAR
		VAR_OUTPUT
			Frequency 	: UINT;			//! <Variable Comment="Result for the uC." Name="SetFrequency.Frequency"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AI084::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_AI084
1$UINT, 18$UINT, (SIZEOF(::AI084))$UINT, 
11$UINT, 33$UINT, 0$UINT, 
TO_UDINT(1475165325), "AI084", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::AI084.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::AI084.FWErrorBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3888132073), "FWErrorBits", 
(::AI084.AI1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4269591187), "AI1", 
(::AI084.AI2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1735760681), "AI2", 
(::AI084.AI3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(275950527), "AI3", 
(::AI084.AI4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2383822364), "AI4", 
(::AI084.AI5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4178644618), "AI5", 
(::AI084.AI6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1612209968), "AI6", 
(::AI084.AI7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(387936166), "AI7", 
(::AI084.AI8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2275439159), "AI8", 
(::AI084.CableBreak.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3580028836), "CableBreak", 
//Clients:
(::AI084.LowRangeLimit.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3824620287), "LowRangeLimit", 
(::AI084.AI1Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2190884243), "AI1Config", 
(::AI084.AI1_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1690732223), "AI1_Freq", 
(::AI084.AI1_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2432037533), "AI1_Min", 
(::AI084.AI1_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2901986756), "AI1_Max", 
(::AI084.AI2Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3011389198), "AI2Config", 
(::AI084.AI2_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3797087249), "AI2_Freq", 
(::AI084.AI2_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3612706893), "AI2_Min", 
(::AI084.AI2_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3948459796), "AI2_Max", 
(::AI084.AI3Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(352922810), "AI3Config", 
(::AI084.AI3_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(688793524), "AI3_Freq", 
(::AI084.AI3_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3929383421), "AI3_Min", 
(::AI084.AI3_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3594034852), "AI3_Max", 
(::AI084.AI4Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3501068852), "AI4Config", 
(::AI084.AI4_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(873142028), "AI4_Freq", 
(::AI084.AI4_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1477803501), "AI4_Min", 
(::AI084.AI4_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1679311540), "AI4_Max", 
(::AI084.AI5Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1993939328), "AI5Config", 
(::AI084.AI5_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4283942057), "AI5_Freq", 
(::AI084.AI5_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1702188125), "AI5_Min", 
(::AI084.AI5_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1501063940), "AI5_Max", 
(::AI084.AI6Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1194394397), "AI6Config", 
(::AI084.AI6_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2042869255), "AI6_Freq", 
(::AI084.AI6_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(584396429), "AI6_Min", 
(::AI084.AI6_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(517476820), "AI6_Max", 
(::AI084.AI7Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3779463337), "AI7Config", 
(::AI084.AI7_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2996790690), "AI7_Freq", 
(::AI084.AI7_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(531957565), "AI7_Min", 
(::AI084.AI7_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(599275620), "AI7_Max", 
(::AI084.AI8Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(386824256), "AI8Config", 
(::AI084.AI8_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1137301367), "AI8_Freq", 
(::AI084.AI8_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2649067756), "AI8_Min", 
(::AI084.AI8_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2716381109), "AI8_Max", 
END_FUNCTION


#define USER_CNT_AI084 25

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AI084] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AI084::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AI084;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetFWVersion();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= AI084();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL AI084::UpdateRt
  VAR
  	TempReadData : t_ReadData;
  END_VAR
  
  TempReadData := pReadData^;

  // set Status
  FWErrorBits.ErrorBits := TempReadData.Status;
  
  if (TempReadData.Error.CableBreakAI1) | (TempReadData.Error.OverRangeAI1) then
    AI1 := AI084_INVALID_VALUE;
  else
    if ScaleAI1 then
      AI1 := AI1_Min + (aAIRange[0] * (TempReadData.AnalogIn1 - aAIMinValue[0])) / (AI084_FIRMWARE_MAX - aAIMinValue[0]);
    else
      AI1 := TempReadData.AnalogIn1;
    end_if;    
  end_if;
  
  if (TempReadData.Error.CableBreakAI2) | (TempReadData.Error.OverRangeAI2) then
    AI2 := AI084_INVALID_VALUE;
  else
    if ScaleAI2 then
      AI2 := AI2_Min + (aAIRange[1] * (TempReadData.AnalogIn2 - aAIMinValue[1])) / (AI084_FIRMWARE_MAX - aAIMinValue[1]);
    else
      AI2 := TempReadData.AnalogIn2;
    end_if;    
  end_if;
  
  if (TempReadData.Error.CableBreakAI3) | (TempReadData.Error.OverRangeAI3) then
    AI3 := AI084_INVALID_VALUE;
  else
    if ScaleAI3 then
      AI3 := AI3_Min + (aAIRange[2] * (TempReadData.AnalogIn3 - aAIMinValue[2])) / (AI084_FIRMWARE_MAX - aAIMinValue[2]);
    else
      AI3 := TempReadData.AnalogIn3;
    end_if;    
  end_if;
  
  if (TempReadData.Error.CableBreakAI4) | (TempReadData.Error.OverRangeAI4) then
    AI4 := AI084_INVALID_VALUE;
  else
    if ScaleAI4 then
      AI4 := AI4_Min + (aAIRange[3] * (TempReadData.AnalogIn4 - aAIMinValue[3])) / (AI084_FIRMWARE_MAX - aAIMinValue[3]);
    else
      AI4 := TempReadData.AnalogIn4;
    end_if;    
  end_if;
  
  if (TempReadData.Error.CableBreakAI5) | (TempReadData.Error.OverRangeAI5) then
    AI5 := AI084_INVALID_VALUE;
  else
    if ScaleAI5 then
      AI5 := AI5_Min + (aAIRange[4] * (TempReadData.AnalogIn5 - aAIMinValue[4])) / (AI084_FIRMWARE_MAX - aAIMinValue[4]);
    else
      AI5 := TempReadData.AnalogIn5;
    end_if;    
  end_if;
  
  if (TempReadData.Error.CableBreakAI6) | (TempReadData.Error.OverRangeAI6) then
    AI6 := AI084_INVALID_VALUE;
  else
    if ScaleAI6 then
      AI6 := AI6_Min + (aAIRange[5] * (TempReadData.AnalogIn6 - aAIMinValue[5])) / (AI084_FIRMWARE_MAX - aAIMinValue[5]);
    else
      AI6 := TempReadData.AnalogIn6;
    end_if;    
  end_if;
  
  if (TempReadData.Error.CableBreakAI7) | (TempReadData.Error.OverRangeAI7) then
    AI7 := AI084_INVALID_VALUE;
  else
    if ScaleAI7 then
      AI7 := AI7_Min + (aAIRange[6] * (TempReadData.AnalogIn7 - aAIMinValue[6])) / (AI084_FIRMWARE_MAX - aAIMinValue[6]);
    else
      AI7 := TempReadData.AnalogIn7;
    end_if;    
  end_if;
  
  if (TempReadData.Error.CableBreakAI8) | (TempReadData.Error.OverRangeAI8) then
    AI8 := AI084_INVALID_VALUE;
  else
    if ScaleAI8 then
      AI8 := AI8_Min + (aAIRange[7] * (TempReadData.AnalogIn8 - aAIMinValue[7])) / (AI084_FIRMWARE_MAX - aAIMinValue[7]);
    else
      AI8 := TempReadData.AnalogIn8;
    end_if;    
  end_if;

  // set Error server
  CableBreak  := TempReadData.Error;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI084::ConnectEvent

  // start the accesses on the SDIAS (initialize the control byte in the DPRAM)
  if DefaultAccesses.ReadAccess.pControlByte then
    pReadData := DefaultAccesses.ReadAccess.pData$^t_ReadData;

    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;

  eInitSSW := _InitVariables;
  eResponseState := _idle;
  eInitState    := _NotInitialized;

END_FUNCTION


FUNCTION VIRTUAL AI084::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);

  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;   
  
  if eResult = READY then
    
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        case hOffset of
          AI084_ADDR_CFG_FIRMWARE:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;           
        end_case;
        
      SDIAS_SDO_CMD_MEM_READ:
        case hOffset of
          AI084_ADDR_STATE_FIRMWARE:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;
            sStateFirmware := pResponseBuffer^$t_StateFirmware;
        end_case;
    end_case;
    
    if eResponseState <> _valid then
      LogError("@ZZZZ (AI084::ReceiveSDOResponse) Error in response data of SDO");
      eInitSSW := _InitError;      
    end_if;
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@ZZZZ (AI084::ReceiveSDOResponse) Error while writing the firmware configuration");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@ZZZZ (AI084::ReceiveSDOResponse) Error while waiting for the firmware state");
    end_case;
    eInitSSW := _InitError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI084::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      : iprStates;
  END_VAR
  
  eModuleInitState := BUSY;

  CASE eInitSSW OF
//**********************************************************************************************************************************************************
    _InitVariables:
      AI1Config := AI1Config.Read();
      AI2Config := AI2Config.Read();
      AI3Config := AI3Config.Read();
      AI4Config := AI4Config.Read();
      AI5Config := AI5Config.Read();
      AI6Config := AI6Config.Read();
      AI7Config := AI7Config.Read();
      AI8Config := AI8Config.Read();

      if AI1Config = 1 then 
        aAIMinValue[0] := AI084_FIRMWARE_MIN_4000; 
      else 
        aAIMinValue[0] := AI084_FIRMWARE_MIN; 
      end_if;

      if AI2Config = 1 then 
        aAIMinValue[1] := AI084_FIRMWARE_MIN_4000; 
      else 
        aAIMinValue[1] := AI084_FIRMWARE_MIN; 
      end_if;

      if AI3Config = 1 then 
        aAIMinValue[2] := AI084_FIRMWARE_MIN_4000; 
      else 
        aAIMinValue[2] := AI084_FIRMWARE_MIN; 
      end_if;

      if AI4Config = 1 then 
        aAIMinValue[3] := AI084_FIRMWARE_MIN_4000; 
      else 
        aAIMinValue[3] := AI084_FIRMWARE_MIN; 
      end_if;

      if AI5Config = 1 then 
        aAIMinValue[4] := AI084_FIRMWARE_MIN_4000; 
      else 
        aAIMinValue[4] := AI084_FIRMWARE_MIN; 
      end_if;

      if AI6Config = 1 then 
        aAIMinValue[5] := AI084_FIRMWARE_MIN_4000; 
      else 
        aAIMinValue[5] := AI084_FIRMWARE_MIN; 
      end_if;

      if AI7Config = 1 then 
        aAIMinValue[6] := AI084_FIRMWARE_MIN_4000; 
      else 
        aAIMinValue[6] := AI084_FIRMWARE_MIN; 
      end_if;

      if AI8Config = 1 then 
        aAIMinValue[7] := AI084_FIRMWARE_MIN_4000; 
      else 
        aAIMinValue[7] := AI084_FIRMWARE_MIN; 
      end_if;
      
      
      
      AI1_Freq := AI1_Freq.Read();
      AI2_Freq := AI2_Freq.Read();
      AI3_Freq := AI3_Freq.Read();
      AI4_Freq := AI4_Freq.Read();
      AI5_Freq := AI5_Freq.Read();
      AI6_Freq := AI6_Freq.Read();
      AI7_Freq := AI7_Freq.Read();
      AI8_Freq := AI8_Freq.Read();

      sCfgFirmware.StandardModus.AI1_Freq := SetFrequency(AI1_Freq);
      sCfgFirmware.StandardModus.AI2_Freq := SetFrequency(AI2_Freq);
      sCfgFirmware.StandardModus.AI3_Freq := SetFrequency(AI3_Freq);
      sCfgFirmware.StandardModus.AI4_Freq := SetFrequency(AI4_Freq);
      sCfgFirmware.StandardModus.AI5_Freq := SetFrequency(AI5_Freq);      
      sCfgFirmware.StandardModus.AI6_Freq := SetFrequency(AI6_Freq);
      sCfgFirmware.StandardModus.AI7_Freq := SetFrequency(AI7_Freq);
      sCfgFirmware.StandardModus.AI8_Freq := SetFrequency(AI8_Freq); 
      
      AI1_Min := AI1_Min.Read();
      AI1_Max := AI1_Max.Read();
      AI2_Min := AI2_Min.Read();
      AI2_Max := AI2_Max.Read();
      AI3_Min := AI3_Min.Read();
      AI3_Max := AI3_Max.Read();
      AI4_Min := AI4_Min.Read();
      AI4_Max := AI4_Max.Read();
      AI5_Min := AI5_Min.Read();
      AI5_Max := AI5_Max.Read();
      AI6_Min := AI6_Min.Read();
      AI6_Max := AI6_Max.Read();
      AI7_Min := AI7_Min.Read();
      AI7_Max := AI7_Max.Read();
      AI8_Min := AI8_Min.Read();
      AI8_Max := AI8_Max.Read();
      
      //check if calculation is necessary
      if ((AI1Config = 0) & ((AI1_Max <> AI084_FIRMWARE_MAX) | (AI1_Min <> AI084_FIRMWARE_MIN)))
      | ((AI1Config = 1) & ((AI1_Max <> AI084_FIRMWARE_MAX) | (AI1_Min <> AI084_FIRMWARE_MIN_4000))) then
        ScaleAI1 := TRUE;      
      end_if;
      if ((AI2Config = 0) & ((AI2_Max <> AI084_FIRMWARE_MAX) | (AI2_Min <> AI084_FIRMWARE_MIN)))
      | ((AI2Config = 1) & ((AI2_Max <> AI084_FIRMWARE_MAX) | (AI2_Min <> AI084_FIRMWARE_MIN_4000))) then
        ScaleAI2 := TRUE;      
      end_if;
      if ((AI3Config = 0) & ((AI3_Max <> AI084_FIRMWARE_MAX) | (AI3_Min <> AI084_FIRMWARE_MIN)))
      | ((AI3Config = 1) & ((AI3_Max <> AI084_FIRMWARE_MAX) | (AI3_Min <> AI084_FIRMWARE_MIN_4000))) then
        ScaleAI3 := TRUE;      
      end_if;
      if ((AI4Config = 0) & ((AI4_Max <> AI084_FIRMWARE_MAX) | (AI4_Min <> AI084_FIRMWARE_MIN)))
      | ((AI4Config = 1) & ((AI4_Max <> AI084_FIRMWARE_MAX) | (AI4_Min <> AI084_FIRMWARE_MIN_4000))) then
        ScaleAI4 := TRUE;      
      end_if;
      if ((AI5Config = 0) & ((AI5_Max <> AI084_FIRMWARE_MAX) | (AI5_Min <> AI084_FIRMWARE_MIN)))
      | ((AI5Config = 1) & ((AI5_Max <> AI084_FIRMWARE_MAX) | (AI5_Min <> AI084_FIRMWARE_MIN_4000))) then
        ScaleAI5 := TRUE;      
      end_if;      
      if ((AI6Config = 0) & ((AI6_Max <> AI084_FIRMWARE_MAX) | (AI6_Min <> AI084_FIRMWARE_MIN)))
      | ((AI6Config = 1) & ((AI6_Max <> AI084_FIRMWARE_MAX) | (AI6_Min <> AI084_FIRMWARE_MIN_4000))) then
        ScaleAI6 := TRUE;      
      end_if;
      if ((AI7Config = 0) & ((AI7_Max <> AI084_FIRMWARE_MAX) | (AI7_Min <> AI084_FIRMWARE_MIN)))
      | ((AI7Config = 1) & ((AI7_Max <> AI084_FIRMWARE_MAX) | (AI7_Min <> AI084_FIRMWARE_MIN_4000))) then
        ScaleAI7 := TRUE;      
      end_if;
      if ((AI8Config = 0) & ((AI8_Max <> AI084_FIRMWARE_MAX) | (AI8_Min <> AI084_FIRMWARE_MIN)))
      | ((AI8Config = 1) & ((AI8_Max <> AI084_FIRMWARE_MAX) | (AI8_Min <> AI084_FIRMWARE_MIN_4000))) then
        ScaleAI8 := TRUE;      
      end_if;      
      
      aAIRange[0] := AI1_Max - AI1_Min;
      aAIRange[1] := AI2_Max - AI2_Min;
      aAIRange[2] := AI3_Max - AI3_Min;
      aAIRange[3] := AI4_Max - AI4_Min;
      aAIRange[4] := AI5_Max - AI5_Min;
      aAIRange[5] := AI6_Max - AI6_Min;
      aAIRange[6] := AI7_Max - AI7_Min;
      aAIRange[7] := AI8_Max - AI8_Min;
           
      sCfgFirmware.StandardModus.Selection := 0;

      sCfgFirmware.StandardModus.Selection.AI1_Analog_4mA     := AI1Config <> 0;
      sCfgFirmware.StandardModus.Selection.AI2_Analog_4mA     := AI2Config <> 0;
      sCfgFirmware.StandardModus.Selection.AI3_Analog_4mA     := AI3Config <> 0;
      sCfgFirmware.StandardModus.Selection.AI4_Analog_4mA     := AI4Config <> 0;
      sCfgFirmware.StandardModus.Selection.AI5_Analog_4mA     := AI5Config <> 0;
      sCfgFirmware.StandardModus.Selection.AI6_Analog_4mA     := AI6Config <> 0;
      sCfgFirmware.StandardModus.Selection.AI7_Analog_4mA     := AI7Config <> 0;      
      sCfgFirmware.StandardModus.Selection.AI8_Analog_4mA     := AI8Config <> 0;      

      LowRangeLimit := LowRangeLimit.Read();
      if LowRangeLimit < 0 then
        LowRangeLimit := 0;
      elsif LowRangeLimit > 4000 then
        LowRangeLimit := 4000;
      end_if;
      sCfgFirmware.StandardModus.LowRangeLimit := LowRangeLimit$UINT;

      // Increment Messagecounter
      sCfgFirmware.StandardModus.MessageCounter += 1;
      sCfgFirmware.ConfigBits.NewThesholdEnable := TRUE;

      sCfgFirmware.Info.PmbModus                      := FALSE;
      sCfgFirmware.Info.BootloaderUpdateRequ          := FALSE;   
      sCfgFirmware.DataLength                         := sizeof(t_CfgFirmware) - sizeof(t_CfgFirmware.CRC) - sizeof(t_CfgFirmware.DataLength);
      sCfgFirmware.CRC                                := CheckSum_16(pData:=(#sCfgFirmware.Info)$^UINT, uiDataLength:=sCfgFirmware.DataLength, uiCrcStart:=16#FFFF);
      
      if (eInitState = _InvalidConfguration) then
        eInitSSW   := _InitError;
      else
        eInitSSW   := _ConfigModule;      
      end_if;
    
//**********************************************************************************************************************************************************
    _ConfigModule:
      case eResponseState of
        _idle:
          TmpRetcode  := StartWriteSDO(hOffset:=AI084_ADDR_CFG_FIRMWARE, usLength:=sizeof(t_CfgFirmware), pWriteBuffer:=(#sCfgFirmware)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AI084::InitModule) Failed to add write SDO for firmware configuration");
            eInitState := _NoMem;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI084_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (AI084::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          eInitSSW        := _ReadState;
          eResponseState  := _idle;
        //*****************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    _ReadState:
      case eResponseState of
        _idle:
          TmpRetcode  := StartReadSDO(hOffset:=AI084_ADDR_STATE_FIRMWARE, usLength:=sizeof(t_StateFirmware), eCommand:=SDIAS_SDO_CMD_MEM_READ);
          if TmpRetcode = READY then
            udSDOTimeout      := ops.tAbsolute;
            eResponseState := _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AI084::InitModule) Failed to add read SDO for firmware info");
            eInitState := _NoMem;
          end_if; 
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AI084_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (AI084::InitModule) SDO Response timeout read state");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid: 
          if (sStateFirmware.DataLength = (sizeof(t_StateFirmware) - sizeof(t_StateFirmware.CRC) - sizeof(t_StateFirmware.DataLength)))
          |  (sStateFirmware.DataLength = (sizeof(t_StateFirmware) - sizeof(t_StateFirmware.CRC) - sizeof(t_StateFirmware.DataLength) - sizeof(t_StateFirmware.MessageCounter))) then
            if (sStateFirmware.CRC = CheckSum_16(pData:= #sStateFirmware.FirmwareVersion, uiDataLength:= sStateFirmware.DataLength, uiCrcStart:=16#FFFF)) then
              FirmwareVersion := (sStateFirmware.FirmwareVersion and 16#0000FFFF)$HDINT;

              eInitSSW         := _Finish;
              eResponseState   := _idle;

              if sStateFirmware.DataLength >= (sizeof(t_StateFirmware.FirmwareVersion) + sizeof(t_StateFirmware.MessageCounter)) then
                // message counter ist supported by firmware, check it.
                if (sStateFirmware.MessageCounter <> sCfgFirmware.StandardModus.MessageCounter) then
                  eModuleInitState := ERROR;
                  LogError("@ZZZZ (AI084::InitModule) Invalid message counter from Firmware");
                  eInitState := _ClientNotready;
                end_if;

              end_if;
            else
              eModuleInitState := ERROR;
              LogError("@ZZZZ (AI084::InitModule) Invalid checksum at firmware info");
              eInitState := _ClientNotready;
            end_if;
          else
              eModuleInitState := ERROR;
              LogError("@ZZZZ (AI084::InitModule) Invalid length at firmware info");
              eInitState := _ClientNotready;
          end_if;

      end_case;
//**********************************************************************************************************************************************************
    _Finish:
      eInitSSW         := _InitVariables;
      eModuleInitState := READY;
      eInitState      := _ClassOk;
      
//**********************************************************************************************************************************************************
    _InitError:
      eModuleInitState := ERROR; 
      if (eInitState <> _InvalidConfguration) then
        eInitState      := _ClientNotready;
      end_if;  
      
//**********************************************************************************************************************************************************
  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI084::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
	//look if it is right hardware
	if ( udID2Check <> DEVICE_ID_AI084 ) then
		bIsOK := FALSE;
	else
    bIsOK := TRUE;
	end_if;
  
END_FUNCTION

FUNCTION AI084::SetFrequency
	VAR_INPUT
		ClientValue 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Frequency 	: UINT;
	END_VAR
  
  // lookup table for cut off frequency
  case ClientValue of
    6:  Frequency := 10;
    5:  Frequency := 25;
    4:  Frequency := 50;
    3:  Frequency := 100;
    2:  Frequency := 250;
    1:  Frequency := 500;
  else 
        Frequency := 1000;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AI084::DisconnectEvent

  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION AI084::AI084
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL AI084::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE;

END_FUNCTION


FUNCTION VIRTUAL AI084::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_AI084;
  
END_FUNCTION


FUNCTION VIRTUAL AI084::GetFWVersion
	VAR_INPUT
		pData 	: ^CHAR;
		Length 	: UDINT;
	END_VAR
  
  //Check pointer
  if pData then
    //Length of Firmwareversion (HDINT) -> 8Byte +1 byte zero termination
    if Length >= 9 then
      _itoa(udNumber:=FirmwareVersion, pString:=pData);  
    else
      pData^ := 0;
    end_if; 
  end_if;
  
END_FUNCTION
