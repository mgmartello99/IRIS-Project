//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "RetSvrRam"
	Revision           = "1.1"
	GUID               = "{67843DDE-277A-11D4-83FF-00902787C17B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "static RAM, retentive data">
	<Channels>
		<Server Name="Data" GUID="{67843DDF-277A-11D4-83FF-00902787C17B}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\RetSvrRam\Ram.h" Include="false"/>
		</Files>
	</Dependencies>
</Class>
*)
RetSvrRam : CLASS
  //Servers:
	Data 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		pRamAddr 	: ^RamCell;			//! <Variable Comment="pointer to static RAM" Name="pRamAddr"/>
		Version 	: DINT;
  //Functions:
	
	FUNCTION RetSvrRam
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="---------------------- &#13;&#10;---- OLD VERSION ----&#13;&#10;----------------------&#13;&#10; not supported since 02.2002&#13;&#10;" Name="ChkRAM"/>
	FUNCTION GLOBAL ChkRAM;
				//! <Function Comment="---------------------- &#13;&#10;---- OLD VERSION ----&#13;&#10;----------------------&#13;&#10; not supported since 02.2002&#13;&#10;" Name="MakeNewRAMentry"/>
	FUNCTION GLOBAL MakeNewRAMentry
		VAR_INPUT
			udCRC 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pRAM 	: ^RamCell;
		END_VAR;
				//! <Function Comment="&#13;&#10;    EDI -&gt; cell&#13;&#10;    &lt;-AX = data&#13;&#10;" Name="QuickChk"/>
	FUNCTION AWL QuickChk
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="---------------------- &#13;&#10;---- OLD VERSION ----&#13;&#10;----------------------&#13;&#10; not supported since 02.2002&#13;&#10;" Name="SearchRAM"/>
	FUNCTION SearchRAM
		VAR_INPUT
			udCRC32 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pRAMaddr 	: ^RamCell;
		END_VAR;
				//! <Function Comment="---------------------- &#13;&#10;---- OLD VERSION ----&#13;&#10;----------------------&#13;&#10; not supported since 02.2002&#13;&#10;" Name="CompressRAM"/>
	FUNCTION CompressRAM
		VAR_OUTPUT
			udMoved 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Schreibfunktion der Klasse S-RAM bei Version grösser 2&#13;&#10;" Name="WriteNew"/>
	FUNCTION AWL VIRTUAL GLOBAL WriteNew
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="------------------------------------------------&#13;&#10; der Klasse Ram fuer alte Version des S_RAM&#13;&#10;------------------------------------------------&#13;&#10;" Name="Data.Write"/>
	FUNCTION AWL VIRTUAL GLOBAL Data::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB RetSvrRam::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_RETSVRRAM
1$UINT, 1$UINT, (SIZEOF(::RetSvrRam))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(3727704799), "RetSvrRam", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::RetSvrRam.Data.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2607161047), "Data", 
//Clients:
END_FUNCTION


#define USER_CNT_RetSvrRam 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_RetSvrRam] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION RetSvrRam::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_RetSvrRam, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #Write();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #WriteNew();

#pragma warning (default : 74)
	Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= RetSvrRam();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#ifdef LDR_RETSVR

//*********************Inserted from .\code\C_Memory.st*********************



 



(******************************************************************************
*
*	Class RetSvrRam
*	Created: Sigmatek
*	Changes:
*		0.1 => 1.1	/	25.03.2005	/	Mark:	//#SR000
*			make compatible to lasal 2 with #define Lasal2_OBJ in "Memory.h"
*
******************************************************************************)

#include <Rtos_privheader.h>
#include <RTOS_Mem.h>
#include <Rtos_header.h>
#include <LSL_ST_LSLFILE.H> // RTKernel V3.18

#define LASAL2_OBJ			//activate for Lasal2 Library

VAR_EXTERNAL
	aRamHdr			: RAMhdr;
END_VAR




//--------------------------------------------------------------
// im neuen ram die verbindung zum s-ram suchen  (Im Loader)
//--------------------------------------------------------------  
// Wird von allen S-Ram klassen verwendet um das objekt mit den
// Daten zu verbinden

FUNCTION GLOBAL AWL Find_sRam
VAR_INPUT
	CRC32		: UDINT;
END_VAR
VAR_OUTPUT
	pRamAdr		: ^XramCell;
END_VAR;
// neue funktion für den C-IPC
FUNCTION GLOBAL AWL Find_sRamFile
VAR_INPUT
	CRC32		:  UDINT;
	ppRamAdr	: ^UDINT;
	ppFileAdr	: ^pXFileCell_t;
	uiType		: UDINT;				// 0=RamZelle 1=RamExZelle 	
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR;
// liefert S-RAM Version
FUNCTION GLOBAL AWL GetVersion_sRam
VAR_OUTPUT
	Version		: UDINT;
END_VAR;


//
//  ==========================================================
//   ID:= 06145
//   Rev:= 000     09.09.99  a.m.
//   Fix:= 000
//  ==========================================================
//    General Function:  Chn Object Class CONST
//  ==========================================================

FUNCTION RetSvrRam::RetSvrRam
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
VAR
	pObj           : ^OBJ;
	CRC			   : UDINT;
	pFileAdr	   : ^XFileCell;
	result		   : UDINT;		 	
END_VAR

// NEUE VERSION
// Diesen Pointer gibt es seit a.m mit pranz und gradl am 2.2.2002 vergangenheitsbewältigung gemacht hat

IF _S_RAM_Hptr <> 0 then 

  pObj 	:= LSL_GetHdr(this);

	//#SR000 Start
	#ifdef LASAL2_OBJ
		#pragma warning (disable:137)
			CRC:=	pObj^.pObjDsc^.SymName.udCRC;
		#pragma warning (default:137)
	#else
	//#SR000 End
		CRC:=	pObj^.pObjDsc^.udCRC;
	#endif		//#SR000

 version :=(GetVersion_sRam())$DINT;
 if version < 2 then

  pRAMaddr$UDINT:=Find_sRam(CRC)$UDINT;
  
  If  pRAMaddr <> 0 Then
 	// -- Daten im Ram ungültig, initialisieren
    If (pRAMaddr$^XramCell^.udType and 16#80000000) = 0 then
	  pRAMaddr^.udData$dint :=Data;
	  pRAMaddr^.udChk:=pRAMaddr^.udData+pRAMaddr^.udCRC32;
	  	// -- Daten im Ram gültig, Auslesen
	else
	  Data:=pRAMaddr^.udData$dint ;
	end_if; 
	pRAMaddr$^XramCell^.udType:=16#C0000000;    // ganz am ende machen wir uns gültig !
  end_if;		
 else
  
	// suchen oder anlegen eines neuen eintrages
    result := Find_sRamFile(CRC,#pRAMaddr$UDINT,#pFileAdr,0);
    If pRAMaddr <> 0 then
	  if result = 0	then
        If (pFileAdr^.udType and 16#80000000) = 0 then
		 // init data it is new one
	     pRAMaddr^$dint  :=Data;
	     pFileAdr^.udType:=16#C0000000;    // ganz am ende machen wir uns gültig !
		else
		  Data := pRAMaddr^$dint;
	  	end_if;
	  else
		// init data it is new one
	    pRAMaddr^$dint :=Data;
	  end_if;  	
	end_if;
	 // writemethode wird überladen dauert 20sekunden bei 10.000 ramzellen (???)
	//this^.data.pMeth^.write := #WriteNew();

 end_if;

ELSE
   // Kein Sram vorhanden
   TRACE_ERR("no SRAM available on this platform (needed by a retentive-server-sram)");
END_IF;
	ret_code := C_OK;
END_FUNCTION

#ifndef _LSL_USECLISTI

FUNCTION GLOBAL Lock_On VAR_OUTPUT CpuFlgs : DINT; END_VAR;
FUNCTION GLOBAL Lock_Off VAR_INPUT CpuFlgs : DINT; END_VAR;

FUNCTION RetSvrRam::QuickChk
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
    result$udint := input$^RamCell^.udCRC32 + input$^RamCell^.udData;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL RetSvrRam::Data::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
  	udTmp : UDINT;
    cflg : DINT;
  END_VAR

  result := input;

  // do nothing if data doesn't change
  if (input = Data) then
    return;
  end_if;
  
  cflg := Lock_On();
  
  // write data to server channel
  Data := input;
  // check for valid memory pointer, don't copy data if file-system is active
  if (pRamAddr <> NIL) then
    
    if (Version$UINT < 2) then
      // copy data to SRAM
      pRamAddr^.udData := input$UDINT;
      udTmp := pRamAddr^.udCRC32 + input$UDINT;
      pRamAddr^.udChk := udTmp;
    else
      //new version only 4 byte
      pRamAddr^.udChk := input$UDINT;
    end_if;
    
  end_if;
  
  Lock_Off(cflg);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL RetSvrRam::WriteNew
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  VAR
    cflg : DINT;
  END_VAR

  output := input;

  // do nothing if data doesn't change
  if (input <> Data) then
    // write data to server channel
    cflg := Lock_On();
    Data := input;
    // check for valid memory pointer, don't copy if file-system is active
    if (pRamAddr <> NIL) then
      // copy data to SRAM
      pRamAddr^.udChk := input$UDINT;
    end_if;
    Lock_Off(cflg);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL RetSvrRam::WriteNew

#else

//
//    EDI -> cell
//    <-AX = data
FUNCTION AWL RetSvrRam::QuickChk
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

			L.EAX		(EDI+RAMCELL.udCRC32)
			ADD.EAX		(EDI+RAMCELL.udData)

END_FUNCTION

//------------------------------------------------
// der Klasse Ram fuer alte Version des S_RAM
//------------------------------------------------

FUNCTION AWL VIRTUAL GLOBAL RetSvrRam::Data::Write
	VAR_INPUT
	 input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
	  result(EAX) 	: DINT;
	END_VAR

						
			CMP.EAX		Data		// do nothing if data doesn't change
			JE			M_WR_R_NWR
			PSHF
			CLI
			S.EAX		Data		// write data to server channel

			L.ECX		pRAMaddr    // CHK For Valid Memory pointer
			JECXZ		M_WR_NoMem	// don't copy data if file-system is active
			
			cmp.w		version+0,2
			jae			M_WR_NEW

			S.EAX		(ECX+RAMcell.udData) // copy data to SRAM
			L.EDI		(ECX+RAMCELL.udCRC32)
			ADD.EDI		EAX
			S.EDI		(ECX+RAMcell.udChk)
			jmp			M_WR_NoMem
M_WR_NEW
			// new version only 4 byte //
			S.EAX		(ECX) 		// copy data to SRAM
M_WR_NoMem
			POPF

M_WR_R_NWR
END_FUNCTION

//[#ENGLISH]
//Schreibfunktion der Klasse S-RAM bei Version grösser 2
FUNCTION AWL VIRTUAL GLOBAL RetSvrRam::WriteNew
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  
			CMP.EAX		Data		// do nothing if data doesn't change
			JE			M_WR_R_NWR
			S.EAX		Data		// write data to server channel
			L.ECX		pRAMaddr    // CHK For Valid Memory pointer
			JECXZ		M_WR_R_NWR	// don't copy data if file-system is active
			S.EAX		(ECX) 		// copy data to SRAM
M_WR_R_NWR

END_FUNCTION //VIRTUAL GLOBAL RetSvrRam::WriteNew
#endif // _LSL_TARGETARCH_ARM
//---------------------- 
//---- OLD VERSION ----
//----------------------
// not supported since 02.2002
FUNCTION RetSvrRam::CompressRAM
	VAR_OUTPUT
		udMoved 	: UDINT;
	END_VAR
	udMoved :=0; 
END_FUNCTION

//---------------------- 
//---- OLD VERSION ----
//----------------------
// not supported since 02.2002
FUNCTION GLOBAL RetSvrRam::ChkRAM
END_FUNCTION
//---------------------- 
//---- OLD VERSION ----
//----------------------
// not supported since 02.2002
#pragma warning (disable:0073)
FUNCTION GLOBAL RetSvrRam::MakeNewRAMentry
	VAR_INPUT
		udCRC 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pRAM 	: ^RamCell;
	END_VAR
	pRam := NIL;
END_FUNCTION

//---------------------- 
//---- OLD VERSION ----
//----------------------
// not supported since 02.2002
FUNCTION RetSvrRam::SearchRAM
	VAR_INPUT
		udCRC32 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pRAMaddr 	: ^RamCell;
	END_VAR
   pRAMaddr := NIL;
END_FUNCTION
#pragma warning (default:0073)
#else
#pragma warning (disable:0076)
FUNCTION RetSvrRam::RetSvrRam
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
END_FUNCTION
#pragma warning (default:0076)

FUNCTION AWL VIRTUAL GLOBAL RetSvrRam::Data::Write
	VAR_INPUT
		EAX 	: DINT;
	END_VAR
	VAR_OUTPUT
		EAX 	: DINT;
	END_VAR
END_FUNCTION

FUNCTION VIRTUAL GLOBAL RetSvrRam::WriteNew
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
END_FUNCTION
#endif //LDR_RETSVR