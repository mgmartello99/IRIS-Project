//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "ProjectReader"
	Revision           = "0.0"
	GUID               = "{A5F75C36-4BBC-4C10-8B24-A8F3866B125F}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Server0" GUID="NULL" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
</Class>
*)
ProjectReader : CLASS
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		pTable 	: ^void;
		udLength 	: UDINT;
		pStart 	: ^void;
		pORds 	: ^ObjectReader;
		nONs 	: UDINT;
		bOldPrj 	: DINT;			//! <Variable Comment="die Projektliste ist im alten Format angegeben" Name="bOldPrj"/>
  //Functions:
	
	FUNCTION GLOBAL CreateClass
		VAR_INPUT
			pName 	: ^CLexem;
			udRev 	: Revision;
			ppCls 	: ^pClsHdr;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL SetTable;
	
	FUNCTION GLOBAL GetCount
		VAR_OUTPUT
			nEle 	: UINT;
		END_VAR;
	
	FUNCTION MakeCtName
		VAR_INPUT
			pName 	: ^CLexem;
			udRev 	: Revision;
		END_VAR
		VAR_OUTPUT
			pFct 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL CreateClasses
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL CreateONs
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Initialize;
	
	FUNCTION AWL InitClsObj
		VAR_OUTPUT
			state 	: UINT;
		END_VAR;
	
	FUNCTION SkipClassNames
		VAR_OUTPUT
			nEle 	: UDINT;
		END_VAR;
	
	FUNCTION CreateClassesFromONs
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION OpenOnTables
		VAR_INPUT
			nEle 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL _dtor;
	
	FUNCTION GLOBAL LoadIprProgs
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL CheckIprProgs
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL InitOsiClasses
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION ReadPrjInfo;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ProjectReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_PROJECTREADER
0$UINT, 0$UINT, (SIZEOF(::ProjectReader))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(1931374299), "ProjectReader", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::ProjectReader.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
END_FUNCTION


#define USER_CNT_ProjectReader 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ProjectReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ProjectReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

#pragma usingLtd ObjectReader

//{{LSL_IMPLEMENTATION

#include "RTOS_mem.h"
//#include "RTOS_PrivDefs.h"
#include ".\RTOS_PrivHeader.h"
#include "LoaderItf.h"

#pragma using ObjectReader
#pragma using ClassReader
#pragma using IprReader
#pragma using ConnectReader
#pragma using TaskReader

#ifdef LDR_RETSVR
FUNCTION GLOBAL FreeMemoryRetainSvrFile;
#endif

FUNCTION GLOBAL CONFIG_TABLES;    // Name der Projektliste

FUNCTION GLOBAL OpCyclic;

FUNCTION GLOBAL SortCRCMap
  VAR_OUTPUT
    retcode : UDINT;
  END_VAR;

FUNCTION GLOBAL _GetClsList
VAR_OUTPUT
	pCls		: ^CLSHDR;
END_VAR;

FUNCTION GLOBAL TaskReader_ProcessStoredObjs
  VAR_OUTPUT
    ok : UDINT;
  END_VAR;

VAR_EXTERNAL
  pFirstCls : ^ClsHdr;
END_VAR

VAR_GLOBAL
  // Flag, das gesetzt wird wenn eine optionale externe Verbindung 
  // zu einem Server eines nicht existierenden Objekts existiert
  LDR_bExtConnToCltOfNonExistentObj : BOOL; 
END_VAR


//[#DEUTSCH]
//Liest einen Klassennamen aus und legt die Klasse an
FUNCTION GLOBAL ProjectReader::CreateClass
	VAR_INPUT
		pName 	: ^CLexem;
		udRev 	: Revision;
		ppCls 	: ^pClsHdr;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
    ClsRd			: ClassReader;
    pFct			: pVoid;
    pCls      : ^ClsHdr;
  END_VAR

	// search for the global function <class>::CT_
	pFct    := MakeCtName(pName, udRev);
  ppCls^  := NIL;

	IF pFct = NIL THEN
		ret_code := C_OK;	// happens i.e. with HW-container-classes
	ELSE
		pFct	 += sizeof(UDINT);
		ret_code := ClsRd.ReadClass(pFct, ppCls);	// store the function pointer
    
    IF ret_code = C_OK THEN
      pCls  := ppCls^;
      IF pCls = NIL THEN
        ret_code  := C_UNKNOWN_CID; // should not happen, ret_code must be <> C_OK
        RETURN;
      END_IF;

      pCls  := pCls^.pBaseCls;
      IF pCls = NIL THEN
        RETURN;                       // class is installed
      END_IF;
      
      // install the base class of this class
      pName     := pCls $ ^CLexem;
      udRev     := (pName + pName^.Size())$^Revision^;
      IF _LookupClsIdExact(NIL, pName, udRev, 1) = NIL THEN
      ret_code  := CreateClass(pName, udRev, #pCls);
      ELSE
        ret_code := C_OK;
      END_IF;
    ELSE
      TRACE0_ERR("Cannot load class '{0}'", #pName^.Text[0]);
      LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
    END_IF;
	END_IF;

END_FUNCTION //GLOBAL ProjectReader::CreateClass

// "Konstruktor" für die Klasse
FUNCTION GLOBAL ProjectReader::SetTable

	// =====================================================================
	// | Error:  Unresolved external 'Config_table' -  reason : no classes |
	// |         defined in the project                                    |
	// | Fehler: Nicht aufgelöster Verweis 'Config_table' -  	             |
	// |         Grund: Es gibt in dem Projekt keine Klassen               |
	// =====================================================================
//	pTable	:= #NewTable::RTDB_Index();     // see note above!!
  pTable := #CONFIG_TABLES();
	// =====================================================================

  pStart    := pTable;
  udLength  := pTable^ $ UDINT;
  pTable    += sizeof(UDINT);

END_FUNCTION //GLOBAL ProjectReader::SetTable

FUNCTION GLOBAL ProjectReader::GetCount
VAR_OUTPUT
	nEle		: UINT;
END_VAR

	nEle	:= pTable^ $ UINT;
	pTable	+= sizeof(UINT);

END_FUNCTION //GLOBAL ProjectReader::GetCount
//[#ENGLISH]
//This function creates the name of the class descriptor table from the
//class name
//[>pName] name of the class, 0-terminated + CRC32
//[>udRev] class revision
//[<pFct]  pointer to the CT - table
FUNCTION ProjectReader::MakeCtName
	VAR_INPUT
		pName 	: ^CLexem;
#pragma warning (disable : 73)
		udRev 	: Revision;
#pragma warning (default : 73)
	END_VAR
	VAR_OUTPUT
		pFct 	: ^void;
	END_VAR
  VAR
    szFctName	: ARRAY [0..NLNG] OF CHAR;
  END_VAR

// Klasse::CT_ 

 #ifdef OTTOSPEED 
  szFctName[0]$UDINT := 16#5F544340;
  szFctName[4]       := 16#40;       // "@CT_@"
 #else
	_strcpy(#szFctName[0], "@CT_@");	// @CT_@Klasse
 #endif
	_strcpy(#szFctName[5], #pName^.Text[0]);

	pFct		:= _FindFctName(#szFctName[0]);
  
END_FUNCTION // ProjectReader::MakeCtName
// Wenn als Klassenzahl 0 angegeben wird, dann kommen die Klassendefinitionen
// aus den ONs
FUNCTION GLOBAL ProjectReader::CreateClasses
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	ClsRd		: ClassReader;
	pCls		: ^ClsHdr;
END_VAR

	ok	:= FALSE;

	SetTable();

	GetCount();  			// wenn in der Projektliste keine Klassen angegeben sind, dann
                            // wird versucht, sie aus den Objekttabellen zu laden
                            // ToDo: Konfigurationstabellen anpassen, die brauchen keine Klassenliste mehr
  // Klassen aus den ON-Tabellen ermitteln und anlegen
  IF CreateClassesFromONs() = FALSE THEN
    RETURN;
  END_IF;

	pCls	:= _GetClsList();
	WHILE pCls <> NIL DO
		IF ClsRd.CheckClsSyntax(pCls) <> C_OK THEN	// Klassen prüfen (Objektkanäle, Basisklassen)
			RETURN;
		END_IF;
		pCls	:= pCls^.pNxtCls;
	END_WHILE;

	ok	:= TRUE;

END_FUNCTION //GLOBAL ProjectReader::CreateClasses

(*
  Geht die Liste der Klassen durch und initialisiert die OSI Klasse wenn 
  es sich um eine solche handelt
 *)
FUNCTION GLOBAL ProjectReader::InitOsiClasses
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	pCls		: ^ClsHdr;
	ClsRd		: ClassReader;
END_VAR

	ok	:= FALSE;

	pCls	:= _GetClsList();
	WHILE pCls <> NIL DO
		IF ClsRd.CheckOsiClass(pCls) <> C_OK THEN	// OSI Klasse initialisieren
			RETURN;
		END_IF;
		pCls	:= pCls^.pNxtCls;
	END_WHILE;

	ok	:= TRUE;

END_FUNCTION //GLOBAL ProjectReader::InitOsiClasses

FUNCTION GLOBAL ProjectReader::CreateONs
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	i,
	nEle	: UDINT;
	pObjRd	: ^ObjectReader;
END_VAR

	ok	:= FALSE;

  IF pORds = NIL THEN       // Klassen sind direkt angegeben, und ohne ONs erstellt worden
    nEle		:= GetCount();	// Anzahl der ONs
  
    IF OpenOnTables(nEle) = FALSE THEN
      RETURN;
    END_IF;
  ELSE                      // Klassen sind aus den Listen in den ONs erstellt worden
    nEle    := nONs;
  END_IF;
  
  // Das Verzeichnis mit den Initialisierungswerten erstellen
  IF ConnectReader::ProcessConnectionFile(ConnectReader::PRJCFG_CREATE_INITVAL_DICT) = FALSE THEN
    RETURN;
  END_IF;

	pObjRd		:= pORds;

	FOR i:=1 TO nEle DO
		IF pObjRd^.CreateOn() = FALSE THEN
			RETURN;
		END_IF;
		pObjRd	+= sizeof(ObjectReader);
	END_FOR;

  // Das Verzeichnis mit den Initialisierungswerten zerstören
  IF ConnectReader::ProcessConnectionFile(ConnectReader::PRJCFG_DESTROY_INITVAL_DICT) = FALSE THEN
    RETURN;
  END_IF;

  if(SortCRCMap() <> 0) then
    return; // error in map ("objectcrc nicht eindeutig" oder "zu viele objekte")
  end_if;

  IF !!TaskReader_ProcessStoredObjs() THEN
    RETURN;
  END_IF;

#ifdef LDR_RETSVR
  FreeMemoryRetainSvrFile();
#endif

	pObjRd		:= pORds;		// ON - Tabellen erneut durchlaufen

  LDR_bExtConnToCltOfNonExistentObj := FALSE;
	FOR i:= 1 TO nEle DO
		IF pObjRd^.SetExternConnection() = FALSE THEN
			RETURN;
		END_IF;
		pObjRd	+= sizeof(ObjectReader);
	END_FOR;
  // Wenn externe Verbindungen zu Servern von nicht existierenden Objekten vorhanden sind, 
  // dann wird erst hier abgebrochen, damit in der Debugger-Trace Ausgabe alle falschen 
  // Verbindungen angezeigt werden.
  IF LDR_bExtConnToCltOfNonExistentObj THEN
    RETURN;
  END_IF;
  
  // Textfile mit der Verbindungsliste einlesen und Verbindungen herstellen
  IF ConnectReader::ProcessConnectionFile(ConnectReader::PRJCFG_CONNECT) = FALSE THEN
    RETURN;
  END_IF;

  IF ConnectReader::ChkOpenConnections(pORds, nEle) = FALSE THEN
    RETURN;
  END_IF;
  
  IF TaskReader::BuildUpdateLists() = FALSE THEN  // Pre/Postscan
    RETURN;
  END_IF;
  
	ok	:= TRUE;

END_FUNCTION //GLOBAL ProjectReader::CreateONs


// Wartet, bis alle required MM Server initialisiert sind, oder eine 
// Zeitüberschreitung festgestellt wird.
FUNCTION WaitForRequiredMMServer
VAR
  udStartTime_ms : UDINT;
END_VAR

  udStartTime_ms := ops.tabsolute;
  OPS.SysState := C_RUNRAM;
  
  WHILE !!MM_AreAllReqInitialised(udStartTime_ms) DO
    OpCyclic();
    OS_SSR_Delay(1);
  END_WHILE;

END_FUNCTION


FUNCTION GLOBAL ProjectReader::Initialize
VAR
	usClsInit		: USINT;
END_VAR

	// wir rufen 11 mal mit firstscan = 0 init auf damit sich auch 
	// neue Verbindugen aufbauen können und wir die reihenfolge der init nicht wissen
	FOR usClsInit := 0 TO 10 DO		// for a deeper hierarchy of objects
		InitClsObj();		
	END_FOR;

  // Warten, bis alle required MM Server initialisiert sind
  WaitForRequiredMMServer();

	// jetzt kommt das letzte init mit firstscan = 1
	_firstscan := 1;
  
  MM_PrepareForFirstInit();
  
	InitClsObj();
  
  MM_FirstInitFinished();

END_FUNCTION
//    Call the init-method of all objects to enable initialization for them.
//
#ifdef _LSL_TARGETARCH_ARM
FUNCTION ProjectReader::InitClsObj
VAR_OUTPUT
	state			: UINT;
END_VAR
VAR
  pClass : ^ClsHdr;
  pObj   : ^OBJ;
  pThis  : ^VirtualBase;
END_VAR

  pClass := pFirstCls;            // --> to first class
  while(pClass <> NIL) do         // classloop
  
    if(pClass^.nObjs <> 0) then   // is there any object ?
      pObj := pClass^.pFirstObj;  // --> to fist object of class
      while(pObj <> NIL) do       // objectloop
        pThis := pObj + sizeof(OBJ);
        pThis^.Init();
        pObj := pObj^.pNxtObj;    // next object
      end_while;
    end_if; 
    
    pClass := pClass^.pNxtCls;    // next class
  end_while;
  
  state := C_IS_CON;
  
END_FUNCTION

#else

FUNCTION AWL ProjectReader::InitClsObj
VAR_OUTPUT
	state			: UINT;
END_VAR
VAR
  MyCounter : UDINT;
END_VAR

// wir hanteln uns durch 2 schleifen
// 1. alle klassen und 
// 2.darinnen alle objekte

  L.D     MyCounter, 1

	L.EAX   pFirstCls   // ToDo: _GetClsList verwenden
	L.EDI		EAX

Ini_ClsLP
	O.EDI		EDI
	JZ			init_end		// das war die letzte klasse --> pfirti
  
  L.AX   (EDI + ClsHdr.nObjs)
  O.AX    AX
  JZ      Ini_NxtCls  // die Klasse beinhaltet keine Objekte, OSI - Klassen haben pFirstObj <> NIL!
  
	L.EAX		(EDI + ClsHdr.pFirstObj)
  
Ini_ObjLP
	O.EAX		EAX
	JZ			Ini_NxtCls		// Das war das letzte objekt der klasse
	PUSH		EAX
	PUSH		EDI
	L.ESI		EAX
	ADD.ESI	sizeof(obj)		// Das ist jetzt der This Pointer
	L.EDI		(ESI)			    //  Methodentabelle
	CALL		(EDI + CmdMeth.Init) // endlich können wir zur tat schreiten !!!
	POP			EDI
	POP			EAX
  
  INC.D   MyCounter
  
	L.EAX		(EAX + Obj.pNxtObj)		// nächstes Objekt der Klasse
	jmp			Ini_ObjLP

Ini_NxtCls
	L.EDI		(EDI + ClsHdr.pNxtCls)	// Nächste klasse durchwursteln
	JMP			INI_ClsLP
init_end
	L.W			state, C_IS_CON
END_FUNCTION
#endif

// zum Testen werden aus der alten ConfigTable die Klassen-Daten überlesen
FUNCTION ProjectReader::SkipClassNames
	VAR_OUTPUT
		nEle 	: UDINT;
	END_VAR
  VAR
    pOn   : ^void;
    nAttr : UINT;
  END_VAR

  pTable -= sizeof(UINT); // Anzahl ist auf 0 gesetzt worden (zum Testen), neu lesen
  nEle  := pTable^ $ UINT;
  pTable += sizeof(UINT);
  
  WHILE nEle > 0 DO
    pTable += 2 * sizeof(UINT);
    pTable += _strlen(pTable $ ^char)+1;
    nEle   -= 1;
  END_WHILE;

  nEle  := 0;
  pOn   := pTable;
  
  // alle ONs durchlaufen
  WHILE ((pTable $ UDINT) - (pStart $ UDINT))$ DINT < (udLength $ DINT) DO
    nAttr := pTable ^$ UINT;
    IF (nAttr AND ONE_CFG) = 0 THEN
      EXIT;
    END_IF;
    pTable  += 2 * sizeof(UINT);    // Cfg - Attribut und Revision überlesen
    pTable  += _strlen(pTable $ ^char) + 1;
    nEle    += 1;
  END_WHILE;
  
  pTable  := pOn;   // Tabellenzeiger auf den 1. ON-Eintrag stellen

END_FUNCTION

FUNCTION ProjectReader::CreateClassesFromONs
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    nEle    : UDINT;
    pObjRd  : ^ObjectReader;
  END_VAR

  ok    := FALSE;
  bOldPrj := TRUE;
  nEle  := SkipClassNames();    // hier gehört die Anzahl der ONs ausgelesen
  
  IF OpenOnTables(nEle) = FALSE THEN  // Tabellen-Pointer speichern
    RETURN;
  END_IF;
  
  // Projekt-Info (Versionsnummer und Projektname) auslesen (falls vorhanden)
  ReadPrjInfo();
  
  pObjRd  := pORds;
  FOR nEle:=1 TO nONs DO
    IF pObjRd^.GetUsedClasses() = FALSE THEN
      RETURN;
    END_IF;
    pObjRd  += sizeof(ObjectReader);
  END_FOR;
  
  ok  := TRUE;
  
END_FUNCTION

// In einer Schleife werden alle ON-Tabellen gesucht und ein Zeiger
// darauf in einem ObjectReader - Objekt gespeichert.
FUNCTION ProjectReader::OpenOnTables
	VAR_INPUT
		nEle 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    pFct		  : ^void;
   #ifndef OTTOSPEED
    szFctName	: ARRAY[0..NLNG*2] OF CHAR;
   #endif
    pObjRd    : ^ObjectReader;
  END_VAR

  ok  := FALSE;
	pORds		:= LDR_alloc_descr(nEle * sizeof(ObjectReader)) $ ^ObjectReader;
	IF pORds = NIL THEN			// Liste mit allen ON - Tabellen im Projekt
    IF nEle = 0 THEN
      ok  := TRUE;        // es könnten irgendwelche Sourcen ohne Klassen und Objekten existieren
      TRACE_WARN("No objects are created in this project");
      LSLCLI_LoaderTracePrint("No objects are created in this project", 12);
    END_IF;
		RETURN;
	END_IF;

  _memset(pORds, 0, sizeof(ObjectReader) * nEle);
  pObjRd  := pORds;
  nONs    := nEle;
  
  WHILE nEle > 0 DO
    IF bOldPrj THEN   // Flags und 2 Byte Revision überlesen
      pTable  += sizeof(UDINT);
    END_IF;

   #ifdef OTTOSPEED
    pFct := _FindFctName(pTable$^char);
    IF pObjRd^.SetTable(pFct) = FALSE THEN
      TRACE0_ERR("Cannot open configuration table for ON '{0}'", pTable$^char);
      LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
      RETURN;
    END_IF;
   #else
    _strcpy(#szFctName[0], pTable $ ^char);
 //	_strcat(#szFctName[0], "@NewTable");
  
    pFct		:= _FindFctName(#szFctName[0]);
  
    IF pObjRd^.SetTable(pFct) = FALSE THEN
      TRACE0_ERR("Cannot open configuration table for ON '{0}'", #szFctName[0]);
      LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
      RETURN;
    END_IF;
   #endif    
    pObjRd  += sizeof(ObjectReader);
    
    pTable  += _strlen(pTable $ ^char) + 1;
    nEle    -= 1;
  END_WHILE;
  
  ok	:= TRUE;
  
END_FUNCTION


FUNCTION GLOBAL ProjectReader::_dtor
VAR
  pObjRd    : ^ObjectReader;
  i         : UDINT;
END_VAR

  pObjRd    := pORds;
  
  FOR i:= 1 TO nONs DO
    pObjRd^._dtor();
    pObjRd  += sizeof(ObjectReader);
  END_FOR;
  
  _free(pORds);
  pORds := NIL;
  
END_FUNCTION

// zu ladende Ipr-Liste öffnen, und Programme prüfen bzw. laden
FUNCTION GLOBAL ProjectReader::LoadIprProgs
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    pIpr        : ^void;
    IprRd       : IprReader;
  END_VAR

  ok  := FALSE;
  
  pIpr  := _FindFctName("IPR_CONF");
  IF pIpr = NIL THEN
    RETURN;
  END_IF;
  
  IF IprRd.IprInit(pIpr) = FALSE THEN  // setup interpreter objects
    RETURN;
  END_IF;

  IF IprRd.LoadProgs() = FALSE THEN
    RETURN;
  END_IF;
  
  ok  := TRUE;
  
END_FUNCTION
// Validate IPR-programs, reload them if necessary
//
FUNCTION GLOBAL ProjectReader::CheckIprProgs
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
VAR
  IprRd     : IprReader;
END_VAR

	IF ops.pProg THEN
    ok  := IprRd.CheckIprProgs();
	ELSE
		ok	:= TRUE;
	END_IF;

END_FUNCTION

VAR_PRIVATE
  g_prjInfoAvailable : BOOL;
  g_prjRevHi : BYTE;
  g_prjRevLo : BYTE;
  g_pPrjName : ^CHAR;
END_VAR

(* 
  Liest die Version und den Namen des Lasal-Projekts aus der Tabelle CONFIG_OBJECTS aus 
  und speichert die ausgelesene Info in globalen Variablen. 
  Der Tabelleneintrag in der CONFIG_OBJECTS für die Projektinfo schaut folgendermaßen aus:
    PRJ_CFG$UINT, Rev-Hi, Rev-Lo, "Projektname"
  
  Die Membervariable pTable muss bereits auf einen Eintrag nach der Klassenliste zeigen. 
  Sie wird durch den Aufruf dieser Methode nicht verändert.
*)
FUNCTION ProjectReader::ReadPrjInfo
  VAR
    pWork : ^void;
    nAttr : UINT;
  END_VAR

  // Default-Wert für den Fall, dass die Projektinfo nicht vorhanden ist
  g_prjInfoAvailable := FALSE;
  
  pWork := pTable;

  // alle Einträge durchlaufen, bis man auf PRJ_CFG trifft
  WHILE ((pWork $ UDINT) - (pStart $ UDINT))$ DINT < (udLength $ DINT) DO
    nAttr := pWork^$UINT;
    IF (nAttr AND (ONE_CFG OR TASK_CFG OR IPR_CFG OR PRJ_CFG)) = 0 THEN
      // Bei einem unbekannten Typ eines Tabelleneintrags wird die Schleife abgebrochen, 
      // da man nicht weiß, wie der Aufbau ist.
      EXIT;
    END_IF;
    IF nAttr = PRJ_CFG THEN
      // Tabelleneintrag für die Projektinfo gefunden
      g_prjInfoAvailable := TRUE;
      pWork  += sizeof(UINT);    // Attribut überlesen
      g_prjRevHi := pWork^$BYTE;
      pWork  += sizeof(BYTE);    // Revision-Hi überlesen
      g_prjRevLo := pWork^$BYTE;
      pWork  += sizeof(BYTE);    // Revision-Hi überlesen
      g_pPrjName := pWork$^CHAR;
      EXIT;
    END_IF;
    pWork  += 2 * sizeof(UINT);    // Attribut und Revision überlesen
    pWork  += _strlen(pWork$^CHAR) + 1;
  END_WHILE;

END_FUNCTION

(* Abfrage der Versionsnummer und des Namens des Lasal-Projekts. 

  Wenn keine Projektinfo vorhanden ist (ältere Lasal-Version), dann wird Version 0.0 bzw. 
  ein Leerstring zurückgegeben

  param pRevHi .. Zeiger auf einen Byte-Wert. Wenn <> NIL, dann wird auf diese Speicherstelle 
      die Versionsnummer des Projekts (Rev-Hi) geschrieben.
  param pRevLo .. Zeiger auf einen Byte-Wert. Wenn <> NIL, dann wird auf diese Speicherstelle 
      die Versionsnummer des Projekts (Rev-Lo) geschrieben.
  param ppName .. Zeiger auf einen CHAR-Zeiger. Wenn <> NIL, dann wird dieser Zeiger auf den 
      Projektnamen-String gesetzt.
      
  return TRUE wenn die Projektinfo ermittelt werden konnte, sonst FALSE
*)
FUNCTION GLOBAL LDR_GetPrjInfo
VAR_INPUT
  pRevHi : ^BYTE;
  pRevLo : ^BYTE;
  ppName : ^PCHAR;
END_VAR
VAR_OUTPUT
  result : BOOL;
END_VAR

  result := g_prjInfoAvailable;

  IF g_prjInfoAvailable THEN
    IF pRevHi <> NIL THEN
      pRevHi^ := g_prjRevHi;
    END_IF;
    IF pRevLo <> NIL THEN
      pRevLo^ := g_prjRevLo;
    END_IF;
    IF ppName <> NIL THEN
      ppName^ := g_pPrjName;
    END_IF;
  END_IF;

END_FUNCTION


