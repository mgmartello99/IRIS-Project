//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Manager_globale"
	Revision           = "0.0"
	GUID               = "{72B66E46-0639-4CDC-A2D9-B7755D524D6D}"
	RealtimeTask       = "false"
	DefRealtime        = "100 ms"
	CyclicTask         = "true"
	DefCyclictime      = "100 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(758,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{9602F654-176B-4684-9861-88C75064F1A2}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ComandoGeneraleIRIS" GUID="{7F3F92FC-A2BF-40FF-A8F5-E25F8143BCA2}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ComandoIrradiation" GUID="{2FEC62E5-0688-4C61-BDBE-93758BD1D548}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ComandoMeasurement" GUID="{750E1E23-B9AE-4212-A907-0C2EC7E13F74}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ComandoRecoupledM3" GUID="{2579AF24-461B-4C50-801E-A8B3555EB87E}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Enable" GUID="{C22760BA-98B8-41A2-BB6B-4126603D30EC}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="c_ResetTimer" Required="true" Internal="false"/>
		<Client Name="Comando_main_sequence" Required="true" Internal="false"/>
		<Client Name="Reset_IN" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\Manager_globale\Variabili.h" Include="true"/>
		</Files>
	</Dependencies>
</Class>
*)
Manager_globale : CLASS
	TYPE
	  t_IrradiationPhase :  //! <Type Public="true" Name="t_IrradiationPhase"/>
	  (
	    Irradiation_Idle,
	    Irradiation_Start:=10,
	    Irradiation_Over:=20
	  )$UDINT;
	  t_Manager_globale_state :  //! <Type Public="true" Name="t_Manager_globale_state"/>
	  (
	    Idle,
	    Start:=10,
	    Charge:=20,
	    Irradiation:=30,
	    Discharge:=40,
	    Reset:=60,
	    ErrorState:=70,
	    Stop:=80
	  )$UDINT;
	  t_MeasurementPhase :  //! <Type Public="true" Name="t_MeasurementPhase"/>
	  (
	    Measurement_Idle,
	    Measurement_Start:=10,
	    Measurement_Over:=20
	  )$UDINT;
	  t_ReCoupleM3 :  //! <Type Public="true" Name="t_ReCoupleM3"/>
	  (
	    RecoupledM3_idle:=0,
	    RecoupledM3_Startmoving:=10,
	    RecoupledM3_moving:=20,
	    RecoupledM3_ok:=30
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	ComandoGeneraleIRIS 	: SvrCh_t_Manager_globale_state_PTofCls_Manager_globale;
	ComandoIrradiation 	: SvrCh_t_IrradiationPhase_PTofCls_Manager_globale;
	ComandoMeasurement 	: SvrCh_t_MeasurementPhase_PTofCls_Manager_globale;
	ComandoRecoupledM3 	: SvrCh_t_ReCoupleM3_PTofCls_Manager_globale;
	Enable 	: SvrCh_DINT;
  //Clients:
	Comando_main_sequence 	: CltChCmd_MainSequence;
	Reset_IN 	: CltCh_DINT;
	c_ResetTimer 	: CltCh_DINT;
  //Variables:
		CaseManagerGlobale 	: t_Manager_globale_state;
		CaseIrradiationPhase 	: t_IrradiationPhase;
		v_IrradiationStartOver 	: BOOL;
		v_MeasurementStartOver 	: BOOL;
		CaseMisurationPhase 	: t_MeasurementPhase;
		CaseRecoupledM3 	: t_ReCoupleM3;
		v_recoupledM3 	: DINT;
		v_Enable 	: DINT;
		v_Reset 	: DINT;
		v_block 	: BOOL;
  //Functions:
	
	FUNCTION Manager_globale
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetSequenceStep
		VAR_INPUT
			Cmd 	: t_Manager_globale_state;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL SetIrradiationState
		VAR_INPUT
			Param 	: t_IrradiationPhase;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ComandoGeneraleIRIS::Read
		VAR_OUTPUT
			output (EAX) 	: Manager_globale::t_Manager_globale_state;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ComandoIrradiation::Read
		VAR_OUTPUT
			output (EAX) 	: Manager_globale::t_IrradiationPhase;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ComandoMeasurement::Read
		VAR_OUTPUT
			output (EAX) 	: Manager_globale::t_MeasurementPhase;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ComandoRecoupledM3::Read
		VAR_OUTPUT
			output (EAX) 	: Manager_globale::t_ReCoupleM3;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Enable::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd MainSequence


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Manager_globale::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_MANAGER_GLOBALE
0$UINT, 0$UINT, (SIZEOF(::Manager_globale))$UINT, 
6$UINT, 3$UINT, 0$UINT, 
TO_UDINT(3218456232), "Manager_globale", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Manager_globale.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::Manager_globale.ComandoGeneraleIRIS.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3803422125), "ComandoGeneraleIRIS", 
(::Manager_globale.ComandoIrradiation.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3294093785), "ComandoIrradiation", 
(::Manager_globale.ComandoMeasurement.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2271586944), "ComandoMeasurement", 
(::Manager_globale.ComandoRecoupledM3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3286020341), "ComandoRecoupledM3", 
(::Manager_globale.Enable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(56102836), "Enable", 
//Clients:
(::Manager_globale.Comando_main_sequence.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2177663030), "Comando_main_sequence", TO_UDINT(1203230383), "MainSequence", 0$UINT, 0$UINT, 
(::Manager_globale.Reset_IN.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3981161935), "Reset_IN", 
(::Manager_globale.c_ResetTimer.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4289303837), "c_ResetTimer", 
END_FUNCTION


#define USER_CNT_Manager_globale 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Manager_globale] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Manager_globale::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Manager_globale, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ComandoGeneraleIRIS.pMeth			:= StoreMethod( #ComandoGeneraleIRIS::Read(), #M_WR_DIRECT() );
	IF ComandoGeneraleIRIS.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ComandoIrradiation.pMeth			:= StoreMethod( #ComandoIrradiation::Read(), #M_WR_DIRECT() );
	IF ComandoIrradiation.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ComandoMeasurement.pMeth			:= StoreMethod( #ComandoMeasurement::Read(), #M_WR_DIRECT() );
	IF ComandoMeasurement.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ComandoRecoupledM3.pMeth			:= StoreMethod( #ComandoRecoupledM3::Read(), #M_WR_DIRECT() );
	IF ComandoRecoupledM3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Enable.pMeth			:= StoreMethod( #Enable::Read(), #M_WR_DIRECT() );
	IF Enable.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= Manager_globale();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL Manager_globale::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  CaseManagerGlobale:=ComandoGeneraleIRIS.Read();
  CaseIrradiationPhase:=ComandoIrradiation.Read();
  CaseMisurationPhase:=ComandoMeasurement.Read();
  CaseRecoupledM3:=ComandoRecoupledM3.Read();
  
  
  v_Reset:=Reset_IN.Read();
  v_Enable:=Enable.Read();
  
  if v_Enable then
  
    
    
    case CaseManagerGlobale of
  
  //===========================================================================================
  
  Idle:
    c_ResetTimer.Write(input:=0);
    if v_block=1 then
      ComandoGeneraleIRIS.Write(input:=ErrorState);
    end_if;

  //===========================================================================================
  
  Start:

    if v_block=1  then
      ComandoGeneraleIRIS.Write(input:=ErrorState);
    else
      Comando_main_sequence.SetSequenceState(Cmd:=Cmd_start);
    end_if;

    
  //===========================================================================================
  
  Charge:
    if v_block=1 then
      ComandoGeneraleIRIS.Write(input:=ErrorState);
    else
      Comando_main_sequence.SetSequenceState(Cmd:=MainSequence::Cmd_charge);
    end_if;

  //===========================================================================================
  
  Irradiation:
  
    if v_block=1  then
      ComandoGeneraleIRIS.Write(input:=ErrorState);
    else
      Comando_main_sequence.SetSequenceState(Cmd:=MainSequence::Cmd_irradiation);
      
      case CaseIrradiationPhase of
      
        Irradiation_Idle://attesa comando esterno
          v_IrradiationStartOver:=0;
      
        Irradiation_Start:
          v_IrradiationStartOver:=1;
          Comando_main_sequence.SetIrradiationStartOver(Status:=v_IrradiationStartOver);//inizia l'irraggiamento
          //Comando per comandare la posizione del collimatore qualcosa del tipo -> s_pos_FCC.write(input:=1);
      
        Irradiation_Over:
          v_IrradiationStartOver:=0; //FORSE NEANCHE SERVE METTERLO A ZERO
          Comando_main_sequence.SetIrradiationStartOver(Status:=v_IrradiationStartOver);//irraggiamento terminato
          CaseIrradiationPhase:=ComandoIrradiation.Write(input:=Irradiation_Idle);
          //Comando per comandare la posizione del collimatore qualcosa del tipo -> s_pos_FCC.write(input:=0);
      end_case;
    
    end_if;
    


//===========================================================================================

  Discharge:
    
    if v_block=1  then
      ComandoGeneraleIRIS.Write(input:=ErrorState);
    else
      Comando_main_sequence.SetSequenceState(Cmd:=MainSequence::Cmd_Discharge);
    
      case CaseMisurationPhase of
      
        Measurement_Idle:
        
        v_MeasurementStartOver:=FALSE;
        
        Measurement_Start:
        
          v_MeasurementStartOver:=TRUE;
          Comando_main_sequence.SetMisurationStartOver(Status:=v_MeasurementStartOver);
        
        Measurement_Over:
        
          v_MeasurementStartOver:=FALSE;
          Comando_main_sequence.SetMisurationStartOver(Status:=v_MeasurementStartOver);
          CaseMisurationPhase:=ComandoMeasurement.Write(input:=Measurement_Idle);
        
      end_case;
    end_if;

//===========================================================================================
  Stop:

    ComandoGeneraleIRIS.Write(input:=ErrorState);
    v_block:=1;

//===========================================================================================

  ErrorState:

  if v_Reset=1 then
    ComandoGeneraleIRIS.Write(input:=Reset);
  end_if;
  
//===========================================================================================

  Reset:
    v_Reset:=0;
    v_block:=0;
    Comando_main_sequence.SetSequenceState(Cmd:=Cmd_reset);
    c_ResetTimer.Write(input:=1);
    
//===========================================================================================
  
 // end_case;

  //end_if;
end_case;
end_if;
  
	state := READY;

END_FUNCTION


//costruttore BISOGNA CAPIRE BENE A COSA SERVE
FUNCTION Manager_globale::Manager_globale
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;

END_FUNCTION


//Attraverso questa funzione viene creata per essere utilizzate da classi esterne. Attraverso questa è possibile comandare uno stato specifico della macchina a stati della classe
FUNCTION GLOBAL Manager_globale::SetSequenceStep
	VAR_INPUT
		Cmd 	: t_Manager_globale_state;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  ComandoGeneraleIRIS:=Cmd;
  retcode:=true;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Manager_globale::Init
  v_IrradiationStartOver:=FALSE; //false->over | true->start
  v_MeasurementStartOver:=FALSE; //false->over | true->start

  v_recoupledM3:=0;

  ComandoGeneraleIRIS:=Idle;
  CaseRecoupledM3:=RecoupledM3_idle;

  v_Enable:=TRUE;
  v_Reset:=0;

  v_block:=0;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Manager_globale::ComandoGeneraleIRIS::Read
	VAR_OUTPUT
		output (EAX) 	: Manager_globale::t_Manager_globale_state;
	END_VAR

	output := ComandoGeneraleIRIS;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Manager_globale::ComandoIrradiation::Read
	VAR_OUTPUT
		output (EAX) 	: Manager_globale::t_IrradiationPhase;
	END_VAR

	output := ComandoIrradiation;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Manager_globale::ComandoMeasurement::Read
	VAR_OUTPUT
		output (EAX) 	: Manager_globale::t_MeasurementPhase;
	END_VAR

	output := ComandoMeasurement;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Manager_globale::ComandoRecoupledM3::Read
	VAR_OUTPUT
		output (EAX) 	: Manager_globale::t_ReCoupleM3;
	END_VAR

	output := ComandoRecoupledM3;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Manager_globale::Enable::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	output := Enable;

END_FUNCTION


FUNCTION GLOBAL Manager_globale::SetIrradiationState
	VAR_INPUT
		Param 	: t_IrradiationPhase;
	END_VAR
  CaseIrradiationPhase:=Param;
END_FUNCTION
