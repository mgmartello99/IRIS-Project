//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "InitReader"
	Revision           = "0.0"
	GUID               = "{8238D715-1AFB-45C7-90D3-5576EF7EA534}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
	</Channels>
	<Network Name="InitReader">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{A040468C-73A9-476F-90D6-84A71B1FE743}"
				Class      = "ObjectReader"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Server0"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using ObjectReader

InitReader : CLASS
: ObjectReader
  //Servers:
  //Clients:
  //Variables:
		pObjRd 	: ^ObjectReader;
  //Functions:
	
	FUNCTION GLOBAL SetInitValues
		VAR_INPUT
			pObjRd 	: ^ObjectReader;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetInitValueOff
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetInitValueObjNo
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetInitSymbolOff
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetInitSymbolObjNo
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SetInitStrings
		VAR_INPUT
			pObjRd 	: ^ObjectReader;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetInitStringOff
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetInitStringObjNo
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
				//! <Function Comment="Untersucht, ob ein Kanal eines bestimmten Objekts einen Initwert erhalten hat oder nicht." Name="FindIniValue"/>
	FUNCTION GLOBAL FindIniValue
		VAR_INPUT
			pObjRd 	: ^ObjectReader;
			pThis 	: ^VirtualBase;			//! <Variable Comment="Zeiger auf das zu untersuchende Objekt" Name="FindIniValue.pThis"/>
			ppCD 	: ^ChDsc;			//! <Variable Comment="Zeiger auf den zu untersuchenden Kanal" Name="FindIniValue.ppCD"/>
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;			//! <Variable Comment="Kanal dieses Objekts ist initialisiert" Name="FindIniValue.ok"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB InitReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_INITREADER
0$UINT, 0$UINT, (SIZEOF(::InitReader))$UINT, 
0$UINT, 0$UINT, 0$UINT, 
TO_UDINT(4214777842), "InitReader", //Class
TO_UDINT(1461090386), "ObjectReader", 0$UINT, 1$UINT, //Baseclass
//Servers:
//Clients:
END_FUNCTION


#define USER_CNT_InitReader 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_InitReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION InitReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code	:= ObjectReader::@STD();

END_FUNCTION

//{{LSL_IMPLEMENTATION
//[#DEUTSCH]
//Die Initwerte der Objekte im ON setzen
FUNCTION  InitReader::SetInitValues
VAR_INPUT
	pObjRd	: ^ObjectReader;
END_VAR
VAR_OUTPUT
	ok		: BOOL;
END_VAR

	this^.pObjRd	:= pObjRd;
  pObjRd^.pInit := pObjRd^.pTable;  // Anfang der Init-Werte merken

	ok	:= 	SetInitValueOff() &
          SetInitValueObjNo() &
          SetInitSymbolOff() &
          SetInitSymbolObjNo();

END_FUNCTION //GLOBAL InitReader::SetInitValues
//[#DEUTSCH]
//Jene Initwerte setzen, die über einen Offset angegeben sind.
FUNCTION  InitReader::SetInitValueOff
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pClt	: ^CltCh;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Initwerte einlesen

		pClt	:= (pObjRd^.GetObjectOff()) $ ^CltCh;		// Offset im ON
		pClt^.dData  := (pObjRd^.GetCount()) $ DINT;	// 4 Byte Daten

		nCon	-= 1;

	END_WHILE;

	ok		:= TRUE;

END_FUNCTION // InitReader::SetInitValueOff
//[#DEUTSCH]
//Setzt die Initwerte von Kanälen, die über eine Objektnummer und den Namen
//gegeben sind.
FUNCTION  InitReader::SetInitValueObjNo
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pThis	: ^VirtualBase;
	pClt	: ^CltCh;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Initwerte einlesen
		pThis	:= pObjRd^.GetObjectNo();
		pClt	:= pObjRd^.GetChPtr(pThis);
		IF pClt = NIL THEN
			RETURN;
		END_IF;

		pClt^.dData	:= (pObjRd^.GetCount()) $ DINT;	// 4 Byte Daten einlesen

		nCon	-= 1;
	END_WHILE;

	ok	:= TRUE;

END_FUNCTION // InitReader::SetInitValueObjNo
//[#DEUTSCH]
//Symbolische Konstante zum Initialisieren verwenden
FUNCTION  InitReader::SetInitSymbolOff
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pClt	: ^CltCh;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Initwerte einlesen

		pClt	:= (pObjRd^.GetObjectOff()) $ ^CltCh;					  // Offset im ON
		pClt^.dData	:= (pObjRd^.GetSymbol()) $ DINT;	// symbolischen Initwert

		nCon	-= 1;

	END_WHILE;

	ok		:= TRUE;


END_FUNCTION // InitReader::SetInitSymbolOff
//[#DEUTSCH]
//Symbolische Konstante zum Initialisieren eines Objekts mit
//einer bestimmten Nummer im ON verwenden
FUNCTION  InitReader::SetInitSymbolObjNo
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pThis	: ^VirtualBase;
	pClt	: ^CltCh;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Initwerte einlesen
		pThis	:= pObjRd^.GetObjectNo();
		pClt	:= pObjRd^.GetChPtr(pThis);
		IF pClt = NIL THEN
			RETURN;
		END_IF;

		pClt^.dData	:= (pObjRd^.GetSymbol()) $ DINT;	// symbolischen Initwert einlesen

		nCon	-= 1;
	END_WHILE;

	ok	:= TRUE;


END_FUNCTION // InitReader::SetInitSymbolObjNo
//[#DEUTSCH]
//Setzt die Init-Werte von VBI - Objekten
FUNCTION  InitReader::SetInitStrings
VAR_INPUT
	pObjRd	: ^ObjectReader;
END_VAR
VAR_OUTPUT
	ok		: BOOL;
END_VAR

	this^.pObjRd	:= pObjRd;

	ok	:= 	SetInitStringOff() &
          SetInitStringObjNo();

END_FUNCTION // InitReader::SetInitStrings
//[#DEUTSCH]
//Setzt die Init-Werte von VirtualBaseInit - Objekten
// As the init-routine is a virtual method it has to be
// called after the constructor
FUNCTION  InitReader::SetInitStringOff
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pObj	: ^VirtualBaseInit;		// VBI - Objekt
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Initwerte einlesen

		pObj	:= (pObjRd^.GetObjectOff()) $ ^VirtualBaseInit;

		// die Init - Daten sind auf 64k beschränkt, die Funktion nimmt aber UDINT
		pObjRd^.InitString(pObj);

		nCon	-= 1;

	END_WHILE;

	ok	:= TRUE;

END_FUNCTION // InitReader::SetInitStringOff
//[#DEUTSCH]
//Setzt die Initwerte von VBI-Objekten, angegeben über Objekt-Nummer und Namen
FUNCTION  InitReader::SetInitStringObjNo
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pObj	: ^VirtualBaseInit;		// VBI - Objekt
	pClt	: ^CltCh;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Initwerte einlesen
		pObj	:= (pObjRd^.GetObjectNo()) $ ^VirtualBaseInit;
		pClt	:= pObjRd^.GetChPtr(pObj $ ^VirtualBase);
		IF pClt = NIL THEN
			RETURN;
		END_IF;

		// die Init - Daten sind auf 64k beschränkt, die Funktion nimmt aber UDINT
		pObjRd^.InitString(pObj);
    //Anm pr 3.7.07:
    //Möglicherweise muss obige Zeile durch die folgende ersetzt werden.
    //(Siehe BS602 - Loader Exception mit einem komplexen VBI Objekt)
		//pObjRd^.InitString(pClt$^VirtualBaseInit);

		nCon	-= 1;

	END_WHILE;

	ok	:= TRUE;

END_FUNCTION // InitReader::SetInitStringObjNo

FUNCTION GLOBAL InitReader::FindIniValue
	VAR_INPUT
		pObjRd 	: ^ObjectReader;
		pThis 	: ^VirtualBase;
		ppCD 	: ^ChDsc;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    udCnt     : UDINT;
    pOnThis   : ^VirtualBase;
    pOnClt,
    pClt      : ^CltCh;
    uiLen     : UINT;
  END_VAR
  
  this^.pObjRd    := pObjRd;
  pObjRd^.pTable  := pObjRd^.pInit;
  
  ok  := FALSE;   // kein Init-Wert vorhanden
  // der Zeiger pInit des InitReaders zeigt auf den Anfang der Init-Werte
  // dort stehen folgende Abschnitte: IniOff, IniObjNo, SymbolOff, SymbolObjNo
  // die String-Initialisierung wird hier nicht untersucht, weil davon nur Objekte betroffen sein können
  // d.h. im bisherigen Anwendungsfall würden die String-Listen immer umsonst untersucht werden
  
  IF pObjRd^.nObjs = 0 THEN
    RETURN;   // in dem ON gibt's keine Objekte
  END_IF;
  
  pClt  := (pThis + ppCD^.pDsc^.uiOff) $ ^CltCh;
  udCnt := pObjRd^.GetCount();
  WHILE udCnt > 0 DO
  
		IF pClt = (pObjRd^.GetObjectOff()) $ ^CltCh THEN		// Offset im ON
      ok  := TRUE;    // Init-Wert ist vorhanden
      RETURN;
    END_IF;
    
		pObjRd^.GetCount();	                  // 4 Byte Daten überlesen
    
    udCnt -= 1;
  END_WHILE;
  
  udCnt := pObjRd^.GetCount();
  WHILE udCnt > 0 DO
		pOnThis	:= pObjRd^.GetObjectNo();
    IF pOnThis = pThis THEN               // Verbindung auf das gesuchte Objekt
      pOnClt	  := pObjRd^.GetChPtr(pOnThis);
      IF pClt = pOnClt THEN
        ok  := TRUE;    // Init-Wert ist vorhanden
        RETURN;
      END_IF;
    ELSE
      pObjRd^.SkipText();	// Kanalnamen überlesen
    END_IF;

		pObjRd^.GetCount();	// 4 Byte Daten einlesen
    udCnt -= 1;
  END_WHILE;
  
  pObjRd^.GetCount();  // Symbole + Offset
  pObjRd^.GetCount();  // Symbole + ObjNo
  
  udCnt := pObjRd^.GetCount();  // Strings + Offset
  
	WHILE udCnt > 0 DO				// alle angegebenen Initwerte einlesen

		IF pClt = (pObjRd^.GetObjectOff()) $ ^CltCh THEN		// Offset im ON
      ok  := TRUE;    // Init-Wert ist vorhanden
      RETURN;
    END_IF;

    // Initialisierungsstring überlesen
		pObjRd^.GetUInt();  // channel type
    uiLen := pObjRd^.GetUInt();  // length
    pObjRd^.pTable  += uiLen;

		udCnt	-= 1;

	END_WHILE;

  udCnt := pObjRd^.GetCount();  // Strings + object number
  
	WHILE udCnt > 0 DO				// alle angegebenen Initwerte einlesen

		pOnThis	:= pObjRd^.GetObjectNo();
    IF pOnThis = pThis THEN               // Verbindung auf das gesuchte Objekt
      pOnClt	  := pObjRd^.GetChPtr(pOnThis);
      IF pClt = pOnClt THEN
        ok  := TRUE;    // Init-Wert ist vorhanden
        RETURN;
      END_IF;
    ELSE
      pObjRd^.SkipText();	// Kanalnamen überlesen
    END_IF;

		// Initialisierungsstring überlesen
		pObjRd^.GetUInt();  // channel type
    uiLen := pObjRd^.GetUInt();  // length
    pObjRd^.pTable  += uiLen;

		udCnt	-= 1;

	END_WHILE;


  
END_FUNCTION
