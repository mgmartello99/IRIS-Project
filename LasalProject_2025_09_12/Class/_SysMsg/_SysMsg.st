//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_SysMsg"
	Revision           = "0.0"
	GUID               = "{2B9B4EB1-BABE-4B61-BD0C-4607C8468574}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "true"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "The functions of the Sysmsg API make it possible for the application to produce errors, warnings and other messages. It is often important that these messages can be viewed later, so that they can be written to a file.">
	<Channels>
		<Server Name="Server0" GUID="{D4350549-287B-4FA0-9F41-53CE9EA3966F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\code\OsiBaseNew.st"/>
			<File Path=".\Source\code\OsiBaseNew.h" Include="false"/>
			<File Path=".\SysMsgTypes.h" Include="false"/>
		</Files>
	</Dependencies>
</Class>
*)
_SysMsg : CLASS
	TYPE
#pragma pack(push, 1)
	  OS_SYSMSG : STRUCT
	    udVersion : UDINT;
	    lcreate : pVoid;
	    lopen : pVoid;
	    lclose : pVoid;
	    res1 : pVoid;
	    lwrite : pVoid;
	    lwriteln : pVoid;
	    lprintfln : pVoid;
	    lwrite_i : pVoid;
	    res2 : pVoid;
	    lflush : pVoid;
	    res3 : pVoid;
	    res4 : pVoid;
	    linfo : pVoid;
	    plprintfln_userlog : pVoid;
	    plwrite_event_userlog : pVoid;
	    plflush_userlog : pVoid;
	    plfileheader_userlog : pVoid;
	    plexport_userlog : pVoid;
	    plastexporterror_userlog : pVoid;
	    res5 : pVoid;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION _SysMsg
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="The OS_SYSMSG_LCREATE function creates a new message buffer object and returns a handle, which can be used to access the object." Name="LCreate"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LCreate
		VAR_INPUT
			nID 	: DINT;			//! <Variable Comment="Specifies the identification number of the message buffer object. Its value must be between 0 and 9. This number is used to construct the file name of the mes-sage file. When more than one message buffers are used, each buffer must have its own identification number." Name="LCreate.nID"/>
			pBuffer 	: ^CHAR;			//! <Variable Comment="Pointer to a buffer where the messages are written to." Name="LCreate.pBuffer"/>
			udBufferSize 	: UDINT;			//! <Variable Comment="Size of the buffer." Name="LCreate.udBufferSize"/>
			dFileQuota 	: DINT;			//! <Variable Comment="Specifies the file-quota of the message file. A value of 0 disables writing the message buffer to a message file. A value of -1 indicates that the system default value should be used." Name="LCreate.dFileQuota"/>
			udFlags 	: UDINT;			//! <Variable Comment="This parameter is reserved for future use and must be set to 0." Name="LCreate.udFlags"/>
		END_VAR
		VAR_OUTPUT
			hLog (EAX) 	: UDINT;			//! <Variable Comment="If the function succeeds, the return value is a handle to the message buffer. Otherwise the return value is 0." Name="LCreate.hLog"/>
		END_VAR;
				//! <Function Comment="The OS_SYSMSG_LOPEN function opens an existing message buffer object and returns a handle that can be used to access the object." Name="LOpen"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LOpen
		VAR_INPUT
			nID 	: DINT;			//! <Variable Comment="Specifies the identification number of the message buffer object. Its value must be between 0 and 9." Name="LOpen.nID"/>
		END_VAR
		VAR_OUTPUT
			hLog (EAX) 	: UDINT;			//! <Variable Comment="If the function succeeds, the return value is a handle to the message buffer. Otherwise the return value is 0." Name="LOpen.hLog"/>
		END_VAR;
				//! <Function Comment="The OS_SYSMSG_LCLOSE function closes an open handle to a message buffer object." Name="LClose"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LClose
		VAR_INPUT
			hLog 	: UDINT;			//! <Variable Comment="Handle to the message buffer object." Name="LClose.hLog"/>
		END_VAR;
				//! <Function Comment="The OS_SYSMSG_LWRITE function writes data to a message buffer." Name="LWrite"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LWrite
		VAR_INPUT
			hLog 	: UDINT;			//! <Variable Comment="Handle to the message buffer object." Name="LWrite.hLog"/>
			udAddTimeStamp 	: UDINT;			//! <Variable Comment="A flag that specifies whether a timestamp should be added to the mes-sage or not. A value of 0 means that no timestamp is added, all other values add a timestamp." Name="LWrite.udAddTimeStamp"/>
			pData 	: ^CHAR;			//! <Variable Comment="Pointer to the data that should be written to the message buffer." Name="LWrite.pData"/>
			udSize 	: UDINT;			//! <Variable Comment="Size of data." Name="LWrite.udSize"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;			//! <Variable Comment="The return value is the number of bytes written to the message buffer." Name="LWrite.result"/>
		END_VAR;
				//! <Function Comment="Writes a null-terminated string to a log-buffer with a new-line character at the end of the data." Name="LWriteln"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LWriteln
		VAR_INPUT
			hLog 	: UDINT;			//! <Variable Comment="Handle to the message buffer object." Name="LWriteln.hLog"/>
			udAddTimeStamp 	: UDINT;			//! <Variable Comment="A flag that specifies whether a timestamp should be added to the mes-sage. A value of 0 means that no timestamp is added, all other values add a timestamp." Name="LWriteln.udAddTimeStamp"/>
			pTxt 	: ^CHAR;			//! <Variable Comment="A pointer to a null-terminated string." Name="LWriteln.pTxt"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;			//! <Variable Comment="The return value is the number of bytes written to the message buffer." Name="LWriteln.result"/>
		END_VAR;
				//! <Function Comment="Print formatted data to a log-buffer. A new-line character is appended to the end of the text." Name="LPrintfln1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LPrintfln1
		VAR_INPUT
			hLog 	: UDINT;			//! <Variable Comment="Handle to the message buffer object." Name="LPrintfln1.hLog"/>
			udAddTimeStamp 	: UDINT;			//! <Variable Comment="A flag that specifies whether a timestamp should be added to the mes-sage. A value of 0 means that no timestamp is added, all other values add a timestamp." Name="LPrintfln1.udAddTimeStamp"/>
			pMsg 	: ^CHAR;			//! <Variable Comment="A null-terminated format control string." Name="LPrintfln1.pMsg"/>
			udParam 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LPrintfln1.udParam"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;			//! <Variable Comment="The return value is the number of characters written, not including the terminating null character, or a negative value if an output error occurs. If the number of characters to write exceeds 256, then 256 characters are written. In this case the message should be divided into more parts." Name="LPrintfln1.result"/>
		END_VAR;
				//! <Function Comment="Print formatted data to a log-buffer. A new-line character is appended to the end of the text." Name="LPrintfln2"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LPrintfln2
		VAR_INPUT
			hLog 	: UDINT;			//! <Variable Comment="Handle to the message buffer object." Name="LPrintfln2.hLog"/>
			udAddTimeStamp 	: UDINT;			//! <Variable Comment="A flag that specifies whether a timestamp should be added to the mes-sage. A value of 0 means that no timestamp is added, all other values add a timestamp." Name="LPrintfln2.udAddTimeStamp"/>
			pMsg 	: ^CHAR;			//! <Variable Comment="A null-terminated format control string." Name="LPrintfln2.pMsg"/>
			udParam1 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LPrintfln2.udParam1"/>
			udParam2 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LPrintfln2.udParam2"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;			//! <Variable Comment="The return value is the number of characters written, not including the terminating null character, or a negative value if an output error occurs. If the number of characters to write exceeds 256, then 256 characters are written. In this case the message should be divided into more parts." Name="LPrintfln2.result"/>
		END_VAR;
				//! <Function Comment="Print formatted data to a log-buffer. A new-line character is appended to the end of the text." Name="LPrintfln3"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LPrintfln3
		VAR_INPUT
			hLog 	: UDINT;			//! <Variable Comment="Handle to the message buffer object." Name="LPrintfln3.hLog"/>
			udAddTimeStamp 	: UDINT;			//! <Variable Comment="A flag that specifies whether a timestamp should be added to the mes-sage. A value of 0 means that no timestamp is added, all other values add a timestamp." Name="LPrintfln3.udAddTimeStamp"/>
			pMsg 	: ^CHAR;			//! <Variable Comment="A null-terminated format control string." Name="LPrintfln3.pMsg"/>
			udParam1 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LPrintfln3.udParam1"/>
			udParam2 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LPrintfln3.udParam2"/>
			udParam3 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LPrintfln3.udParam3"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;			//! <Variable Comment="The return value is the number of characters written, not including the terminating null character, or a negative value if an output error occurs. If the number of characters to write exceeds 256, then 256 characters are written. In this case the message should be divided into more parts." Name="LPrintfln3.result"/>
		END_VAR;
				//! <Function Comment="Print formatted data to a log-buffer. A new-line character is appended to the end of the text." Name="LPrintfln4"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LPrintfln4
		VAR_INPUT
			hLog 	: UDINT;			//! <Variable Comment="Handle to the message buffer object." Name="LPrintfln4.hLog"/>
			udAddTimeStamp 	: UDINT;			//! <Variable Comment="A flag that specifies whether a timestamp should be added to the mes-sage. A value of 0 means that no timestamp is added, all other values add a timestamp." Name="LPrintfln4.udAddTimeStamp"/>
			pMsg 	: ^CHAR;			//! <Variable Comment="A null-terminated format control string." Name="LPrintfln4.pMsg"/>
			udParam1 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LPrintfln4.udParam1"/>
			udParam2 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LPrintfln4.udParam2"/>
			udParam3 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LPrintfln4.udParam3"/>
			udParam4 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LPrintfln4.udParam4"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;			//! <Variable Comment="The return value is the number of characters written, not including the terminating null character, or a negative value if an output error occurs. If the number of characters to write exceeds 256, then 256 characters are written. In this case the message should be divided into more parts." Name="LPrintfln4.result"/>
		END_VAR;
				//! <Function Comment="Writes a string and up to four optional parameters of type UDINT to a log-buffer." Name="LWrite_I"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LWrite_I
		VAR_INPUT
			hLog 	: UDINT;			//! <Variable Comment="Handle to the message buffer object." Name="LWrite_I.hLog"/>
			pTxt 	: ^CHAR;			//! <Variable Comment="A null-terminated format control string. This format string must contain specifi-cations that determine the output format for the arguments. For a description of the format string see the documentation of the printf function in C." Name="LWrite_I.pTxt"/>
			udParam1 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LWrite_I.udParam1"/>
			udParam2 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LWrite_I.udParam2"/>
			udParam3 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LWrite_I.udParam3"/>
			udParam4 	: UDINT;			//! <Variable Comment="Optional arguments." Name="LWrite_I.udParam4"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;			//! <Variable Comment="Returns the length of the string written to the log-buffer." Name="LWrite_I.result"/>
		END_VAR;
				//! <Function Comment="Flushes a log-buffer to a log-file on disk. The data is appended to the end of the log-file. When logging to disk is not enabled, the function returns with an error." Name="LFlush"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LFlush
		VAR_INPUT
			hLog 	: UDINT;			//! <Variable Comment="Handle to the message buffer object." Name="LFlush.hLog"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;			//! <Variable Comment="If the buffer was successfully flushed, OS_SYSMSG_LFLUSH returns 0. The value 0 is also re-turned in cases in which the specified log-buffer has no data. A return value of -1 indicates an error." Name="LFlush.result"/>
		END_VAR;
				//! <Function Comment="Get information about a log-buffer." Name="LInfo"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LInfo
		VAR_INPUT
			hLog 	: UDINT;			//! <Variable Comment="Handle to the message buffer object." Name="LInfo.hLog"/>
			pBufAddr 	: ^UDINT;			//! <Variable Comment="A pointer to a variable where the address of the message buffer is stored (optional)." Name="LInfo.pBufAddr"/>
			pPos 	: ^UDINT;			//! <Variable Comment="A pointer to a variable where the current position in the message buffer is stored (optional)." Name="LInfo.pPos"/>
			pBufSize 	: ^UDINT;			//! <Variable Comment="A pointer to a variable where the size of the message buffer without the preceding control structure is stored (optional)." Name="LInfo.pBufSize"/>
			pNUnflushed 	: ^UDINT;			//! <Variable Comment="A pointer to a variable where the number of bytes that are not written to the message buffer is stored (optional)." Name="LInfo.pNUnflushed"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Writes a message to the low-priority logbuffer." Name="ULPrintfln0"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ULPrintfln0
		VAR_INPUT
			pMsg 	: ^CHAR;			//! <Variable Comment="A null-terminated format control string." Name="ULPrintfln0.pMsg"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;			//! <Variable Comment="The number of bytes written or a negative error code (see lsl_st_sysmsg.h)." Name="ULPrintfln0.result"/>
		END_VAR;
				//! <Function Comment="Writes a message to the low-priority logbuffer." Name="ULPrintfln1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ULPrintfln1
		VAR_INPUT
			pMsg 	: ^CHAR;			//! <Variable Comment="A null-terminated format control string." Name="ULPrintfln1.pMsg"/>
			dParam1 	: DINT;			//! <Variable Comment="Optional arguments." Name="ULPrintfln1.dParam1"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;			//! <Variable Comment="The number of bytes written or a negative error code (see lsl_st_sysmsg.h)." Name="ULPrintfln1.result"/>
		END_VAR;
				//! <Function Comment="Writes a message to the low-priority logbuffer." Name="ULPrintfln2"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ULPrintfln2
		VAR_INPUT
			pMsg 	: ^CHAR;			//! <Variable Comment="A null-terminated format control string." Name="ULPrintfln2.pMsg"/>
			dParam1 	: DINT;			//! <Variable Comment="Optional arguments." Name="ULPrintfln2.dParam1"/>
			dParam2 	: DINT;			//! <Variable Comment="Optional arguments." Name="ULPrintfln2.dParam2"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;			//! <Variable Comment="The number of bytes written or a negative error code (see lsl_st_sysmsg.h)." Name="ULPrintfln2.result"/>
		END_VAR;
				//! <Function Comment="The function writes 5 values to the high-priority logbuffer." Name="ULWriteEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ULWriteEvent
		VAR_INPUT
			hID0 	: USINT;			//! <Variable Comment="Value to write." Name="ULWriteEvent.hID0"/>
			Scancode 	: UINT;			//! <Variable Comment="Value to write." Name="ULWriteEvent.Scancode"/>
			PicNum 	: UINT;			//! <Variable Comment="Value to write." Name="ULWriteEvent.PicNum"/>
			X 	: UINT;			//! <Variable Comment="Value to write." Name="ULWriteEvent.X"/>
			Y 	: UINT;			//! <Variable Comment="Value to write." Name="ULWriteEvent.Y"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;			//! <Variable Comment="Returns the number of bytes written or a negative error code (see lsl_st_sysmsg.h)." Name="ULWriteEvent.result"/>
		END_VAR;
				//! <Function Comment="The function flushes the given logbuffer to disk." Name="ULFlush"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ULFlush
		VAR_INPUT
			LogBuffID 	: DINT;			//! <Variable Comment="LUSER_LOW_PRIO_ID or 1 for the low-priority log buf. &#10;LUSER_HIGH_PRIO_ID or 2 for the high-priority log buf." Name="ULFlush.LogBuffID"/>
			usNonBlocking 	: USINT;			//! <Variable Comment="0 .. The function blocks. &#10;1 .. The function will not block." Name="ULFlush.usNonBlocking"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;			//! <Variable Comment="Returns 0 if it was successful. Otherwise a negative error code will be returned." Name="ULFlush.result"/>
		END_VAR;
				//! <Function Comment="Writes a user file header to the logfile." Name="ULFileHeader"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ULFileHeader
		VAR_INPUT
			pStr 	: ^CHAR;			//! <Variable Comment="The file header message as a null-terminated string." Name="ULFileHeader.pStr"/>
			LogBuffID 	: DINT;			//! <Variable Comment="The Logfile to write the header to." Name="ULFileHeader.LogBuffID"/>
			usNonBlocking 	: USINT;			//! <Variable Comment="0 .. The function blocks. &#10;1 .. The function will not block." Name="ULFileHeader.usNonBlocking"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;			//! <Variable Comment="Returns 0 if it was successful. Otherwise a negative error code will be returned." Name="ULFileHeader.result"/>
		END_VAR;
				//! <Function Comment="Copies all userlog files and the System Eventlog file (ID 0) with backup files to a given path." Name="ULExport"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ULExport
		VAR_INPUT
			pPath 	: ^CHAR;			//! <Variable Comment="The destination path." Name="ULExport.pPath"/>
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;			//! <Variable Comment="Returns 0 if it was successful. Otherwise a negative error code will be returned." Name="ULExport.result"/>
		END_VAR;
				//! <Function Comment="The function is used to get information about the last OS_USERLOG_EXPORT call." Name="ULLastExportResult"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ULLastExportResult
		VAR_INPUT
			pExtResult 	: ^PLUSER_EXPORT_RESULT;			//! <Variable Comment="Pointer to a pointer that points to an OS allocated array that stores the export result." Name="ULLastExportResult.pExtResult"/>
		END_VAR
		VAR_OUTPUT
			ErrCount (EAX) 	: DINT;			//! <Variable Comment="Return the number of errors occurred in the copy process or a negative error code." Name="ULLastExportResult.ErrCount"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _SysMsg::@CT_
0$UINT,
2#0100000000001000$UINT, //TY__SYSMSG
0$UINT, 0$UINT, (SIZEOF(::_SysMsg))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(792524216), "_SysMsg", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_SysMsg.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
END_FUNCTION


#define USER_CNT__SysMsg 20

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__SysMsg] OF ^Void;
	END_STRUCT;
END_TYPE



//{{LSL_IMPLEMENTATION


//*********************Inserted from <.\OS Interface\code\_SysMsg_00_00.st>*********************



 



#include <Rtos_interfaces.h>
#include "..\..\Source\code\OsiBaseNew.h"

FUNCTION  _SysMsg::_SysMsg
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR
VAR
	piSysMsg	:^OS_SYSMSG;
	aMeths	: ARRAY[0..USER_CNT__SysMsg] OF ^void;
	retv    : SYS_ERROR;
END_VAR

	retv := OS_CILGet("SYSMSG", #piSysMsg);

	if retv <> SYS_ERR_NONE then

	  TRACE("ERROR: SYSMSG Interface not available with this version/platform!");
  	  ret_code	:= C_UNKNOWN_CONSTR;

	elsif _RtOSversion < 16#0550 then

	  TRACE("Error: SYSMSG Interface not available with this version/platform! (Needed OS Version >= 5.80)");
	  ret_code	:= C_UNKNOWN_CONSTR;

    else

	  aMeths [0]  := piSysMsg^.lcreate;
	  aMeths [1]  := piSysMsg^.lopen;
	  aMeths [2]  := piSysMsg^.lclose;
	  aMeths [3]  := piSysMsg^.lwrite;
	  aMeths [4]  := piSysMsg^.lwriteln;
	  aMeths [5]  := piSysMsg^.lprintfln;
	  aMeths [6]  := piSysMsg^.lprintfln;
	  aMeths [7]  := piSysMsg^.lprintfln;
	  aMeths [8]  := piSysMsg^.lprintfln;
	  aMeths [9]  := piSysMsg^.lwrite_i;
	  aMeths [10] := piSysMsg^.lflush;
	  aMeths [11] := piSysMsg^.linfo;
      aMeths [12] := piSysMsg^.plprintfln_userlog;
	  aMeths [13] := piSysMsg^.plprintfln_userlog;
	  aMeths [14] := piSysMsg^.plprintfln_userlog;
	  aMeths [15] := piSysMsg^.plwrite_event_userlog;
	  aMeths [16] := piSysMsg^.plflush_userlog;
	  aMeths [17] := piSysMsg^.plfileheader_userlog;
	  aMeths [18] := piSysMsg^.plexport_userlog;
	  aMeths [19] := piSysMsg^.plastexporterror_userlog;

	  ret_code  := InitOsiM_new(#aMeths[0]$void, USER_CNT__SysMsg);

	end_if;

	ret_code	:= C_OK;

END_FUNCTION //  _SysMsg::_SysMsg

