//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "MMServerString"
	Revision           = "0.0"
	GUID               = "{5C9DAB10-153A-4363-8CED-1A2221201B0A}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Data" WriteProtected="false">
		</Server>
		<Client Name="MMServer" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FimLuc"/>
		<Dokumentation Revision="0.0" Date="2015-10-07" Author="FimLuc" Company="Sigmatek" Description="erstellt"/>
	</RevDoku>
	<Network Name="MMServerString">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{56B7E0C3-A983-4054-B6FF-725526DE3913}"
				Class      = "StringInternal"
				Position   = "(780,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Data"/>
					<Client Name="DataBuffer" Value="0"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Data" Destination="_base.Data" Vertices="(1252,210),(1080,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using StringInternal

MMServerString : CLASS
: StringInternal
  //Servers:
  //Clients:
	MMServer 	: CltChCmd_MMServerBase;
  //Variables:
  //Functions:
				//! <Function Comment=" to have a defined state after configuration&#13;&#10; calculate the CRC&#13;&#10;Die CRC wird am Anfang berechnet, um diesen Wert zu initialisieren&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION MMServerString
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment=" returns the length of the raw data (without termination-0)&#13;&#10;liefert die Länge der Strings-Rohdaten ohne Abschluß-Null&#13;&#10;" Name="GetLength"/>
	FUNCTION VIRTUAL GLOBAL GetLength
		VAR_OUTPUT
			udLen 	: UDINT;			//! <Variable Comment="number of characters" Name="GetLength.udLen"/>
		END_VAR;
				//! <Function Comment="The function extracts the given amount of bytes from a string-buffer.&#13;&#10;udAt specifies the starting position. pData is a pointer to a destination&#13;&#10;buffer, which has to be big enough to contain the extracted part.&#13;&#10;Die Funktion kopiert die angegebene Anzahl von Bytes ab dem Offset udAt&#13;&#10;aus dem String in einen zur Verfügung gestellten Ziel-Puffer. Dieser&#13;&#10;Puffer muß ausreichend groß sein, um den extrahierten Teil aufnehmen&#13;&#10;zu können.&#13;&#10;[&gt;udSize] Anzahl der Bytes, die kopiert werden sollen&#13;&#10;" Name="GetDataAt"/>
	FUNCTION VIRTUAL GLOBAL GetDataAt
		VAR_INPUT
			pData 	: ^USINT;			//! <Variable Comment="Zeigt auf die Quelldaten" Name="GetDataAt.pData"/>
			udSize 	: UDINT;			//! <Variable Comment=" number of bytes to extract" Name="GetDataAt.udSize"/>
			udAt 	: UDINT;			//! <Variable Comment="offset within the string-buffer" Name="GetDataAt.udAt"/>
		END_VAR;
				//! <Function Comment="Initialisiert den String mit konstanten Daten, z.B. aus einer Tabelle&#13;&#10;Der String wird als ASCII-String interpretiert.&#13;&#10;Initializes a string object with constant data (i.e. from a table)&#13;&#10;The string is assumed to be an ASCII-string&#13;&#10;" Name="InitFromTable"/>
	FUNCTION VIRTUAL GLOBAL InitFromTable
		VAR_INPUT
			udLen 	: UDINT;			//! <Variable Comment="Länge der Initialisierungsdaten in Bytes" Name="InitFromTable.udLen"/>
			pData 	: ^USINT;			//! <Variable Comment="pointer to source" Name="InitFromTable.pData"/>
		END_VAR;
				//! <Function Comment=" The function doesn&apos;t provide default functionality&#13;&#10; Please overwrite it for derived classes.&#13;&#10; Die Funktion stellt keine Standard-Implementierung dar. Sie muß für abgeleitete&#13;&#10; Klassen überschrieben werden.&#13;&#10;[&gt;udOff] Offset innerhalb des internen Datenpuffers, auf den die Daten kopiert werden sollen&#13;&#10;" Name="WriteDataOff"/>
	FUNCTION VIRTUAL GLOBAL WriteDataOff
		VAR_INPUT
			udLen 	: UDINT;			//! <Variable Comment=" Length of initialization data block" Name="WriteDataOff.udLen"/>
			udOff 	: UDINT;			//! <Variable Comment=" form this offset the data is read" Name="WriteDataOff.udOff"/>
			pData 	: ^USINT;
		END_VAR;
				//! <Function Comment=" The function returns a CRC of the string&apos;s data buffer&#13;&#10; This CRC is recalculated everytime the contents are changed&#13;&#10;Die Funktion liefert eine Prüfsumme über den Stringinhalt. Diese CRC&#13;&#10;wird bei jeder String-Änderung angepaßt.&#13;&#10;[&lt;udCRC]32-bit-CRC&#13;&#10;" Name="GetCRC"/>
	FUNCTION VIRTUAL GLOBAL GetCRC
		VAR_OUTPUT
			udCRC 	: UDINT;			//! <Variable Comment="32-bit-CRC" Name="GetCRC.udCRC"/>
		END_VAR;
				//! <Function Comment="This function servers as a default implementation for data access.&#13;&#10;It copies the maximum amount of bytes into the provided result buffer.&#13;&#10;Die Funktion stellt eine Standardimplementierung für die Datenabholung dar.&#13;&#10;Sie kopiert vom angegebenen Offset die maximale Anzahl an Bytes in den&#13;&#10;bereitgestellten Ergebnispuffer.&#13;&#10;[&gt;udMax] maximale Anzahl an Bytes die kopiert werden&#13;&#10;" Name="ReadDataOff"/>
	FUNCTION VIRTUAL GLOBAL ReadDataOff
		VAR_INPUT
			udOff 	: UDINT;			//! <Variable Comment=" Offset von dem aus dem internen Datenpuffer Daten gelesen werden" Name="ReadDataOff.udOff"/>
			pData 	: ^USINT;
			udMax 	: UDINT;			//! <Variable Comment=" maximum number of bytes to copy" Name="ReadDataOff.udMax"/>
		END_VAR
		VAR_OUTPUT
			udLen 	: UDINT;			//! <Variable Comment=" Länge des internen Datenpuffers" Name="ReadDataOff.udLen"/>
		END_VAR;
				//! <Function Comment="Kopiert den Inhalt des übergebenen Strings in das eigene String-Objekt.&#13;&#10;Die Inhalte beider Strings sind danach ident.&#13;&#10; Copies the raw data from the passed string to the current one.&#13;&#10; The contents of the data blocks of both strings are the same&#13;&#10; afterwards.&#13;&#10;" Name="StrCpy"/>
	FUNCTION VIRTUAL GLOBAL StrCpy
		VAR_INPUT
			pSrc 	: ^StringInternal;			//! <Variable Comment="pointer to string to append" Name="StrCpy.pSrc"/>
		END_VAR;
				//! <Function Comment="The passed string is appended to the current string&#13;&#10;If the strings styles differ (ASCII/UNICODE), then the passed string&#13;&#10;will be converted to the current string&apos;s style prior to appending it.&#13;&#10;Der übergebene String wird an den eigenen String hinten angehängt.&#13;&#10;Wenn die Strings unterschiedliche Typen haben (ASCII/UNICODE), dann&#13;&#10;wird der übergebene String zuerst angepaßt, und dann erst angehängt.&#13;&#10;" Name="StrCat"/>
	FUNCTION VIRTUAL GLOBAL StrCat
		VAR_INPUT
			pSrc 	: ^StringInternal;			//! <Variable Comment="Zeiger auf den anzuhängenden String" Name="StrCat.pSrc"/>
		END_VAR;
				//! <Function Comment="Der String wird auf einen Leerstring gesetzt.&#13;&#10; the string contents of the string are set to an empty string&#13;&#10;" Name="Clear"/>
	FUNCTION VIRTUAL GLOBAL Clear;
				//! <Function Comment="The two strings are compared case sensitive. The function returns 0&#13;&#10;if the strings are exactly the same, otherwise it returns &lt;&gt;0.&#13;&#10;If one of the two strings is in UNICODE, then the other is converted&#13;&#10;to UNICODE, too, before the comparison.&#13;&#10;None of the strings is changed!&#13;&#10;Die beiden Strings werden mit Unterscheidung von Groß/Kleinschreibung&#13;&#10;verglichen. Die Funktion liefert 0, wenn die beiden Strings exakt&#13;&#10;gleich sind, sonst &lt;&gt;0.&#13;&#10;Wenn einer der beiden Strings UNICODE-Zeichen enthält, dann wird auch&#13;&#10;der andere String auf UNICODE transformiert, bevor der Vergleich&#13;&#10;durchgeführt wird.&#13;&#10;Keiner der beiden Strings wird dadurch verändert!&#13;&#10;" Name="StrCmp"/>
	FUNCTION VIRTUAL GLOBAL StrCmp
		VAR_INPUT
			pStr 	: ^StringInternal;			//! <Variable Comment="Zeiger auf den Zielstring" Name="StrCmp.pStr"/>
		END_VAR
		VAR_OUTPUT
			udNotEqual 	: UDINT;			//! <Variable Comment="0 .. equal, &lt;&gt; 0 .. not equal" Name="StrCmp.udNotEqual"/>
		END_VAR;
				//! <Function Comment="The two strings are compared case insensitive. The function will return 0 if the&#13;&#10;strings are the same, otherwise it returns &lt;&gt;0.&#13;&#10;Comparing &quot;Abc&quot; with &quot;Abc&quot; or &quot;Abc&quot; with &quot;ABC&quot; will result in 0,&#13;&#10;comparing &quot;PLC&quot; with &quot;SPS&quot; will result in a value different from 0&#13;&#10;Die beiden Strings werden ohne Berücksichtigung der Groß/Kleinschreibung&#13;&#10;miteinander verglichen. Die Funktion liefert für gleiche Strings 0,&#13;&#10;ansonsten einen Wert &lt;&gt; 0.&#13;&#10;Der Vergleich von &quot;Abc&quot; mit &quot;Abc&quot; oder von &quot;Abc&quot; mit &quot;ABC&quot; liefert 0,&#13;&#10;der Vergleich &quot;PLC&quot; mit &quot;SPS&quot; liefert einen Wert ungleich 0.&#13;&#10;" Name="StriCmp"/>
	FUNCTION VIRTUAL GLOBAL StriCmp
		VAR_INPUT
			pStr 	: ^StringInternal;			//! <Variable Comment="pointer to the destination string" Name="StriCmp.pStr"/>
		END_VAR
		VAR_OUTPUT
			udNotEqual 	: UDINT;			//! <Variable Comment="0 .. gleich, &lt;&gt; 0 .. ungleich" Name="StriCmp.udNotEqual"/>
		END_VAR;
				//! <Function Comment="Der linke Teil des Strings wird in den Zielstring kopiert. Wenn&#13;&#10;die angegebene Zeichenzahl größer als die Stringlänge ist, wird&#13;&#10;nur der ursprüngliche String kopiert.&#13;&#10;The left part of the string is copied to the specified string object. If udCnt exceeds&#13;&#10;the string length, only the string contents are copied&#13;&#10;" Name="Left"/>
	FUNCTION VIRTUAL GLOBAL Left
		VAR_INPUT
			udCnt 	: UDINT;			//! <Variable Comment="Anzahl der zu kopierenden Zeichen" Name="Left.udCnt"/>
			pStr 	: ^StringInternal;
		END_VAR;
				//! <Function Comment="Die Funktion kopiert die letzten udCnt Zeichen des Strings in den&#13;&#10;Zielstring. Wenn die angegebene Zeichenzahl größer als die String-&#13;&#10;länge ist, wird nur der ursprüngliche String kopiert.&#13;&#10;The function copies the specified number of characters to the destination string. If&#13;&#10;the specified number exceeds the string length, only the string contents are copied.&#13;&#10;" Name="Right"/>
	FUNCTION VIRTUAL GLOBAL Right
		VAR_INPUT
			udCnt 	: UDINT;			//! <Variable Comment="number of characters to extract" Name="Right.udCnt"/>
			pStr 	: ^StringInternal;
		END_VAR;
				//! <Function Comment="All lower case letters are converted to upper case letters. The&#13;&#10;string object itself will be changed.&#13;&#10;Alle Kleinbuchstaben werden in Großbuchstaben konvertiert. Durch diese&#13;&#10;Funktion wird der String selbst geändert.&#13;&#10;" Name="StrUpr"/>
	FUNCTION VIRTUAL GLOBAL StrUpr;
				//! <Function Comment="All characters of a UNICODE-string are converted to ASCII-characters.&#13;&#10;If a character can not be transformed to ASCII-code, it will be replaced&#13;&#10;by a SPACE-character (0x20).&#13;&#10;Die Zeichen eines UNICODE-STrings werden in ASCII-Code gewandelt. Wenn&#13;&#10;sich ein Zeichen nicht auf ASCII-Code abbilden läßt, dann wird es durch&#13;&#10;ein Leerzeichen (0x20) ersetzt.&#13;&#10;" Name="ToAscii"/>
	FUNCTION VIRTUAL GLOBAL ToAscii;
				//! <Function Comment="All characters of an ASCII-string are converted to UNICODE.&#13;&#10;Alle Zeichen eines ASCII-Strings werden auf UNICODE übersetzt.&#13;&#10;" Name="ToUniCode"/>
	FUNCTION VIRTUAL GLOBAL ToUniCode;
				//! <Function Comment="All upper case letters are converted to lower case letters. The&#13;&#10;string object itself will be changed.&#13;&#10;Alle Großbuchstaben werden in Kleinbuchstaben konvertiert. Durch diese&#13;&#10;Funktion wird der String selbst geändert.&#13;&#10;" Name="StrLwr"/>
	FUNCTION VIRTUAL GLOBAL StrLwr;
				//! <Function Comment="The function searches for the given character in its string-buffer.&#13;&#10;It returns -1 if the character was not found, otherwise the index&#13;&#10;of the 1st matching character.&#13;&#10;Die Funktion sucht im String-Puffer nach dem angegebenen Zeichen.&#13;&#10;Sie liefert -1, wenn das Zeichen nicht gefunden wurde, ansonsten&#13;&#10;den Index des ersten übereinstimmenden Zeichens.&#13;&#10;[&gt;uiChar] Zeichen, nach dem gesucht werden soll&#13;&#10;" Name="StrChr"/>
	FUNCTION VIRTUAL GLOBAL StrChr
		VAR_INPUT
			uiChar 	: UINT;			//! <Variable Comment=" character to search for" Name="StrChr.uiChar"/>
		END_VAR
		VAR_OUTPUT
			udPosition 	: UDINT;
		END_VAR;
				//! <Function Comment="Returns the number of characters in the string.&#13;&#10;For ASCII - strings this is equal to the number of bytes, for&#13;&#10;Unicode - strings it&apos;s just the half of it.&#13;&#10;The string length does not include the terminating zero.&#13;&#10;Liefert die Anzahl der Zeichen in einem String.&#13;&#10;Bei ASCII - Strings entspricht das genau der Anzahl an Daten - Bytes,&#13;&#10;bei Unicode - Strings ist es die Hälfte davon.&#13;&#10;Die Abschluß - Null ist nicht inkludiert.&#13;&#10;" Name="StrLen"/>
	FUNCTION VIRTUAL GLOBAL StrLen
		VAR_OUTPUT
			udLen 	: UDINT;			//! <Variable Comment="Anzahl der Zeichen" Name="StrLen.udLen"/>
		END_VAR;
				//! <Function Comment="Set a character to the String at a given position&#13;&#10;Setzt ein Zeichen an einer bestimmten Position des Strings&#13;&#10;" Name="SetDataAt"/>
	FUNCTION VIRTUAL GLOBAL SetDataAt
		VAR_INPUT
			pData 	: ^UINT;
			udAt 	: UDINT;			//! <Variable Comment="Position im String an der das Zeichen gesetzt wird" Name="SetDataAt.udAt"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;returns 1 for ASCII strings and 2 for Unicode strings&#13;&#10;" Name="GetCharSize"/>
	FUNCTION VIRTUAL GLOBAL GetCharSize
		VAR_OUTPUT
			usSize 	: USINT;			//! <Variable Comment="size of one character in the string (ASCII vs. Unicode)" Name="GetCharSize.usSize"/>
		END_VAR;
				//! <Function Comment=" The function doesn&apos;t provide default functionality&#13;&#10; Please overwrite it for derived classes.&#13;&#10; Die Funktion stellt keine Standard-Implementierung dar. Sie muß für abgeleitete&#13;&#10; Klassen überschrieben werden.&#13;&#10;[&gt;udOff] Offset innerhalb des internen Datenpuffers, auf den die Daten kopiert werden sollen&#13;&#10;" Name="WriteDataOffUni"/>
	FUNCTION VIRTUAL GLOBAL WriteDataOffUni
		VAR_INPUT
			udlen 	: UDINT;			//! <Variable Comment="length of initialization data in bytes" Name="WriteDataOffUni.udlen"/>
			udOff 	: UDINT;			//! <Variable Comment=" offset where data should be copied to" Name="WriteDataOffUni.udOff"/>
			pData 	: ^UINT;			//! <Variable Comment="contains the stringdata" Name="WriteDataOffUni.pData"/>
			usSize 	: USINT;			//! <Variable Comment="hand over the size of one character!&#13;&#10;1 = ASCII, 2 = Unicode" Name="WriteDataOffUni.usSize"/>
		END_VAR;
	
	FUNCTION GetDataPtrIn
		VAR_OUTPUT
			pData 	: ^USINT;
		END_VAR;
	
	FUNCTION BufferInToStrBuff;
	
	FUNCTION StrBuffToBufferOut;
	
	FUNCTION CheckInputStr
		VAR_INPUT
			pStr 	: ^StringInternal;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::GetState
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::Kill
		VAR_OUTPUT
			ret_code (EAX) 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd MMServerBase


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MMServerString::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MMSERVERSTRING
0$UINT, 0$UINT, (SIZEOF(::MMServerString))$UINT, 
0$UINT, 1$UINT, 0$UINT, 
TO_UDINT(2277096699), "MMServerString", //Class
TO_UDINT(2898603620), "StringInternal", 1$UINT, 82$UINT, //Baseclass
//Servers:
//Clients:
(::MMServerString.MMServer.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3912347455), "MMServer", TO_UDINT(2479275025), "MMServerBase", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_MMServerString 48

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MMServerString] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MMServerString::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= StringInternal::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= VirtualBaseInit::Data.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, VirtualBaseInit::Data.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_MMServerString;
	vmt.CmdTable.GetState		:= #Data::GetState();
	vmt.CmdTable.Kill		:= #Data::Kill();
	vmt.CmdTable.NewInstr		:= #Data::NewInst();
	vmt.CmdTable.Read		:= #Data::Read();
	vmt.CmdTable.Write		:= #Data::Write();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetLength();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetDataAt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #InitFromTable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #WriteDataOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetCRC();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ReadDataOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #StrCpy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #StrCat();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #Clear();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #StrCmp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #StriCmp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #Left();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Right();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #StrUpr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #ToAscii();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #ToUniCode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #StrLwr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #StrChr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #StrLen();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #SetDataAt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #GetCharSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #WriteDataOffUni();

#pragma warning (default : 74)
	VirtualBaseInit::Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VirtualBaseInit::Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= MMServerString();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include <RTOS_MemIntern.h>

//==============================================================
#define GetBufferInLen()        MMServer.GetBufferLen(MM_BufferIn)
#define GetCharSizeBufferIn()   MMServer.GetCharSize(MM_BufferIn)
#define IsAsciiBufferIn()	      GetCharSizeBufferIn() = sizeof(char)
#define IsUniCodeBufferIn()	    GetCharSizeBufferIn() = sizeof(UINT)
//==============================================================

VAR_PRIVATE

  m_bCallBase : BOOL;

END_VAR

FUNCTION VIRTUAL GLOBAL MMServerString::Data::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	output := MMServer.Read();

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::Data::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

  Data := input;
	StrCpy(input$^StringInternal);
  result := Data;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::Data::Kill
	VAR_OUTPUT
		ret_code (EAX) 	: IprStates;
	END_VAR

	ret_code := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::Clear
VAR
	c : ARRAY[0..1] OF CHAR;
	usSize 	: USINT;
END_VAR
  
  IF (m_bCallBase = TRUE) THEN
    StringInternal::Clear();
  ELSE
    usSize := GetCharSize();
    IF (usSize = 1) THEN
      c[0] := 0$USINT;
    ELSE
      c[0] := 0$UINT;
    END_IF;
    MMServer.WriteDataOff(usSize, 0, #c[0]);
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::GetCharSize
	VAR_OUTPUT
		usSize 	: USINT;
	END_VAR
  
  IF (m_bCallBase = TRUE) THEN
    usSize := StringInternal::GetCharSize();
  ELSE
    usSize := MMServer.GetCharSize(MM_BufferIn);
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::GetCRC
	VAR_OUTPUT
		udCRC 	: UDINT;
	END_VAR
  
  IF (m_bCallBase = TRUE) THEN
    udCRC := StringInternal::GetCRC();
  ELSE
    udCRC := MMServer.GetCRC();
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::GetDataAt
	VAR_INPUT
		pData 	: ^USINT;
		udSize 	: UDINT;
		udAt 	: UDINT;
	END_VAR
  
  IF (m_bCallBase = TRUE) THEN
    StringInternal::GetDataAt(pData, udSize, udAt);
  ELSE
    MMServer.GetDataAt(pData, udSize, udAt);
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::GetLength
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR
  
  IF (m_bCallBase = TRUE) THEN
    udLen := StringInternal::GetLength();
  ELSE
    udLen := MMServer.GetBufferLen(MM_BufferIn);
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::Init

  m_bCallBase := FALSE;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::InitFromTable
	VAR_INPUT
		udLen 	: UDINT;
		pData 	: ^USINT;
	END_VAR
  
  m_bCallBase := TRUE;
   // Basis funktion aufrufen
  StringInternal::InitFromTable(udLen,pData);
  // Wert in bufferOut schreiben
  StrBuffToBufferOut();
  m_bCallBase := FALSE;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::Left
	VAR_INPUT
		udCnt 	: UDINT;
		pStr 	: ^StringInternal;
	END_VAR
   
  IF (m_bCallBase = TRUE) THEN
     StringInternal::Left(udCnt, pStr);
  ELSE
  
    CheckInputStr(pStr);
    m_bCallBase := TRUE;
    // BufferIn wert in DummyBuffer vom StringInternal schreiben
    BufferInToStrBuff();
    StringInternal::Left(udCnt, pStr);
    // Wert in bufferOut schreiben
    StrBuffToBufferOut();
    m_bCallBase := FALSE;

  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::ReadDataOff
	VAR_INPUT
		udOff 	: UDINT;
		pData 	: ^USINT;
		udMax 	: UDINT;
	END_VAR
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR
  
  IF (m_bCallBase = TRUE) THEN
    udLen := StringInternal::ReadDataOff(udOff, pData, udMax);
  ELSE
    udLen := MMServer.ReadDataOff(udOff, pData, udMax);
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::Right
	VAR_INPUT
		udCnt 	: UDINT;
		pStr 	: ^StringInternal;
	END_VAR

  IF (m_bCallBase = TRUE) THEN
     StringInternal::Right(udCnt, pStr);
  ELSE
  
    CheckInputStr(pStr);
    m_bCallBase := TRUE;
    // BufferIn wert in DummyBuffer vom StringInternal schreiben
    BufferInToStrBuff();
    // Basis funktion aufrufen
    StringInternal::Right(udCnt, pStr);
    // Wert in bufferOut schreiben
    StrBuffToBufferOut();
    m_bCallBase := FALSE;
    
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::SetDataAt
	VAR_INPUT
		pData 	: ^UINT;
		udAt 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  IF (m_bCallBase = TRUE) THEN
     ret_code := StringInternal::SetDataAt(pData, udAt);
  ELSE

    m_bCallBase := TRUE;
    // BufferIn wert in DummyBuffer vom StringInternal schreiben
    BufferInToStrBuff();
    // Basis funktion aufrufen
    ret_code := StringInternal::SetDataAt(pData, udAt);
    // Wert in bufferOut schreiben
    StrBuffToBufferOut();
    m_bCallBase := FALSE;
    
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::StrCat
	VAR_INPUT
		pSrc 	: ^StringInternal;
	END_VAR

  IF (m_bCallBase = TRUE) THEN
     StringInternal::StrCat(pSrc);
  ELSE
  
    CheckInputStr(pSrc);
    m_bCallBase := TRUE;
    // BufferIn wert in DummyBuffer vom StringInternal schreiben
    BufferInToStrBuff();
    StringInternal::StrCat(pSrc);
    // Wert in bufferOut schreiben
    StrBuffToBufferOut();
    m_bCallBase := FALSE;
  
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::StrChr
	VAR_INPUT
		uiChar 	: UINT;
	END_VAR
	VAR_OUTPUT
		udPosition 	: UDINT;
	END_VAR

  IF (m_bCallBase = TRUE) THEN
     udPosition := StringInternal::StrChr(uiChar);
  ELSE
    
    m_bCallBase := TRUE;
    // BufferIn wert in DummyBuffer vom StringInternal schreiben
    BufferInToStrBuff();
    // Basis funktion aufrufen
    udPosition := StringInternal::StrChr(uiChar);
    m_bCallBase := FALSE;

  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::StrCmp
	VAR_INPUT
		pStr 	: ^StringInternal;
	END_VAR
	VAR_OUTPUT
		udNotEqual 	: UDINT;
	END_VAR
  
  IF (m_bCallBase = TRUE) THEN
     udNotEqual := StringInternal::StrCmp(pStr);
  ELSE
  
    CheckInputStr(pStr);
    m_bCallBase := TRUE;
    // BufferIn wert in DummyBuffer vom StringInternal schreiben
    BufferInToStrBuff();
    // Basis funktion aufrufen
    udNotEqual := StringInternal::StrCmp(pStr);
    m_bCallBase := FALSE;
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::StrCpy
	VAR_INPUT
		pSrc 	: ^StringInternal;
	END_VAR
  
  IF (m_bCallBase = TRUE) THEN
     StringInternal::StrCpy(pSrc);
  ELSE
  
    CheckInputStr(pSrc);
    m_bCallBase := TRUE;
    // Basis funktion aufrufen
    StringInternal::StrCpy(pSrc);
    // Wert in bufferOut schreiben
    StrBuffToBufferOut();
    m_bCallBase := FALSE;
    
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::StriCmp
	VAR_INPUT
		pStr 	: ^StringInternal;
	END_VAR
	VAR_OUTPUT
		udNotEqual 	: UDINT;
	END_VAR
 
  IF (m_bCallBase = TRUE) THEN
    udNotEqual := StringInternal::StriCmp(pStr);
  ELSE
  
    CheckInputStr(pStr);
    m_bCallBase := TRUE;
    // BufferIn wert in DummyBuffer vom StringInternal schreiben
    BufferInToStrBuff();
    // Basis funktion aufrufen
    udNotEqual := StringInternal::StriCmp(pStr);
    m_bCallBase := FALSE;
    
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::StrLen
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR
  
  IF (m_bCallBase = TRUE) THEN
     udLen := StringInternal::StrLen();
  ELSE
     udLen := MMServer.GetBufferLen(MM_BufferIn);
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::StrUpr

  IF (m_bCallBase = TRUE) THEN
     StringInternal::StrUpr();
  ELSE
  
    m_bCallBase := TRUE;
    // BufferIn wert in DummyBuffer vom StringInternal schreiben
    BufferInToStrBuff();
    // Basis funktion aufrufen
    StringInternal::StrUpr();
    // Wert in bufferOut schreiben
    StrBuffToBufferOut();
    m_bCallBase := FALSE;
    
  END_IF;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::StrLwr

  IF (m_bCallBase = TRUE) THEN
     StringInternal::StrLwr();
  ELSE
  
    m_bCallBase := TRUE;
    // BufferIn wert in DummyBuffer vom StringInternal schreiben
    BufferInToStrBuff();
    // Basis funktion aufrufen
    StringInternal::StrLwr();
    // Wert in bufferOut schreiben
    StrBuffToBufferOut();
    m_bCallBase := FALSE;
    
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::ToAscii

  IF (m_bCallBase = TRUE) THEN
     StringInternal::ToAscii();
  ELSE
  
    m_bCallBase := TRUE;
    // BufferIn wert in DummyBuffer vom StringInternal schreiben
    BufferInToStrBuff();
    // Basis funktion aufrufen
    StringInternal::ToAscii();
    // Wert in bufferOut schreiben
    StrBuffToBufferOut();
    m_bCallBase := FALSE;
    
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::ToUniCode

  IF (m_bCallBase = TRUE) THEN
     StringInternal::ToUniCode();
  ELSE
  
    m_bCallBase := TRUE;
    // BufferIn wert in DummyBuffer vom StringInternal schreiben
    BufferInToStrBuff();
    // Basis funktion aufrufen
    StringInternal::ToUniCode();
    // Wert in bufferOut schreiben
    StrBuffToBufferOut();
    m_bCallBase := FALSE;
    
  END_IF;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::WriteDataOff
	VAR_INPUT
		udLen 	: UDINT;
		udOff 	: UDINT;
		pData 	: ^USINT;
	END_VAR
  
  IF (m_bCallBase = TRUE) THEN
     StringInternal::WriteDataOff(udLen, udOff, pData);
  ELSE
     MMServer.WriteDataOff(udLen, udOff, pData);
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::WriteDataOffUni
	VAR_INPUT
		udlen 	: UDINT;
		udOff 	: UDINT;
		pData 	: ^UINT;
		usSize 	: USINT;
	END_VAR
  VAR
    ptmpmem : ^UINT;
    tmplen  : UDINT;
  END_VAR
    
    ptmpmem := NIL;
    tmplen := udOff + udlen;

    IF pData & udLen >= 2 THEN
      IF usSize = 1 then
        WriteDataOff(udLen, udOff, pData$^USINT);
      ELSIF usSize = 2 THEN

        IF (udOff = 0) THEN
          //  allcoate with extern function
          ptmpmem$^void := _alloc(udlen + 2);

          //  check if we get a valid pointer
          IF (ptmpmem <> NIL) THEN 
            //  write the identifier in the first 2 bytes
            ptmpmem^ := 16#0200;

            //  copy the string to the new memoryblock with the identifier
            _memcpy(ptmpmem + 2, pData, udlen);
            //  the len is increased by 2 bytes
            tmplen += 2;

            //  we call the WriteDataOff method with the new len and the new memory block
            WriteDataOff(udLen:= tmplen, udOff:= udOff, pData:= ptmpmem$^USINT);
            //  the string is written so we can free the memory block again
            _free(ptmpmem);
          END_IF;
        ELSE
          //  increase the offset, because the identifier is in front of the string
          udOff += 2;
          //  call write method with new offset
          WriteDataOff(udlen, udOff, pData$^USINT);

        END_IF;
      END_IF;
    END_IF;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::Data::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR

  ret_code := StringInternal::NewInst(pPara, pResult);
  
  IF (pPara^.uiCmd > 4) THEN
    MMServer.NewInst(pPara, pResult);
  END_IF;
    
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerString::Data::GetState
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR

	ret_code := MMServer.GetState(pPara, pResult);
  
END_FUNCTION

FUNCTION MMServerString::GetDataPtrIn
	VAR_OUTPUT
		pData 	: ^USINT;
	END_VAR

  pData := MMServer.GetDataPtrIn();

END_FUNCTION

FUNCTION MMServerString::MMServerString
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

FUNCTION MMServerString::BufferInToStrBuff

  StringInternal::WriteDataOff(GetBufferInLen(), 0, GetDataPtrIn());

END_FUNCTION

FUNCTION MMServerString::StrBuffToBufferOut

  MMServer.WriteDataOff(StringInternal::GetLength(), 0, DataBuffer.GetDataPtr());
   
END_FUNCTION


FUNCTION MMServerString::CheckInputStr
	VAR_INPUT
		pStr 	: ^StringInternal;
	END_VAR
  VAR
	  pObj	      : ^Obj;
    pObjThis	  : ^Obj;
    udLen       : UDINT;
    pData       : ^USINT;
    usCharSize  : USINT;
  END_VAR
  
  
  // prüfen ob Input auch vom Type MMServerString ist
  pObj	:= LSL_GetHdr(pStr);
  pObjThis	:= LSL_GetHdr(this);
  
  IF (pObj^.pClsHdr = pObjThis^.pClsHdr) THEN
  
    // Datenptr vom MMServerBufferIn holen
    pData := pStr^$MMServerString.GetDataPtrIn();
    udLen := pStr^.GetLength();
    usCharSize := pStr^.GetCharSize();
    
    // Daten in den DummyBuffer schreiben
    m_bCallBase := TRUE;
    pStr^.WriteDataOffUni(udLen, 0, pData$^UINT, usCharSize);
    m_bCallBase := FALSE;
  END_IF;

END_FUNCTION
