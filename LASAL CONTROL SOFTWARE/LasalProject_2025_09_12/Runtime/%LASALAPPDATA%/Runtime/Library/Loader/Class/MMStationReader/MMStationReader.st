//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "MMStationReader"
	Revision           = "0.0"
	GUID               = "{A7B9989F-92DA-4DD1-BDA4-2E3D269B9174}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(810,120)"
	Comment            = "Parst die Stations.txt Datei&#13;&#10;Verwaltung der MMStation Objekte">
	<Channels>
		<Server Name="ClassSvr" GUID="{1F75000B-AEF4-4E5A-A0D3-7023897CE8DC}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FimLuc"/>
		<Dokumentation Revision="0.0" Date="2015-10-07" Author="FimLuc" Company="Sigmatek" Description="erstellt"/>
	</RevDoku>
</Class>
*)
MMStationReader : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		m_uiCnt 	: UINT;			//! <Variable Comment="Anzahl der gelesenen Stationen" Name="m_uiCnt"/>
		m_pMultiMasterStations 	: ^MMStation;			//! <Variable Comment="Start Speicheraddresse für alle eingelesenen Stationen" Name="m_pMultiMasterStations"/>
  //Functions:
				//! <Function Comment="Sucht das Objekt der Station mit der ID" Name="GetStation"/>
	FUNCTION GLOBAL GetStation
		VAR_INPUT
			pszName 	: ^CHAR;			//! <Variable Comment="StationsId&#13;&#10;" Name="GetStation.pszName"/>
		END_VAR
		VAR_OUTPUT
			pMultiMasterStation 	: ^MMStation;
		END_VAR;
				//! <Function Comment="Liest die Datei RemoteStations.txt ein und &#13;&#10;erstellt aus jedem gültigen Eintrag ein RemoteStation-Objekt&#13;&#10;" Name="CreateStationsFromFile"/>
	FUNCTION GLOBAL CreateStationsFromFile;
				//! <Function Comment="Liest und Parst eine Zeile aus dem RemoteStations.txt" Name="ReadLine"/>
	FUNCTION ReadLine
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Dateihandle" Name="ReadLine.handle"/>
			pBuf 	: ^void;			//! <Variable Comment="Zeiger auf die RemoteStation Struktur zum befüllen" Name="ReadLine.pBuf"/>
		END_VAR
		VAR_OUTPUT
			nRet 	: DINT;			//! <Variable Comment="&gt;0 wenn eine komplette Zeile gelesen wurde&#13;&#10;0  wenn das Fileende erreicht ist. &#13;&#10;&lt;0 bei einem Fehler " Name="ReadLine.nRet"/>
		END_VAR;
				//! <Function Comment="Liefert die Anzahl der eingelesenen Stationen" Name="GetStationsCount"/>
	FUNCTION GLOBAL GetStationsCount
		VAR_OUTPUT
			udCount 	: UDINT;			//! <Variable Comment="Anzahl der eingelesenen Stationen" Name="GetStationsCount.udCount"/>
		END_VAR;
				//! <Function Comment="Gibt die Station an der mitgelieferten Stelle zurück" Name="GetStationAt"/>
	FUNCTION GLOBAL GetStationAt
		VAR_INPUT
			udPos 	: UDINT;			//! <Variable Comment="Wert zw. 0 und GetStationsCount" Name="GetStationAt.udPos"/>
		END_VAR
		VAR_OUTPUT
			pStation 	: ^MMStation;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MMStationReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MMSTATIONREADER
0$UINT, 0$UINT, (SIZEOF(::MMStationReader))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(551343053), "MMStationReader", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::MMStationReader.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
END_FUNCTION


#define USER_CNT_MMStationReader 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MMStationReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MMStationReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

#pragma usingLtd MMStation

//{{LSL_IMPLEMENTATION
#include <LSL_ST_OSFILE.H>
#include <LSL_ST_LSLFILE.H>
#include <RTOS_Mem.h>

#ifndef DUMMY_LOADER
#pragma using ConnectReader
#endif

#define MEM_BUFFER_SIZE           256        // size für char buffer
#define BUFFER_BLOCKSIZE_STATIONS 1 

TYPE
  // Listenelement für eine verkettete Liste von Connection Name + Verbindungsstring
  _nameAndConnStr: STRUCT
    name : ^CHAR;
    connStr : ^CHAR;
    next : ^_nameAndConnStr;
  END_STRUCT;
END_TYPE

VAR_PRIVATE
  // Liste mit Connection Name + Verbindungsstring Elementen, welche aus dem 
  // station2.txt File ausgelesen wurden und von der Applikation verändert 
  // werden können. Diese Werte überschreiben die im stations.txt konfigurierten 
  // Werte.
  stationsOverwrite : ^_nameAndConnStr;
END_VAR

(*
  Sucht das Objekt der Station mit der ID
*)
FUNCTION GLOBAL MMStationReader::GetStation
	VAR_INPUT
		pszName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		pMultiMasterStation 	: ^MMStation;
	END_VAR
  VAR
  	iCnt           : UDINT;
  	iEnd           : UDINT;
    lexem1         : CLocLex;
    lexem2         : CLocLex;  
  END_VAR

  pMultiMasterStation := NIL;
  
  IF ((pszName = NIL) | (m_uiCnt = 0)) THEN
    RETURN;
  END_IF;
        
  lexem1.InitText(pszName);
  iEnd := m_uiCnt-1;
  FOR iCnt := 0 TO iEnd BY 1 DO
    pMultiMasterStation := (m_pMultiMasterStations + (iCnt * sizeof(MMStation)));
    
    lexem2.InitText(#pMultiMasterStation^.m_szName[0]);
    
     IF (lexem1.udCRC = lexem2.udCRC) THEN
        IF (_strcmp(pszName, #pMultiMasterStation^.m_szName[0]) = 0) THEN
          RETURN;
        END_IF;
    END_IF;
  END_FOR;
  
  // nicht gefunden, NIL zurückliefern
  pMultiMasterStation := NIL;

END_FUNCTION

(*
  Erstellt ein neues _nameAndConnStr Element am Heap und initialisiert 
  name und connStr.
*)
FUNCTION NewNameAndConnStr
VAR_INPUT
  name : ^CHAR;
  connStr : ^CHAR;
END_VAR
VAR_OUTPUT
  el : ^_nameAndConnStr;
END_VAR

  // Da sich der Name nicht mehr ändert, kann man das _nameAndConnStr und den name String zusammenfassen.
  el$pVoid := _alloc_resize_LDR(sizeof(_nameAndConnStr) + _strlen(name) + 1);
  IF el = NIL THEN
    RETURN;
  END_IF;

  el^.name$pVoid := el$pVoid + sizeof(_nameAndConnStr);
  el^.connStr$pVoid := _alloc_resize_LDR(_strlen(connStr) + 1);
  IF el^.connStr = NIL THEN
    _Free(el);
    el := NIL;
    RETURN;
  END_IF;
  
  _strcpy(el^.name, name);
  _strcpy(el^.connStr, connStr);
  el^.next := NIL;

END_FUNCTION

(*
  Fügt eine name/connStr Paar in die Liste stationsOverwrite ein oder ändert 
  den connStr Wert, wenn name schon in der Liste vorhanden ist.
*)
FUNCTION AddStationsOverwrite
VAR_INPUT
  name : ^CHAR;
  connStr : ^CHAR;
END_VAR
VAR_OUTPUT
  status    : DINT; // 0=ok
END_VAR
VAR
  el : ^_nameAndConnStr;
  newConnStr : ^CHAR;
END_VAR

  status := 0;
  el := stationsOverwrite;
  WHILE el <> NIL DO
    IF _strcmp(el^.name, name) = 0 THEN
      // Element schon vorhanden
      newConnStr$pVoid := _alloc_resize_LDR(_strlen(connStr) + 1);
      IF newConnStr = NIL THEN
        status := -1;
        RETURN;
      END_IF;

      // connStr ändern
      _Free(el^.connStr);
      el^.connStr := newConnStr;
      _strcpy(el^.connStr, connStr);
      RETURN;
    END_IF;
    el := el^.next;
  END_WHILE;

  // neues Listenelement erstellen
  el := NewNameAndConnStr(name, connStr);
  IF el = NIL THEN
    status := -1;
    RETURN;
  END_IF;

  // Element in die Liste einfügen
  el^.next := stationsOverwrite;
  stationsOverwrite := el;

END_FUNCTION

(*
  Löscht ein name/connStr Paar oder alles aus der Liste stationsOverwrite. 
  Wenn name NIL ist, dann wird alles gelöscht, sonst nur ein einzelner Eintrag.
*)
FUNCTION DelStationsOverwrite
VAR_INPUT
  name : ^CHAR;
END_VAR
VAR
  prev : ^_nameAndConnStr;
  el : ^_nameAndConnStr;
  next : ^_nameAndConnStr;
END_VAR

  IF name = NIL THEN // alles löschen ?
    WHILE stationsOverwrite <> NIL DO
      next := stationsOverwrite^.next;
      _Free(stationsOverwrite^.connStr);
      _Free(stationsOverwrite);
      stationsOverwrite := next;
    END_WHILE;
  ELSE
    prev := NIL;
    el := stationsOverwrite;
    WHILE el <> NIL DO
      next := el^.next;
      IF _strcmp(el^.name, name) = 0 THEN
        // Listenelement gefunden
        IF prev = NIL THEN
          stationsOverwrite := el^.next;
        ELSE
          prev^.next := el^.next;
        END_IF;
        _Free(el^.connStr);
        _Free(el);
        RETURN;
      END_IF;
      prev := el;
      el := next;
    END_WHILE;
  END_IF;

END_FUNCTION

(*
  Sucht ein name/connStr Paar in der Liste stationsOverwrite anhand von name
*)
FUNCTION FindStationsOverwrite
VAR_INPUT
  name : ^CHAR;
END_VAR
VAR_OUTPUT
  connStr : ^CHAR;
END_VAR
VAR
  el : ^_nameAndConnStr;
END_VAR

  connStr := NIL;
  el := stationsOverwrite;
  WHILE el <> NIL DO
    IF _strcmp(el^.name, name) = 0 THEN
      connStr := el^.connStr;
      RETURN;
    END_IF;
    el := el^.next;
  END_WHILE;

END_FUNCTION

(*
  Fügt einen Text an einen Zeilenbuffer an.
  Beim Zeilenbuffer ist angegeben, wie lang der Text aktuell ist und wie 
  groß der Buffer allokiert ist. Bei Bedarf wird der Zeilenbuffer vergrößert.
  
  Wenn der Zeilenbuffer NIL ist, dann wird nichts gemacht. Das hat den Sinn, 
  dass die äussere Schleife im Fehlerfall nicht abbrechen muss und keinen 
  Returncode prüfen muss, weil dann in Fehlerfall einfach lineBuf auf NIL 
  gesetzt wird.
*)
FUNCTION AppendLine
VAR_INPUT
  lineBuf : ^CHAR;
  lineLen : ^UDINT;
  lineAllocated : ^UDINT;
  text : ^CHAR;
END_VAR
VAR_OUTPUT
  newLineBuf : ^CHAR;
END_VAR
VAR
	len : UDINT;
  nb : ^CHAR;
END_VAR

  newLineBuf := lineBuf;
  IF lineBuf = NIL THEN
    // nichts zu tun
    RETURN;
  END_IF;

  len := _strlen(text);
  IF lineLen^ + len  > lineAllocated^ THEN
    nb := newLineBuf;
    newLineBuf$pVoid := _realloc_LDR(newLineBuf$pVoid, lineLen^ + len + 10);
    IF newLineBuf = NIL THEN
      _Free(nb);
      RETURN;
    END_IF;
    lineAllocated^ := lineLen^ + len + 10;
  END_IF;

  // es wird memcpy statt strcpy verwendet, da der Zeilentext nicht 0-terminiert ist
  _memcpy(newLineBuf + lineLen^, text, len);
  lineLen^ += len;

END_FUNCTION

(*
  Schreibt den Inhalt der Liste stationsOverwrite ins File c:\lsldata\station2.txt
*)
FUNCTION SaveStationsOverwrite
VAR_OUTPUT
  status : DINT;
END_VAR
VAR
	handle : DINT;
  el : ^_nameAndConnStr;
  rc : DINT;
  lineBuf : ^CHAR;
  lineLen : UDINT;
  lineAllocated : UDINT;
END_VAR

  status := 0;

  lineAllocated := 0;
  lineLen := 0;
  lineBuf$pVoid := _alloc_resize_LDR(10);
  IF lineBuf <> NIL THEN
    lineAllocated := 10;
  END_IF;


  el := stationsOverwrite;
  WHILE el <> NIL DO
    // Format: "<name>","<verbindungs-string>"
    lineBuf := AppendLine(lineBuf, #lineLen, #lineAllocated, "$22");  // $22 ist ein doppeltes Hochkomma (")
    lineBuf := AppendLine(lineBuf, #lineLen, #lineAllocated, el^.name);
    lineBuf := AppendLine(lineBuf, #lineLen, #lineAllocated, "$22,$22"); // ","
    lineBuf := AppendLine(lineBuf, #lineLen, #lineAllocated, el^.connStr);
    lineBuf := AppendLine(lineBuf, #lineLen, #lineAllocated, "$22$N"); // "

    el := el^.next;
  END_WHILE;

  handle:= OS_FILE_OPEN(MM_STATIONCFG_OVERWRITE_FILE, 2, ATT_CREATE_ALWAYS);
  IF handle < 0 THEN
    status := -1;
  ELSE
    IF lineBuf <> NIL THEN
      rc := OS_FILE_WRITEV1(handle, lineBuf, lineLen);
      IF rc <> lineLen$DINT THEN
        status := -1;
      END_IF;
    END_IF;
    OS_FILE_CLOSE(handle);
  END_IF;

  IF lineBuf <> NIL THEN
    _Free(lineBuf);
  END_IF;

END_FUNCTION

(*
  Liste das File c:\lsldata\station2.txt ein und schreibt die eingelesenen Werte 
  in die Liste stationsOverwrite.
*)
FUNCTION LoadStationsOverwrite
VAR
	handle : DINT;
  fileSize : DINT;
  buf : ^CHAR;
  b : ^CHAR;
  bufEnd : ^CHAR;
  rc : DINT;
  state : UDINT;
  pszName : ^CHAR;
  pszConn : ^CHAR;
END_VAR

  handle := OS_FILE_OPEN(MM_STATIONCFG_OVERWRITE_FILE, 0, 0);	
  IF (handle < 0) THEN
    RETURN; // File existiert nicht
  END_IF;
  
  // es wird die Filegrößte ermittelt und dann auf einmal alles in einen am 
  // Heap allokierten Speicherblock eingelesen.
  fileSize := OS_FILE_SEEKV1(handle, 0, FILE_END);
  if fileSize > 0 THEN
    rc := OS_FILE_SEEKV1(handle, 0, FILE_BEGIN);
    IF fileSize > 0 & rc = 0 THEN
      buf$pVoid := _alloc_resize_LDR(fileSize$UDINT);
      IF buf <> NIL THEN
        rc$UDINT := OS_FILE_READ(handle, buf, fileSize$UDINT);
        IF rc = fileSize THEN
          // Buffer konnte allokiertwerden und alles wurde in den Buffer eingelesen
          bufEnd := buf + fileSize;
          state := 0;
          // Format: "<name>","<verbindungs-string>"
          // Der Einfachheit halber wird beim Parsen nur auf das "-Zeichen geschaut, 
          // d.h. es werden 2 Strings eingelesen, die sich jeweils in doppelten 
          // Hochkommas befinden. Das was sich ausserhalb der "-Zeichen befindet wird 
          // nicht beachtet.
          b := buf;
          WHILE b < bufEnd DO
            IF state = 0 THEN
              IF b^ = '"' THEN
                pszName := b + 1;
                state := 1;
              END_IF;
            ELSIF state = 1 THEN
              IF b^ = '"' THEN
                b^ := 0;
                state := 2;
              END_IF;
            ELSIF state = 2 THEN
              IF b^ = '"' THEN
                pszConn := b + 1;
                state := 3;
              END_IF;
            ELSIF state = 3 THEN
              IF b^ = '"' THEN
                b^ := 0;
                state := 0;
                // name und connStr wurden eingelesen                
                AddStationsOverwrite(pszName, pszConn);
              END_IF;
            END_IF;

            b += 1;
          END_WHILE;

        END_IF;
        _Free(buf);
      END_IF;
    END_IF;
  END_IF;
  
  OS_FILE_CLOSE(handle);

END_FUNCTION

(*
  Funktion verhält sich wie LDR_MM_StatNrConnConfigStr mit dem Unterschied, 
  dass mit pszName statt udStationId die Station angegeben wird
*)
FUNCTION LDR_MM_StatNameConnConfigStr
VAR_INPUT
  pszName : ^CHAR;// Zeiger auf den Namen der Station
  pszConn : ^CHAR;// Zeiger auf den neuen Connection 0term. String. Z.b. "TCPIP:10.10.116.7"
END_VAR
VAR_OUTPUT
  status    : DINT; // 0=ok, <>0 Fehler
END_VAR

  IF pszName = NIL THEN
    // alle Einträge löschen
    DelStationsOverwrite(NIL);
    status := 0;
  ELSIF pszConn <> NIL THEN
    // Eintrag hinzufügen
    status := AddStationsOverwrite(pszName, pszConn);
  ELSE
    // einzelnen Eintrag löschen
    DelStationsOverwrite(pszName);
    status := 0;
  END_IF;
  
  IF status = 0 THEN
    // geänderte Liste ins File schreiben
    status := SaveStationsOverwrite();
  END_IF;

END_FUNCTION

(*
  Fügt Name + Connectionstring einer MM Station zu der Liste der Stationen 
  hinzu, welche beim Hochlauf die in der stations.txt konfigurierten Werte 
  überschreiben. Die Liste wird ins File c:\lsldata\station2.txt eingetragen. 
  Der Aufruf dieser Funktion hat erst beim nächsten Hochlauf eine Auswirkung, 
  da das File c:\lsldata\station2.txt nur beim Hochlauf ausgewertet wird.
  
  Es können auch einzelne oder alle Einträge gelöscht werden.
  
  Parameter:
    udStationId .. Id der Station oder 16#FFFFffff, wenn alle Einträge aus dem File 
      gelöscht werden sollen
    pszConn .. Verbindungsstring der Station (Format z.B. "TCPIP:10.10.116.7") oder 
      NIL, wenn der Eintrag entfernt werden soll.
      
  Return:
    status .. 0 wenn ok, sonst Fehler
      Wenn beim Löschen eines Eintrags der Eintrag von Anfang an nicht vorhanden 
      ist, dann wird das nicht als Fehler gewertet.
*)
FUNCTION GLOBAL LDR_MM_StatNrConnConfigStr
VAR_INPUT
  udStationId : UDINT;// Id der Station
  pszConn : ^CHAR;// Zeiger auf den neuen Connection 0term. String. Z.b. "TCPIP:10.10.116.7"
END_VAR
VAR_OUTPUT
  status    : DINT; // 0=ok, <>0 Fehler
END_VAR
VAR
  pszName : ^CHAR;// Zeiger auf den Namen der Station
	pStation : ^MMStation;
END_VAR

  IF udStationId = 16#FFFFffff THEN
    // alles löschen
    pszName := NIL;
  ELSE
    pStation := MM_GetStation(udStationId)$^MMStation;
    IF pStation = NIL THEN
      status := -1;
      RETURN;
    END_IF;
    pszName := #pStation^.m_szName[0];
  END_IF;

  status := LDR_MM_StatNameConnConfigStr(pszName, pszConn);

END_FUNCTION

(*
  Liest die Datei MultiMasterStations.txt ein und 
  erstellt aus jedem gültigen Eintrag ein MMStation-Objekt
*)
FUNCTION GLOBAL MMStationReader::CreateStationsFromFile
 VAR
    handle      : DINT;  // file handle
    len         : DINT;  // rückgabewert für ReadLine
    pStation    : ^MMStation; // Pointer auf die aktuelle MMStation
    udAlloc     : UDINT;     
    udDummy     : UDINT;     
    curChar     : CHAR; // aktuell eingelesener char
  	rc          : DINT; // rückgabewert vom OS_FILE_READ
    lines       : DINT;
    cBuffVersion: ARRAY[0..20] OF CHAR;
    connStrOverwrite : ^CHAR;
  END_VAR 

  m_uiCnt := 0;
  udAlloc := 0;
  udDummy := sizeof(MMStation);
  cBuffVersion[0] := 0;
  stationsOverwrite := NIL;
  
  // prüfen ob OS Version überhaupt ein Filesystem unterstützt
  IF ((_rtosversion <= 16#537) | (!!(LSLFILE_IsInstalled))) THEN
    // Es gibt kein Filesystem, oder das OS ist so alt, dass es nicht weiß ob eines vorhanden ist
    RETURN;
  END_IF;
  
  LoadStationsOverwrite();

  // Datei öffnen
  handle := OS_FILE_OPEN(MM_STATIONCFG_FILE, 0, 0);	
  IF (handle < 0) THEN
    RETURN; // File existiert nicht
  END_IF;

  lines := 0;
  len := 0;
  // search Start, skip first 3 lines
  WHILE (lines <> 3) DO
  
    // 1 Zeichen einlesen
    rc := OS_FILE_READ(handle, #curChar, 1)$DINT;
    
    IF (rc < 0) THEN
      TRACE_ERR("Error reading Stations.txt");
      EXIT;
    END_IF;
    
    IF ((curChar <> 16#0d) & (curChar <> 16#0a)) THEN
    
      cBuffVersion[len] := curChar;
      len += 1;
      
    ELSE // Prüfen ob Zeilenende
    
      cBuffVersion[len] := 0; 
      
      IF (len > 0) THEN
        IF ((lines = 0) & (_strcmp(MM_STATIONCFG_FILE_DEFVERSION, #cBuffVersion[0]) = 0)) THEN
          lines := 1;
        ELSIF ((lines = 2) & (_strcmp(MM_STATIONCFG_FILE_DEFCONNECTIONS, #cBuffVersion[0]) = 0)) THEN
          lines := 3;
        ELSIF(lines = 1) THEN
          IF (_strcmp(MM_STATIONCFG_FILE_VERSION, #cBuffVersion[0]) <> 0) THEN
            TRACE1_ERR("Stations.txt version {0} not supported. (Supported version: {1})", #cBuffVersion[0], MM_STATIONCFG_FILE_VERSION);
          END_IF;
          lines := 2;
        END_IF;
      END_IF;

      len := 0;

    END_IF;
    
  END_WHILE;

  // initialisieren der Werte
  m_pMultiMasterStations := NIL;
  pStation := NIL;
  
  IF (lines = 3) THEN
    // Alle Zeilen einlesen und bearbeiten
    WHILE (TRUE) DO 
      
      IF (m_pMultiMasterStations = NIL) THEN
        m_pMultiMasterStations := _alloc_resize_LDR(BUFFER_BLOCKSIZE_STATIONS * sizeof(MMStation))$^MMStation;
        pStation := m_pMultiMasterStations;
        udAlloc += 1;
      ELSIF (m_uiCnt = (udAlloc*BUFFER_BLOCKSIZE_STATIONS)) THEN
        udAlloc += 1;
        m_pMultiMasterStations := _realloc_LDR(m_pMultiMasterStations, udAlloc * BUFFER_BLOCKSIZE_STATIONS * sizeof(MMStation))$^MMStation;
        pStation := (m_pMultiMasterStations + (m_uiCnt * sizeof(MMStation)));
      END_IF;

      IF (m_pMultiMasterStations = NIL) THEN
        EXIT;
      END_IF;

       _memset(pStation, 0, sizeof(MMStation));
       pStation^.Initialize();

      // eine zeile lesen und gleich befüllen
      len := ReadLine(handle, pStation);
      IF (len < 0) THEN
        TRACE_ERR("Error reading Stations.txt"); // file konnte nicht gelesen werden
        EXIT;
      END_IF;
      
      // in station2.txt File nachschauen, ob bei den Verbindungseinstellungen der Station 
      // etwas überschrieben werden muss
      connStrOverwrite := FindStationsOverwrite(#pStation^.m_szName[0]);
      IF connStrOverwrite <> NIL THEN
        pStation^.SetConnStr(connStrOverwrite);
      END_IF;
      
      IF (len = 0) THEN
        m_pMultiMasterStations := _realloc_LDR(m_pMultiMasterStations, m_uiCnt * BUFFER_BLOCKSIZE_STATIONS * sizeof(MMStation))$^MMStation;
        EXIT; // Ende des Files
      END_IF;

      pStation^.m_bID := m_uiCnt; // ID = pos in m_pMultiMasterStations
      pStation += sizeof(MMStation);
          
      // zähler für die eingelesenen Zeilen erhöhen
      m_uiCnt += 1; 

    END_WHILE;
  END_IF;

  // fertig mit datei, wieder schliessen
  OS_FILE_CLOSE(handle);

END_FUNCTION

(* Liest eine Zeile vom File in den angegebenen Buffer (=Zeiger auf ein MMStation Objekt) 
   und speichert die relevanten Werte gleich in die übergebene MMStation Struktur.
   Leer- und Kommentarzeilen werden übersprungen.
   
   Die eingelesenen Werte werden im MMStation Objekt auf folgende Membervariablen geschrieben:
   - m_szName .. Stationsname
   - m_acConnStr, m_bConnStrLen .. Connectionstring
   - m_waitForReqTimeout_ms .. Timeout beim Warten bis Werte von required Clients vorhanden sind (optional)
   
   Der Aufbau der Zeile ist folgendermaßen:
   "<Stationsname>","<Connectionstring>"[,<Timeout-ms>]
   z.B.:
   "Lsl Prj 1","TCPIP:10.10.116.7",0
   
 
   Zurückgegeben wird 
   >0 wenn eine komplette Zeile gelesen wurde
   0  wenn das Fileende erreicht ist. 
   <0 bei einem Fehler 
*)
FUNCTION MMStationReader::ReadLine
	VAR_INPUT
		handle 	: DINT;
		pBuf 	: ^void;
	END_VAR
	VAR_OUTPUT
		nRet 	: DINT;
	END_VAR
  VAR
  	rc              : DINT; // rückgabewert vom OS_FILE_READ
    c               : CHAR; // aktuell eingelesener char
		pCurBuf         : ^CHAR; // buffer in dem die eingelesenen zeichen zwischengespeichert werden
    quit_           : BOOL; // Abbruch Bedindung für die Leseschleife
    commaCnt        : DINT; // Zähler bei welchen Abschnitt der Zeile man gerade ist
    pStation        : ^MMStation; // Zeiger auf die MMStation Struktur zum Befüllen
    bSkipChar       : BOOL; // TRUE: Zeichen nicht in den Buffer speichern
    bReset          : BOOL; // Buffer kann resettet werden
    bComment        : BOOL; // es wird gerade Kommentar eingelesen
    bReadToLineEnd  : BOOL; // bis zum Zeilenende einlesen
    bInHochkomma    : BOOL; // TRUE, wenn man sich innerhalb von Hochkommas befindet
  END_VAR
  
  nRet := 0; // wird als Positionszeiger für den Buffer verwendet

  // prüfung ob filehandle gültig ist
  if handle < 0 then
    nRet := handle;
    RETURN;
  end_if;

  // alle Variablen mal initialisieren
  quit_ := FALSE;
  commaCnt := 0;
  pStation := pBuf$^MMStation;
  bSkipChar := FALSE;
  bReset := FALSE;
  bComment := FALSE;
  bReadToLineEnd := FALSE;
  bInHochkomma := FALSE;

  // buffer für die eingelesenen Zeichen allokieren
  pCurBuf$^void := _alloc_resize(MEM_BUFFER_SIZE);
  // buffer initialisieren
  pCurBuf^ := 0;

  // Lese Schleife
  WHILE (quit_ = false) DO 
WhileContinue:  
    
    IF (bReset = TRUE) THEN
      bReset := FALSE;
      pCurBuf^ := 0;
      nRet := 0;
    END_IF;
    
    // 1 Zeichen einlesen
    rc := OS_FILE_READ(handle, #c, 1)$DINT;
    IF (rc < 0) THEN
      nRet := rc;        // Fehler beim Lesen
      quit_ := TRUE;
    ELSIF (rc = 0) THEN
      IF (bReadToLineEnd = FALSE) THEN
        nRet := 0;  
      ELSE
        nRet := 1;  
      END_IF;
      quit_ := TRUE;
    ELSE
      IF (c = '"') THEN
        bInHochkomma := !!bInHochkomma;
      END_IF;
    
      IF ((c = 16#0d) | (c = 16#0a)) THEN // Prüfen ob Zeilenende
        IF (commaCnt = 2) THEN // stations Timeout
          (pCurBuf + nRet)^ := 0;
          IF ConnectReader::ScanInt(pCurBuf, #pStation^.m_waitForReqTimeout_ms, 0) = 0 THEN
            TRACE_ERR("Error scanning Stations.txt: waitForReqTimeout");
            pStation^.m_waitForReqTimeout_ms := 0;
          END_IF;
        END_IF;
        IF (bReadToLineEnd = TRUE) THEN
          nRet := 1;  
          quit_ := TRUE; // fertig mit dem Zeileneintrag
        ELSE       
          bReset := TRUE;
          bSkipChar := FALSE;
          bComment := FALSE;
          commaCnt := 0;
          GOTO WhileContinue; // nächstes Zeichen einlesen
        END_IF;
      ELSIF (c = '#') THEN // beginn kommentar
        bReset := TRUE;
        bSkipChar := TRUE;
        bComment := TRUE;
        commaCnt := 0;
      ELSIF (c = ';') THEN // Eintrag ende
        bReset := TRUE;
        bSkipChar := FALSE;
        bComment := FALSE;
        commaCnt := 0;
        GOTO WhileContinue; // nächstes Zeichen einlesen
      ELSIF ((bComment = false) & (c = ',')) THEN
        (pCurBuf + nRet)^ := 0;
        IF (commaCnt = 0) THEN // stations Name
          _strcpy(#pStation^.m_szName[0], pCurBuf);
        ELSIF (commaCnt = 2) THEN // stations Timeout
          IF ConnectReader::ScanInt(pCurBuf, #pStation^.m_waitForReqTimeout_ms, 0) = 0 THEN
            TRACE_ERR("Error scanning Stations.txt: waitForReqTimeout");
            pStation^.m_waitForReqTimeout_ms := 0;
          END_IF;
        END_IF;
        commaCnt += 1;
        bReset := TRUE;
        bSkipChar := TRUE;       
      ELSIF ((c = '"') & (commaCnt = 1) & (bReadToLineEnd = false)) THEN // Connectionstring
        IF bSkipChar = TRUE THEN // Start des Connectionstring
          bSkipChar := FALSE;
          GOTO WhileContinue; // nächstes Zeichen einlesen
        ELSE // ende des Connectionstring
          (pCurBuf + nRet)^ := 0;
          pStation^.SetConnStr(pCurBuf);// gelesenen String in Struktur kopieren
          bReadToLineEnd := TRUE; // bis zeilenende fertig lesen, rest kann derzeit noch ignoriert werden
          bSkipChar := TRUE;  // zeichen bis dahin ignorieren
        END_IF;
      ELSIF (commaCnt >= 2) THEN
        bSkipChar := FALSE;
      END_IF;
    END_IF;
    
    IF (quit_ = false) THEN
      IF ((bSkipChar = FALSE) & (c <> '"')) THEN // alle hochkommas ignorieren
        IF (commaCnt = 0) THEN
          IF bInHochkomma THEN // leerzeichen nicht ignorieren, dafür Zeichen nur übernehmen wenn innerhalb von Hochkommas
            (pCurBuf + nRet)^ := c; // zeichen im den Buffer schreiben
            nRet += 1; // Anzahl der zeichen im Buffer
          END_IF;
        ELSE
          IF (c <> ' ') THEN // alle leerzeichen ignorieren
            (pCurBuf + nRet)^ := c; // zeichen im den Buffer schreiben
            nRet += 1; // Anzahl der zeichen im Buffer
          END_IF;
        END_IF;
      END_IF;
    ELSE
       _free(pCurBuf); // buffer freigeben
    END_IF;
     
  END_WHILE;

END_FUNCTION

(*
  Anzahl der eingelesenen Station aus der Datei
*)
FUNCTION GLOBAL MMStationReader::GetStationsCount
	VAR_OUTPUT
		udCount 	: UDINT;
	END_VAR

  // anzahl der gelesenen Stationen
  udCount := m_uiCnt;

END_FUNCTION

(* 
  Station an der Position ermittlen
*)
FUNCTION GLOBAL MMStationReader::GetStationAt
	VAR_INPUT
		udPos 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pStation 	: ^MMStation;
	END_VAR
  
  pStation := NIL;

(*
  PraErw 29.4.2020:
  Kainzbauer verwendet diese Funktion (z.B. über einen LDR_MM_StatNrConnGetStr Aufruf) 
  für das IP-Addon so, dass er die Stationen beginnend bei 0 durchenumeriert. 
  Sobald hier NIL zurüdkgegeben wird, nimmt er an dass es keine weiteren Stationen mehr 
  gibt und die Schleife wird abgebrochen.
  Das funktioniert in der derzeitigen Implementierung und muss auch so bleiben. 
  D.h. es darf in Zukunft nicht so geändert werden, dass z.B. an der Position 0 und 2 was ist, 
  die Position 1 aber leer ist !
*)
  IF ((udPos >= 0) & (udPos < m_uiCnt)) THEN
    pStation := (m_pMultiMasterStations + (udPos * sizeof(MMStation)))$^MMStation;
  END_IF;
 
END_FUNCTION