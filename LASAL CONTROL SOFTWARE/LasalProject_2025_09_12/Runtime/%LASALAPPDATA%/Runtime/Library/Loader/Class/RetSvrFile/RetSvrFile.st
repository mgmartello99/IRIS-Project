//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "RetSvrFile"
	Revision           = "0.1"
	GUID               = "{78164F1A-0BB7-4A9A-AF0D-13493B368C4E}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Data" GUID="{A4547313-38A9-49AF-B12D-ED123E489460}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="0.1" Date="10.5.2010" Author="Pranz" Company="Sigmatek" Description="changed file functions to asynchronous functions"/>
	</RevDoku>
</Class>
*)
RetSvrFile : CLASS
	TYPE
	  ASYNC_FILE_STATE : STRUCT
	    XRamAddr : XRamCell;  //! <Type Comment="Daten des asynchronen FileWrite Befehls (müssen stabil sein, solange der Request nicht fertig ist)" Name="ASYNC_FILE_STATE.XRamAddr"/>
	    state : UDINT;  //! <Type Comment="Status der asynchronen Fileoperation:&#13;&#10;0 .. keine asynchrone Fileoperation anstehend&#13;&#10;1 .. pDataObj wurde geändert und muss daher geschrieben werden, Request wurde aber noch nicht abgesetzt&#13;&#10;2 .. asynchroner Request wurde abgesetzt&#13;&#10;3 .. Kombination aus 1 und 2. &#13;&#10;4 .. temporärer State" Name="ASYNC_FILE_STATE.state"/>
	    pDataObj : ^UDINT;  //! <Type Comment="Zeiger auf das dData des RetSvrFile Objekts" Name="ASYNC_FILE_STATE.pDataObj"/>
	    hRequest : DINT;  //! <Type Comment="Request-Handle der asynchronen Fileoperation" Name="ASYNC_FILE_STATE.hRequest"/>
	    pNext : ^ASYNC_FILE_STATE;  //! <Type Comment="Zeiger auf die nächste ASYNC_FILE_STATE Datenstruktur in der verketteten Liste" Name="ASYNC_FILE_STATE.pNext"/>
	    wrCnt : DINT;  //! <Type Comment="zählt die vollendeten File-Schreibvorgänge" Name="ASYNC_FILE_STATE.wrCnt"/>
	  END_STRUCT;
	END_TYPE
  //Servers:
	Data 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		pRamAddr 	: ^RamCell;
		Version 	: DINT;
		AsyncState 	: ASYNC_FILE_STATE;
  //Functions:
	
	FUNCTION RetSvrFile
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL WriteNew
		VAR_INPUT
			input 	: DINT;
		END_VAR
		VAR_OUTPUT
			ret0 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB RetSvrFile::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_RETSVRFILE
0$UINT, 1$UINT, (SIZEOF(::RetSvrFile))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(175441316), "RetSvrFile", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::RetSvrFile.Data.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2607161047), "Data", 
//Clients:
END_FUNCTION


#define USER_CNT_RetSvrFile 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_RetSvrFile] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION RetSvrFile::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_RetSvrFile, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #Write();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #WriteNew();

#pragma warning (default : 74)
	Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= RetSvrFile();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#ifdef LDR_RETSVR
FUNCTION GLOBAL Find_File
VAR_INPUT
	CRC32		:  UDINT;
	ppRamAdr	: ^void;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR;

FUNCTION GLOBAL RetSvrFileWrite_A
VAR_INPUT
  pAsyncState : ^RetSvrFile::ASYNC_FILE_STATE;  // Zeiger auf eine bereits initialisierte ASYNC_FILE_STATE Struktur
END_VAR
VAR_OUTPUT
  ret0 : dint;
END_VAR;

FUNCTION VIRTUAL GLOBAL RetSvrFile::Data::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

 	result := WriteNew( input );

END_FUNCTION

//[#ENGLISH]
//Schreibfunktion der Klasse RetSvrFile bei Version grösser 2
FUNCTION VIRTUAL GLOBAL RetSvrFile::WriteNew
	VAR_INPUT
		input 	: DINT;
	END_VAR
	VAR_OUTPUT
		ret0 	: DINT;
	END_VAR

  if( input <> Data.dData )then
    Data.dData := input;
    RetSvrFileWrite_A( #AsyncState );
  end_if;
  ret0 := input;

END_FUNCTION //VIRTUAL GLOBAL RetSvrFile::WriteNew

FUNCTION RetSvrFile::RetSvrFile
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
    pObj    : ^OBJ;
    CRC     : UDINT;
   	result  : UDINT;
  END_VAR

  pObj := LSL_GetHdr( this );
  CRC :=	pObj^.pObjDsc^.SymName.udCRC;
  
  // AsyncState Datenstruktur initialisieren
  AsyncState.state := 0;
  AsyncState.pDataObj := #Data.dData$UDINT;
  AsyncState.pNext := NIL;
  
	// suchen oder anlegen eines neuen Eintrages
  result := Find_File( CRC, #AsyncState.XRamAddr$^void);
  ret_code := C_OK;
  pRamAddr := ( #AsyncState.XRamAddr )$^RamCell;
  
  if( result = 0 )then
    // hat schon existiert
    Data.dData := AsyncState.XRamAddr.udData$dint;
  elsif( result = 1 )then
    // wurde neu angelegt
    AsyncState.XRamAddr.udChk$dint := Data.dData;
    AsyncState.XRamAddr.udData$dint := Data.dData;
    WriteNew( Data );
  else
    // existiert nicht und konnte auch nicht angelegt werden
    pRAMaddr := NIL;
    ret_code := C_SYSTEM_ERROR;
  end_if;
    
END_FUNCTION
#else
#pragma warning (disable:0076)
#pragma warning (disable:0073)
FUNCTION RetSvrFile::RetSvrFile
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR    
END_FUNCTION

FUNCTION VIRTUAL GLOBAL RetSvrFile::WriteNew
	VAR_INPUT
		input 	: DINT;
	END_VAR
	VAR_OUTPUT
		ret0 	: DINT;
	END_VAR
END_FUNCTION
#pragma warning (disable:0074)
FUNCTION VIRTUAL GLOBAL RetSvrFile::Data::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
END_FUNCTION
#pragma warning (default:0074)
#pragma warning (default:0073)
#pragma warning (default:0076)
#endif //LDR_RETSVR