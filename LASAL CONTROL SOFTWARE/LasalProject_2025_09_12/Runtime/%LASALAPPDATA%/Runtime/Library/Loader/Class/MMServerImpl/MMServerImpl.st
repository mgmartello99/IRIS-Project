//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define MM_REQUIRED       0x01
#define MM_VALID_VALUE    0x02
#define MM_VALID_LASALID  0x04
#define MM_ONLINE         0x08
#define MM_OUTOFMEMORY    0x10
#define MM_SENDFAILED     0x20
#define MM_READFAILED     0x40
#define MM_INITIALIZED    0x80

#define MM_ERROR_STATI    (MM_OUTOFMEMORY OR MM_SENDFAILED OR MM_READFAILED)





//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "MMServerImpl"
	Revision           = "0.0"
	GUID               = "{D49C1868-D722-4FC3-93DB-494AE395D2C1}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(810,120)"
	Comment            = "Enthält alle Informationen zu einem MMServer">
	<Channels>
		<Server Name="Data" WriteProtected="false">
		</Server>
		<Client Name="DataBuffer" Required="false" Internal="false"/>
		<Client Name="DataBufferOut" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Loader\Source\include\MultiMasterdefs.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FimLuc"/>
		<Dokumentation Revision="0.0" Date="2015-10-07" Author="FimLuc" Company="Sigmatek" Description="erstellt"/>
	</RevDoku>
	<Network Name="MMServerImpl">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{075DD4B7-2DB3-41E8-8CFD-9FF5FC2D7DCC}"
				Class      = "MMServerBase"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Data" Destination="_base.Data" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using MMServerBase

MMServerImpl : CLASS
: MMServerBase
  //Servers:
  //Clients:
	DataBuffer 	: CltChCmd_MMBuffer;
	DataBufferOut 	: CltChCmd_MMBuffer;
  //Variables:
		m_bServerNameLen 	: BYTE;			//! <Variable Comment="Länge des Servernamens 0..255" Name="m_bServerNameLen"/>
		m_pStation 	: ^void;
		m_flFlags 	: UDINT;
		m_uiPriority 	: UINT;			//! <Variable Comment="0..0xFF&#13;&#10;0  = Zyklische Übertragung deaktiviert&#13;&#10;0xFF  = einmalig Übertragen" Name="m_uiPriority"/>
		m_flServerType 	: BYTE;
		m_OpsAbs 	: UDINT;
		m_szServerName : ARRAY [0..NLNG] OF CHAR;

		m_udCrc32 	: UDINT;
		m_udLasalId 	: UDINT;
		m_udCrcIn 	: UDINT;
		pNewInstArray 	: ^sNewInst;
		m_udLastWrite 	: UDINT;
		m_bReadReq 	: DINT;
		m_uiReflistOff 	: UINT;
		m_bReadNotify 	: BOOL;
		MuxHdl 	: ^void;
		m_bLockHdlInitialized 	: BOOL;
		DataOut 	: UDINT;
		m_sendReqCnt 	: DINT;
		m_sendReqDone 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION MMServerImpl
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment=" The function doesn&apos;t provide default functionality&#13;&#10; Please overwrite it for derived classes.&#13;&#10; Die Funktion stellt keine Standard-Implementierung dar. Sie muß für abgeleitete&#13;&#10; Klassen überschrieben werden.&#13;&#10;" Name="WriteDataOff"/>
	FUNCTION VIRTUAL GLOBAL WriteDataOff
		VAR_INPUT
			udLen 	: UDINT;			//! <Variable Comment=" Length of initialization data block" Name="WriteDataOff.udLen"/>
			udOff 	: UDINT;			//! <Variable Comment=" form this offset the data is read" Name="WriteDataOff.udOff"/>
			pData 	: ^USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetCharSize
		VAR_INPUT
			nBufferId 	: UDINT;
		END_VAR
		VAR_OUTPUT
			usSize 	: USINT;
		END_VAR;
				//! <Function Comment=" The function should return a value that can be used&#13;&#10; to check if the contents of the data buffer changed.&#13;&#10; Diese Funktion soll eine Prüfsumme über die gehaltenen Daten liefern,&#13;&#10; anhand derer eine Änderung der Daten festgestellt werden kann.&#13;&#10;[&lt;udCRC] Prüfsumme&#13;&#10;" Name="GetCRC"/>
	FUNCTION VIRTUAL GLOBAL GetCRC
		VAR_OUTPUT
			udCRC 	: UDINT;			//! <Variable Comment=" check sum" Name="GetCRC.udCRC"/>
		END_VAR;
				//! <Function Comment=" Diese Funktion muß für abgeleitete Klassen überschrieben werden. Sie soll die&#13;&#10; Daten vom angegebenen Offset im Datenpuffer auf den übergebenen Pointer kopieren.&#13;&#10; Maximal dürfen udLen-Bytes kopiert werden.&#13;&#10; Die Funktion wird durch das READ_DATA-Kommando der NewInst-Methode aufgerufen.&#13;&#10; Overwrite this function for derived classes, copy the data from offset udOff&#13;&#10; to the pointer pData. Copy at maximum udLen - bytes of data.&#13;&#10; The function is called on the READ_DATA-command in the NewInst-&#13;&#10; method.&#13;&#10;[&gt;udSize] data length to be copied&#13;&#10;[&gt;udAt] offset where data should be copied from&#13;&#10;" Name="GetDataAt"/>
	FUNCTION VIRTUAL GLOBAL GetDataAt
		VAR_INPUT
			pData 	: ^USINT;			//! <Variable Comment=" Zeiger auf die Daten" Name="GetDataAt.pData"/>
			udSize 	: UDINT;			//! <Variable Comment=" Länge der Daten die kopiert werden sollen" Name="GetDataAt.udSize"/>
			udAt 	: UDINT;			//! <Variable Comment=" Offset innerhalb des internen Datenpuffers, von dem die Daten kopiert werden sollen" Name="GetDataAt.udAt"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetBufferLen
		VAR_INPUT
			nBufferId 	: UDINT;
		END_VAR
		VAR_OUTPUT
			udLen 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ReadDataOff
		VAR_INPUT
			udOff 	: UDINT;
			pData 	: ^USINT;
			udMax 	: UDINT;
		END_VAR
		VAR_OUTPUT
			udLen 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDataPtrIn
		VAR_OUTPUT
			pData 	: ^USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetBufferAt
		VAR_INPUT
			nBufferId 	: UDINT;
			pData 	: ^USINT;
			udSize 	: UDINT;
			udAt 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetLasalId
		VAR_OUTPUT
			udId 	: UDINT;
		END_VAR;
				//! <Function Comment=" Overwrite this function for derived classes. It should return&#13;&#10; the length of the internal data buffer. If it&apos;s not possible&#13;&#10; to return the length, then overwrite the NewInst method, too,&#13;&#10; and use a different way to return the data.&#13;&#10; Diese Funktion gehört für abgeleitete Klassen überschrieben. Sie soll&#13;&#10; die Länge des internen Datenpuffers zurückliefern. Falls das nicht&#13;&#10; möglich ist, muß auch die NewInst-Methode überschrieben werden (READ_DATA).&#13;&#10;" Name="GetLength"/>
	FUNCTION VIRTUAL GLOBAL GetLength
		VAR_OUTPUT
			udLen 	: UDINT;			//! <Variable Comment=" length of internal data buffer" Name="GetLength.udLen"/>
		END_VAR;
	
	FUNCTION GLOBAL GetName
		VAR_INPUT
			pStr 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			udLen 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetNewInstParams
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
			bCreateNew 	: BOOL;
		END_VAR
		VAR_OUTPUT
			sParams 	: ^sNewInst;
		END_VAR;
	
	FUNCTION GLOBAL GetPriority
		VAR_OUTPUT
			uiTime 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL GetType
		VAR_OUTPUT
			bType 	: BYTE;
		END_VAR;
				//! <Function Comment="Initialisiert den String mit konstanten Daten, z.B. aus einer Tabelle&#13;&#10;Der String wird als ASCII-String interpretiert.&#13;&#10;Initializes a string object with constant data (i.e. from a table)&#13;&#10;The string is assumed to be an ASCII-string&#13;&#10;" Name="InitFromTable"/>
	FUNCTION VIRTUAL GLOBAL InitFromTable
		VAR_INPUT
			udLen 	: UDINT;			//! <Variable Comment="Länge der Initialisierungsdaten in Bytes" Name="InitFromTable.udLen"/>
			pData 	: ^USINT;			//! <Variable Comment="pointer to source" Name="InitFromTable.pData"/>
		END_VAR;
	
	FUNCTION GLOBAL InvokeCallback;
	
	FUNCTION GLOBAL Is4Byte
		VAR_OUTPUT
			bYes 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL IsInitializedFlagSet
		VAR_OUTPUT
			bInitialized 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL IsLasalIdValid
		VAR_OUTPUT
			bValid 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL IsRequired
		VAR_OUTPUT
			bReq 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL ResetInitializedFlag;
	
	FUNCTION GLOBAL ResetLasalId;
	
	FUNCTION GLOBAL SendNewInst
		VAR_INPUT
			pParams 	: ^sNewInst;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL SetInitialized;
	
	FUNCTION GLOBAL SetLasalId
		VAR_INPUT
			udId 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetName
		VAR_INPUT
			pStrName 	: ^CHAR;
			udLen 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetRequired;
	
	FUNCTION GLOBAL SetStation
		VAR_INPUT
			pStation 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL ToAscii
		VAR_INPUT
			nBufferId 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL ToUnicode
		VAR_INPUT
			nBufferId 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL WriteBufferOff
		VAR_INPUT
			nBufferId 	: UDINT;
			udLen 	: UDINT;
			udOff 	: UDINT;
			pData 	: ^USINT;
		END_VAR;
	
	FUNCTION AddTermination
		VAR_INPUT
			nBufferId 	: UDINT;
			udLen 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetData
		VAR_INPUT
			nBufferId 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pData 	: ^USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetBuffer
		VAR_INPUT
			nBufferId 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pBuffer 	: ^void;
		END_VAR;
	
	FUNCTION IsAscii
		VAR_INPUT
			nBufferId 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bRes 	: BOOL;
		END_VAR;
	
	FUNCTION IsUnicode
		VAR_INPUT
			nBufferId 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bRes 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL CalcCrc;
	
	FUNCTION VIRTUAL GLOBAL SetBufferSize
		VAR_INPUT
			nBufferId 	: UDINT;
			udLen 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL IsSpecialPriority
		VAR_OUTPUT
			bYes 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL AddStatus
		VAR_INPUT
			bStati 	: BYTE;
		END_VAR;
	
	FUNCTION GLOBAL RemoveStatus
		VAR_INPUT
			bStati 	: BYTE;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SetBufferSizeForce
		VAR_INPUT
			nBufferId 	: UDINT;
			udLen 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetNewInstState
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION LockOn;
	
	FUNCTION LockOff;
	
	FUNCTION InitLockHandle;
	
	FUNCTION GLOBAL GetBufferAtWithChgBytes
		VAR_INPUT
			nBufferId 	: UDINT;
			pData 	: ^USINT;
			udSize 	: UDINT;
			udAt 	: UDINT;
			pChgBytes 	: ^USINT;
		END_VAR;
				//! <Function Name="Data.GetState" Hidden="true"/>
	FUNCTION VIRTUAL GLOBAL Data::GetState
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::Kill
		VAR_OUTPUT
			ret_code (EAX) 	: iprStates;
		END_VAR;
				//! <Function Name="Data.NewInst" Hidden="true"/>
	FUNCTION VIRTUAL GLOBAL Data::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd MMBuffer


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MMServerImpl::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MMSERVERIMPL
0$UINT, 0$UINT, (SIZEOF(::MMServerImpl))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(522987795), "MMServerImpl", //Class
TO_UDINT(2479275025), "MMServerBase", 0$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
(::MMServerImpl.DataBuffer.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4265790926), "DataBuffer", TO_UDINT(2181466683), "MMBuffer", 0$UINT, 0$UINT, 
(::MMServerImpl.DataBufferOut.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1392123160), "DataBufferOut", TO_UDINT(2181466683), "MMBuffer", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_MMServerImpl 16

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MMServerImpl] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MMServerImpl::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= MMServerBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= MMServerBase::Data.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, MMServerBase::Data.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_MMServerImpl;
	vmt.CmdTable.GetState		:= #Data::GetState();
	vmt.CmdTable.Kill		:= #Data::Kill();
	vmt.CmdTable.NewInstr		:= #Data::NewInst();
	vmt.CmdTable.Read		:= #Data::Read();
	vmt.CmdTable.Write		:= #Data::Write();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #WriteDataOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetCharSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetCRC();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetDataAt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetBufferLen();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ReadDataOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #GetDataPtrIn();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #GetBufferAt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #GetLength();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #InitFromTable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #WriteBufferOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #GetData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #GetBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #CalcCrc();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #SetBufferSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #SetBufferSizeForce();

#pragma warning (default : 74)
	MMServerBase::Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF MMServerBase::Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= MMServerImpl();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include <RTOS_Mem.h>
#include ".\Multimaster.h"
#Include <rtos_privheader.h>

#pragma using MerkerEx

VAR_EXTERNAL
  mt_api   : ^LSL_MT_TYPE; // multitask interface
END_VAR

FUNCTION HexChar
  VAR_INPUT
    hxindex : USINT;
  END_VAR
  VAR_OUTPUT
    retcode : USINT;
  END_VAR
  VAR
  	ph : ^USINT;
  END_VAR
  
  ph      := "ABCDEF0123456789";
  ph      += hxindex and 16#0F;
  retcode := ph^;

END_FUNCTION

#pragma warning(disable:137);

FUNCTION GLOBAL MMServerImpl::SetStation
	VAR_INPUT
		pStation 	: ^void;
	END_VAR
  
  m_pStation := pStation;

END_FUNCTION
FUNCTION GLOBAL MMServerImpl::GetName
	VAR_INPUT
		pStr 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR
  
  _memcpy(pStr, #m_szServerName, m_bServerNameLen + 1);
  udLen := m_bServerNameLen;

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::SetName
	VAR_INPUT
		pStrName 	: ^CHAR;
		udLen 	: UDINT;
	END_VAR

  m_szServerName[0] := 0;
   IF (udLen > NLNG) THEN
      udLen:= (NLNG-2);
   END_IF;

   _memcpy(#m_szServerName, pStrName, udLen);
  m_bServerNameLen := udLen;
  
END_FUNCTION

FUNCTION GLOBAL MMServerImpl::SetLasalId
	VAR_INPUT
		udId 	: UDINT;
	END_VAR

  m_udLasalId := udId;
  
  IF (m_pStation = NIL) THEN
    RETURN;
  END_IF;
  
  IF (m_udLasalId > 0) THEN
    m_flStatus := (m_flStatus OR MM_VALID_LASALID);
  ELSE
    m_flStatus := (m_flStatus AND ((NOT MM_VALID_LASALID)$BYTE));
  END_IF;

  InvokeCallback();

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::GetLasalId
	VAR_OUTPUT
		udId 	: UDINT;
	END_VAR

  udId := m_udLasalId;

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::ResetLasalId

  m_udLasalId := 0;
  m_flStatus := (m_flStatus AND ((NOT MM_VALID_LASALID)$BYTE));
  ResetInitializedFlag();

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::IsLasalIdValid
	VAR_OUTPUT
		bValid 	: BOOL;
	END_VAR
  
  bValid := m_udLasalId > 0;

END_FUNCTION
FUNCTION GLOBAL MMServerImpl::IsInitializedFlagSet
	VAR_OUTPUT
		bInitialized 	: DINT;
	END_VAR

  bInitialized := ((IsLasalIdValid()) & ((m_flStatus AND MM_INITIALIZED) = MM_INITIALIZED));

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::Is4Byte
	VAR_OUTPUT
		bYes 	: BOOL;
	END_VAR
  
  bYes := (m_flServerType = _MM_CHTY_4BYTE);

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::GetPriority
	VAR_OUTPUT
		uiTime 	: UINT;
	END_VAR
  
  uiTime := TO_UINT(m_uiPriority);

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::GetType
	VAR_OUTPUT
		bType 	: BYTE;
	END_VAR
  
  bType := m_flServerType;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::Data::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR
  
  output := 0;
  
  IF (IsLasalIdValid() = FALSE) THEN
    RETURN;
  END_IF;

  IF (Is4Byte() = TRUE) THEN
    DataBuffer.GetDataAt(#output$USINT, sizeof(UDINT), 0);
  ELSIF (m_flServerType = _MM_CHTY_MERKER)  THEN
    output := DataBuffer.m_udLength;
  ELSE
    output := this$UDINT;
  END_IF;
 
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::Data::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  
  result := ACCESS_DENIED;
  
  IF ((m_flFlags AND _MM_PROP_RO) = _MM_PROP_RO) THEN
    RETURN;
  END_IF;
  
  result := input;
  WriteDataOff(sizeof(input),0 , #input$USINT); 

END_FUNCTION

FUNCTION MMServerImpl::MMServerImpl
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;
  
  ResetLasalId();
  
  m_szServerName[0] := 0;
  m_uiPriority := 0;
  m_bServerNameLen := 0;
  m_pStation := NIL;
  m_flServerType:= 0;
  m_flFlags := 0;
  m_flStatus := 0;
  m_sendReqCnt := 0; // wird inkrementiert, wenn eine Sendeanforerung ansteht
  m_sendReqDone := 0; // wird von m_sendReqCnt übernommen, wenn eine Sendeanforderung erfolgreich ausgeführt wurde
  m_OpsAbs := 0;
  m_udCrc32 := 0;
  m_udCrcIn := 0;
  
  pNewInstArray := NIL;
  m_udLastWrite := 0;
  m_uiReflistOff := 0;
  m_bReadNotify := FALSE;
  
  DataOut := 0;
  
  MuxHdl        := NIL;
  m_bLockHdlInitialized := FALSE;
  
END_FUNCTION

FUNCTION GLOBAL MMServerImpl::SetRequired

  m_flStatus := (m_flStatus OR MM_REQUIRED);

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::SetInitialized

  IF ((IsLasalIdValid()) & ((m_flStatus AND MM_INITIALIZED) <> MM_INITIALIZED)) THEN
    AddStatus(MM_INITIALIZED OR MM_VALID_VALUE);
  END_IF;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::GetLength
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR
  
  udLen := GetBufferLen(MM_BufferIn);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::GetDataAt
	VAR_INPUT
		pData 	: ^USINT;
		udSize 	: UDINT;
		udAt 	: UDINT;
	END_VAR
  
  GetBufferAt(MM_BufferIn, pData, udSize, udAt);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::WriteDataOff
	VAR_INPUT
		udLen 	: UDINT;
		udOff 	: UDINT;
		pData 	: ^USINT;
	END_VAR
  
  IF ((m_flFlags AND _MM_PROP_RO) = _MM_PROP_RO) THEN
    RETURN;
  END_IF;
  
  WriteBufferOff(MM_BufferOut, udLen, udOff, pData);
  
  // m_sendReqCnt wird inkrementiert, wenn eine Sendeanforerung ansteht
  // m_sendReqDone wird von m_sendReqCnt übernommen, wenn eine Sendeanforderung erfolgreich ausgeführt wurde
  m_sendReqCnt += 1;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::ReadDataOff
	VAR_INPUT
		udOff 	: UDINT;
		pData 	: ^USINT;
		udMax 	: UDINT;
	END_VAR
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR

	udLen := GetLength();
	IF udLen > udOff THEN
		udLen -= udOff;
	ELSE
		udLen := 0;
	END_IF;

	IF udLen > udMax THEN
		udLen	:= udMax;
	END_IF;

	GetDataAt(pData, udLen, udOff);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::Data::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
    pNewInstParams  : ^sNewInst;
  END_VAR
  
  ret_code := BUSY;
  
  MM_TRACE("Data::NewInst: calling SendNewInst", 0, 0, 0);
  
  pNewInstParams := GetNewInstParams(pPara, pResult, TRUE);
  IF (pNewInstParams <> NIL) THEN
    ret_code := SendNewInst(pNewInstParams); // new Inst immer senden
    pNewInstParams^.IprState := ret_code;
    MM_TRACE("Data::NewInst: SendNewInst, ret=%d", ret_code, 0, 0);
  ELSE
    ret_code := ERROR;
    MM_TRACE("Data::NewInst: ERROR", 0, 0, 0);
  END_IF;
    
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::InitFromTable
	VAR_INPUT
		udLen 	: UDINT;
		pData 	: ^USINT;
	END_VAR

  IF (m_flServerType = _MM_CHTY_STRING) THEN

   IF DataBuffer.m_pData = 0 THEN
    IF pData & udLen >= 2 & pData$^UINT^ = 16#0100 THEN
      pData += 2;
      udLen -= 2;
    END_IF;

    IF DataBuffer.SetSize( udLen ) = C_OK THEN
      DataBuffer.SetData( pData );
      AddTermination(MM_BufferIn, udLen);
      CalcCRC();
    END_IF;
  END_IF;

  ELSIF DataBuffer.m_pData = 0 THEN
    IF DataBuffer.SetSize( udLen ) = C_OK THEN
      DataBuffer.SetData( pData );
      CalcCRC();
    END_IF;
  END_IF;
  
  IF DataBufferOut.m_pData = 0 THEN
    DataBufferOut.SetSize( udLen );
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::WriteBufferOff
	VAR_INPUT
		nBufferId 	: UDINT;
		udLen 	: UDINT;
		udOff 	: UDINT;
		pData 	: ^USINT;
	END_VAR
  VAR
    tmplen  : UDINT;
    tmpretcode  : ConfStates;
    pBuffer : ^MerkerEx;
  END_VAR
  
  pBuffer := GetBuffer(nBufferId)$^MerkerEx;

  IF (m_flServerType = _MM_CHTY_STRING) THEN
    tmpretcode := C_OK;

	  // check if the string representation is given
    IF udOff = 0 THEN
      IF pData & udLen >= 2 & pData$^UINT^ = 16#0200 THEN
        ToUnicode(nBufferId);
      ELSE
        IF pData & udLen >= 2 & pData$^UINT^ = 16#0100 THEN
          pData += 2;
          udLen -= 2;
        END_IF;
        ToAscii(nBufferId);
      END_IF;
    END_IF;

    tmplen := udOff+udLen;

    IF (tmplen > pBuffer^.m_udLength) THEN
      tmpretcode := pBuffer^.SetSize(tmplen);
    END_IF;

    IF (tmpretcode = C_OK) THEN
      pBuffer^.SetDataAt(pData, udLen, udOff);
      AddTermination(nBufferId, tmplen);
    END_IF;

  ELSIF ((udLen + udOff) > pBuffer^.m_udLength) THEN
    IF (pBuffer^.SetSize( udLen + udOff ) = C_OK) THEN
      pBuffer^.SetDataAt(pData, udLen, udOff);
    END_IF;
  ELSIF ((udLen + udOff) <= pBuffer^.m_udLength) THEN
    pBuffer^.SetDataAt(pData, udLen, udOff);
  END_IF;
  
  IF (nBufferId = MM_BufferIn) THEN
    CalcCRC();
  END_IF;

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::ToUnicode
	VAR_INPUT
		nBufferId 	: UDINT;
	END_VAR
  VAR
    pa : ^usint;
    pu : ^uint;
    noc, len : udint;
    pBuffer : ^MerkerEx;
  END_VAR

  if IsAscii(nBufferId) then
    noc := GetBufferLen(nBufferId) + 1;
    len := (noc + 1) * sizeof(uint); // unicodekennung + uni-0-string

    pBuffer := GetBuffer(nBufferId)$^MerkerEx; 
    if(len > pBuffer^.m_udLength) then
      if(pBuffer^.SetSize(len) <> C_OK) then
        return;
      end_if;
    end_if;

    pa  := GetData(nBufferId);

    if(pa <> NIL) then

      pu  := pa$^uint + len;
      pa  += noc;

      while noc do
        pu  -= 2;
        pa  -= 1;
        pu^ := pa^;
        noc -= 1;
      end_while;

      pu  -= 2;
      pu^ := 16#0200;  // unicode kennung
    
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::GetCharSize
	VAR_INPUT
		nBufferId 	: UDINT;
	END_VAR
	VAR_OUTPUT
		usSize 	: USINT;
	END_VAR
  VAR
    pu : ^uint;
    pBuffer : ^MerkerEx;
  END_VAR

  usSize := 1;
  
  pu$^usint := GetData(nBufferId);
  IF(pu <> NIL) THEN
    pBuffer := GetBuffer(nBufferId)$^MerkerEx;
    IF(pBuffer^.m_udLength >= 2) THEN
      IF(pu^ = 16#0200) THEN
        usSize := 2;
      END_IF;
    END_IF;
  END_IF;

END_FUNCTION

FUNCTION MMServerImpl::AddTermination
	VAR_INPUT
		nBufferId 	: UDINT;
		udLen 	: UDINT;
	END_VAR
  VAR
    pa			:^USINT;
    usSize	: USINT;
    tmplen   : UDINT;
    pBuffer : ^MerkerEx;
  END_VAR

	usSize  := GetCharSize(nBufferId);

	IF((usSize = 1) & (udLen >= 1)) | ((usSize = 2) & (udLen >= 4)) THEN // space for at least on character
    pa := GetData(nBufferId);
    if pa <> nil then  
    
      pa += (udLen - usSize);
      if(usSize = 1) then
        if(pa^ = 0) then
          return; // ascii-0-terminated
        end_if;
      else
        if(pa^$uint = 0) then
          return; // uni-0-terminated
        end_if;
      end_if;
      
      tmplen := udLen + usSize;
      
        pBuffer := GetBuffer(nBufferId)$^MerkerEx;
        IF ((udLen+usSize) > pBuffer^.m_udLength) THEN
          IF (pBuffer^.SetSize(tmplen) <> C_OK) then
            RETURN;

          END_IF;
        END_IF;

      pa	:= GetData(nBufferId);
      if pa <> nil then  
        
        pa  += udLen;
        pa^ := 0;
        if(usSize = 2) then
          pa^$uint := 0;
        end_if;
        
      end_if;

    end_if;      
	ELSE
		IF usSize = 1 THEN

      pa := GetData(nBufferId); //  get the pointer
      IF(pa <> NIL) THEN //  got pointer?
        pa^ := 0; //  first char to zero because of changed method GetLength()
      END_IF;
        
		ELSE
        pBuffer := GetBuffer(nBufferId)$^MerkerEx;

        IF (pBuffer^.m_udLength < 4) THEN
          pBuffer^.SetSize(4);
        END_IF;

			pa := GetData(nBufferId);
      if pa <> nil then   
        pa += 2;
        pa$^UINT^ := 0;
      end_if;
		END_IF;
    
	END_IF;

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::ToAscii
	VAR_INPUT
		nBufferId 	: UDINT;
	END_VAR
  VAR
    pa : ^usint;
    pu : ^uint;
    noc : udint;
  END_VAR

	pa := GetData(nBufferId);
  if(pa <> NIL) then
    if IsUnicode(nBufferId) then
      pu  := pa$^uint + 2;
      noc := 0;
      while(pu^) do
        if(pu^ < 256) then
          pa^ := pu$^usint^;
        else
          pa^ := 32; // space
        end_if;
        pu  += 2;
        pa  += 1;
        noc += 1;
      end_while;
      pa^ := 0;
      noc += 1;

    end_if;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::Init
// wird nie aufgerufen
END_FUNCTION

FUNCTION MMServerImpl::InitLockHandle
VAR
  label : array[0..16] of usint;
  tmp : udint;
END_VAR
  
  IF m_bLockHdlInitialized = TRUE THEN
    return;
  END_IF;
  
  m_bLockHdlInitialized := TRUE;

  IF((mt_api <> NIL) & (MuxHdl = 0)) THEN
  
    tmp$^MMServerImpl := this;  
    label[0]$udint := 16#5F534d4d; // MMS_ 
    label[4]       := HexChar(to_usint(tmp shr 28));
    label[5]       := HexChar(to_usint(tmp shr 24));
    label[6]       := HexChar(to_usint(tmp shr 20));
    label[7]       := HexChar(to_usint(tmp shr 16));
    label[8]       := HexChar(to_usint(tmp shr 12));
    label[9]       := HexChar(to_usint(tmp shr  8));
    label[10]      := HexChar(to_usint(tmp shr  4));
    label[11]      := HexChar(to_usint(tmp       ));
    label[12]      := 0;

    MuxHdl := OS_MT_CREATESEMAPHORE(MTSEMATYPE_MUTEX, 
                                    1,    // initvalue
                                    0,    // flags: 0 means create unconitionally
                                    #label[0] 
                                    );
  END_IF;
  
END_FUNCTION

FUNCTION MMServerImpl::LockOn
  
  InitLockHandle();
  if(MuxHdl <> NIL) then
    OS_MT_WAIT(MuxHdl); 
  end_if;
  
END_FUNCTION

FUNCTION MMServerImpl::LockOff
  
  if(MuxHdl <> NIL) then
    OS_MT_SIGNAL(MuxHdl); 
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL MMServerImpl::GetData
	VAR_INPUT
		nBufferId 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pData 	: ^USINT;
	END_VAR
  
  pData := NIL;
  
  IF (nBufferId = MM_BufferIn) THEN
    pData := DataBuffer.m_pData;
  ELSIF (nBufferId = MM_BufferOut) THEN
    pData := DataBufferOut.m_pData;
  END_IF;
  
END_FUNCTION

FUNCTION VIRTUAL MMServerImpl::GetBuffer
	VAR_INPUT
		nBufferId 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pBuffer 	: ^void;
	END_VAR
  
  pBuffer := NIL;

  IF (nBufferId = MM_BufferIn) THEN
    pBuffer := (#DataBuffer.m_udLength)$^MerkerEx;
  ELSIF (nBufferId = MM_BufferOut) THEN
    pBuffer := (#DataBufferOut.m_udLength)$^MerkerEx;
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::GetBufferLen
	VAR_INPUT
		nBufferId 	: UDINT;
	END_VAR
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR
  VAR
    pa : ^usint;
    pu : ^uint;
    tmplen  : UDINT;
    pBuffer : ^MerkerEx;
  END_VAR
  
  pBuffer := GetBuffer(nBufferId)$^MerkerEx;
  udLen := pBuffer^.m_udLength;// Get act. allocated size
  
  IF (m_flServerType = _MM_CHTY_STRING) THEN

    tmplen := udLen; 
    udLen := 0;
    pa    := GetData(nBufferId);

    IF(pa <> NIL) & (tmplen > 0) THEN
      IF(GetCharSize(nBufferId) = 1) THEN
        udLen := _strlen(pa);
      ELSE
        pu := pa$^UINT;
        WHILE(pu^ <> 0) DO
          udLen += 2;
          pu    += 2;
        END_WHILE;
      END_IF;
    END_IF; 
  END_IF;
 

END_FUNCTION

FUNCTION MMServerImpl::IsAscii
	VAR_INPUT
		nBufferId 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bRes 	: BOOL;
	END_VAR
  
  bRes := GetCharSize(nBufferId) = sizeof(CHAR);

END_FUNCTION

FUNCTION MMServerImpl::IsUnicode
	VAR_INPUT
		nBufferId 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bRes 	: BOOL;
	END_VAR
  
  bRes := GetCharSize(nBufferId) = sizeof(UINT);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::GetBufferAt
	VAR_INPUT
		nBufferId 	: UDINT;
		pData 	: ^USINT;
		udSize 	: UDINT;
		udAt 	: UDINT;
	END_VAR
  VAR
  	pBuffer : ^MerkerEx;
  END_VAR

  pBuffer := GetBuffer(nBufferId)$^MerkerEx;
  IF (pBuffer <> NIL) THEN
    pBuffer^.GetDataAt(pData, udSize, udAt);
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::GetCRC
	VAR_OUTPUT
		udCRC 	: UDINT;
	END_VAR

  udCRC := m_udCrcIn;

END_FUNCTION

FUNCTION VIRTUAL MMServerImpl::CalcCrc

  IF (m_flServerType = _MM_CHTY_STRING) THEN
    m_udCrcIn := CRC32_Buffer(DataBuffer.m_pData, DataBuffer.m_udLength);
  ELSE
    m_udCrcIn += 1;
  END_IF;

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::IsRequired
	VAR_OUTPUT
		bReq 	: BOOL;
	END_VAR
  
  bReq :=  ((m_flStatus AND MM_REQUIRED) = MM_REQUIRED);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::Data::GetState
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR

  MM_TRACE("Data::GetState: calling GetNewInstState", 0, 0, 0);
	ret_code := GetNewInstState(pPara, pResult);
  MM_TRACE("Data::GetState: GetNewInstState, ret=%d", ret_code, 0, 0);

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::GetNewInstState
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  VAR
		pParams 	: ^sNewInst;
  END_VAR

	ret_code := ERROR;

  IF (m_flServerType <> _MM_CHTY_STRING) THEN
  
    pParams := GetNewInstParams(pPara, pResult, FALSE);
    IF (pParams = NIL) THEN
      ret_code := ERROR;
      RETURN;
    END_IF;
    
     IF (pParams^.used <> unusedNewInst) THEN
    
      LockOn();
      IF (pParams^.used = finishedNewInst) THEN
        _memcpy(pResult, #pParams^.Results, sizeof(Results));
        // Fehlerbehebung DEVOS-549:
        // Wenn sich pParams^.used nach der Zuweisung 'ret_code := pParams^.IprState' auf 
        // finishedNewInst ändert, dann steht in ret_code der falsche Wert, daher muss 
        // die Zuweisung hier noch einmal gemacht werden.
        ret_code := pParams^.IprState;
            
        pParams^.used := unusedNewInst;
        
        IF (pParams^.IprState <> READY) THEN
          ret_code := ERROR_BUSY;
        END_IF;

      ELSIF ((m_flStatus AND MM_ONLINE) <> MM_ONLINE) THEN
        pParams^.used := unusedNewInst;
        ret_code := ERROR;
      ELSE
        ret_code := BUSY;
      END_IF;
      
      LockOff();
      
    END_IF;

  END_IF;

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::SendNewInst
	VAR_INPUT
		pParams 	: ^sNewInst;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  VAR
    cmd       : _MMThreadCmdLine;
  END_VAR

  ret_code := ERROR;

  IF ((pParams = NIL) | (pParams^.used = unusedNewInst)) THEN
    MM_TRACE("MMServerImpl::SendNewInst E1", 0, 0, 0);
    RETURN;
  END_IF;
  
  IF ((m_flFlags AND _MM_PROP_NEWINST) = _MM_PROP_NEWINST) THEN
  
   IF ((m_flStatus AND MM_ONLINE) <> MM_ONLINE) THEN
      pParams^.used := unusedNewInst;
      ret_code := ERROR;
      MM_TRACE("MMServerImpl::SendNewInst E2", 0, 0, 0);
      RETURN;
    END_IF;
  
    IF (pParams^.used = fromNewInst) THEN
      ret_code := BUSY;
    END_IF;

    cmd.cmd := MM_NEWINST;
    cmd.SvrHandle := this$UDINT;
    cmd.udStationId := -1$UDINT;
    cmd.pVoid := pParams$UDINT;
    
    IF(MMThread_AddCmd(#cmd) <> 1) THEN
      ret_code := ERROR_BUSY;
      pParams^.used := unusedNewInst;
      MM_TRACE("MMServerImpl::SendNewInst E3", 0, 0, 0);
    END_IF;
  
  ELSE
    TRACE_WARN("No NewInst configured.");
  END_IF;
  

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::GetNewInstParams
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
		bCreateNew 	: BOOL;
	END_VAR
	VAR_OUTPUT
		sParams 	: ^sNewInst;
	END_VAR
  VAR
		pFirstUnused 	: ^sNewInst;
    pNewInst      : ^sNewInst;
  END_VAR
  
  sParams := NIL;
  pFirstUnused := NIL;
  pNewInst := NIL;
  
  IF ((pPara = NIL) | (pResult = NIL)) THEN
    RETURN;
  END_IF;

  LockOn();
    
  
  IF (pNewInstArray = NIL) THEN
  
    IF (bCreateNew = TRUE) THEN
    
      pNewInstArray := _alloc_resize_LDR(sizeof(sNewInst))$^sNewInst;
      
     IF (pNewInstArray = NIL) THEN
        LockOff();
        RETURN;
      END_IF;
      
      pNewInst := pNewInstArray;
     
      pNewInst^.IprState := ERROR;
      pNewInst^.used := fromNewInst;
      pNewInst^.origparaAdr := pPara$UDINT;
      pNewInst^.origresAdr := pResult$UDINT;
      pNewInst^.next := NIL;
      _memcpy(#pNewInst^.Para, pPara, sizeof(CmdStruct));
      _memcpy(#pNewInst^.Results, pResult, sizeof(results));
      
      sParams := pNewInst;
    END_IF;
    
    LockOff();
    RETURN;
    
  END_IF;

  IF (pNewInstArray <> NIL) THEN
  
    pNewInst := pNewInstArray;

    WHILE pNewInst DO
  
      IF ((pFirstUnused = NIL) & (pNewInst^.used = unusedNewInst)) THEN
        pFirstUnused := pNewInst;
      END_IF;
      
      IF ( (pNewInst^.used <> unusedNewInst) & (pNewInst^.Para.uiCmd = pPara^.uiCmd)
          & ( pNewInst^.origparaAdr = pPara$UDINT) & (pNewInst^.origresAdr = pResult$UDINT) ) THEN
        IF (bCreateNew = FALSE) THEN
          _memcpy(pPara, #pNewInst^.Para, sizeof(CmdStruct));
          _memcpy(pResult, #pNewInst^.Results, sizeof(results));
          sParams := pNewInst;
        ELSE
           // bereits ein NewInst mit derselben Cmd Id im Gange, NICHT ERLAUBT
//           sParams := NIL;
//           LockOff();
//           RETURN;
        END_IF;
        LockOff();
        RETURN;
      END_IF;
      
      pNewInst := pNewInst^.next;
      
    END_WHILE;
    
  END_IF;
  
  IF (bCreateNew = TRUE) THEN
  
    IF (pFirstUnused <> NIL) THEN
      sParams := pFirstUnused;
    ELSE
      
      pNewInst := _alloc_resize_LDR(sizeof(sNewInst))$^sNewInst;
       IF (pNewInst = NIL) THEN
        LockOff();
        RETURN;
      END_IF;
      
      pNewInst^.next := NIL;
      
      sParams := pNewInst;

      pNewInst^.next := pNewInstArray;
      pNewInstArray := pNewInst;
      
    END_IF;

     sParams^.used := fromNewInst;
     sParams^.origparaAdr := pPara$UDINT;
     sParams^.origresAdr := pResult$UDINT;
    _memcpy(#sParams^.Para, pPara, sizeof(CmdStruct));
    _memcpy(#sParams^.Results, pResult, sizeof(results));

  ELSE
  
    sParams := NIL;
    
  END_IF;
  
  LockOff();
 

END_FUNCTION
FUNCTION GLOBAL MMServerImpl::ResetInitializedFlag

   RemoveStatus(MM_VALID_VALUE OR MM_INITIALIZED);

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::InvokeCallback
  
  IF ((m_udLasalId = 0) & (m_pStation <> NIL)) THEN
    MM_InvokeUserCallbackServer(this$UDINT, _MMState::SvrNotFoundAtStation);
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::GetDataPtrIn
	VAR_OUTPUT
		pData 	: ^USINT;
	END_VAR
  
  pData := DataBuffer.GetDataPtr();
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerImpl::Data::Kill
	VAR_OUTPUT
		ret_code (EAX) 	: IprStates;
	END_VAR

	ret_code := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerImpl::SetBufferSize
	VAR_INPUT
		nBufferId 	: UDINT;
		udLen 	: UDINT;
	END_VAR
  VAR
    pBuffer : ^MerkerEx;
  END_VAR
  
  pBuffer := GetBuffer(nBufferId)$^MerkerEx;
  
  IF (udLen > GetBufferLen(nBufferId)) THEN 
    pBuffer^.SetSize(udLen);
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerImpl::SetBufferSizeForce
	VAR_INPUT
		nBufferId 	: UDINT;
		udLen 	: UDINT;
	END_VAR
  VAR
    pBuffer : ^MerkerEx;
  END_VAR
  
  pBuffer := GetBuffer(nBufferId)$^MerkerEx;
  pBuffer^.SetSize(udLen);

END_FUNCTION


FUNCTION GLOBAL MMServerImpl::IsSpecialPriority
	VAR_OUTPUT
		bYes 	: BOOL;
	END_VAR

  bYes := ((m_uiPriority = MM_NoRefreshlistEntry) | (m_uiPriority = MM_GetValueOnce));

END_FUNCTION


FUNCTION GLOBAL MMServerImpl::AddStatus
	VAR_INPUT
		bStati 	: BYTE;
	END_VAR
  
  m_flStatus := (m_flStatus OR bStati);
  
  IF (bStati AND MM_ERROR_STATI) THEN
    RemoveStatus(MM_VALID_VALUE);
  ELSIF (bStati AND MM_VALID_VALUE) THEN
    RemoveStatus(MM_ERROR_STATI);
  END_IF;

END_FUNCTION

FUNCTION GLOBAL MMServerImpl::RemoveStatus
	VAR_INPUT
		bStati 	: BYTE;
	END_VAR
  
  m_flStatus := (m_flStatus AND ((NOT bStati)$BYTE));

END_FUNCTION

#pragma warning(default:137);


FUNCTION GLOBAL MMServerImpl::GetBufferAtWithChgBytes
	VAR_INPUT
		nBufferId 	: UDINT;
		pData 	: ^USINT;
		udSize 	: UDINT;
		udAt 	: UDINT;
		pChgBytes 	: ^USINT;
	END_VAR
  VAR
  	pBuffer : ^MMBuffer;
  END_VAR

  pBuffer := GetBuffer(nBufferId)$^MMBuffer;
  IF (pBuffer <> NIL) THEN
    pBuffer^.GetDataAtWithChgBytes(pData, udSize, udAt, pChgBytes);
  END_IF;

END_FUNCTION
