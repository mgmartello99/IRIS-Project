//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#include "RTOS_IprIntern.h"
#pragma using BaseIp

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "ProgIp"
	Revision           = "0.0"
	GUID               = "{E6C1A536-8707-4D26-B5FF-68BF0364C350}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="pCmd">
		</Server>
		<Client Name="m_Breakpoints" Required="true" Internal="false"/>
	</Channels>
	<Network Name="ProgIp">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{D25F6048-9FC0-4EE7-AA40-268322B0C6B4}"
				Class      = "BaseIp"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="pCmd"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.pCmd" Destination="_base.pCmd" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using BaseIp

ProgIp : CLASS
: BaseIp
	TYPE
#pragma pack(push, 1)
	  StackInfo : STRUCT
	    pCall : ^instruct;
	    uiLineNr : UINT;
	    uiCalledFrom : UINT;
	    uiCalledIpr : UINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
  //Clients:
	m_Breakpoints 	: CltChCmd_RAMex;
  //Variables:
		uiActLine 	: UINT;
		m_pPrgHead 	: ^NewSubPrgHead;
		m_dTriggerCnt 	: UDINT;
		m_dTriggerOffset 	: UDINT;
		m_uiSubLevels 	: UINT;
		m_subStack : ARRAY [0..9] OF StackInfo;

		m_udCFLCycle 	: UDINT;
		m_udLastCFL 	: UDINT;
		m_bCFLExchange 	: BOOL;
		m_bSoftExchange 	: BOOL;
		m_loadState 	: LOAD_STATE;
		m_uiBpCnt 	: UINT;
		m_uiCalledFrom 	: UINT;
		m_uiCalledIpr 	: UINT;
		m_udSinglestepBp 	: UDINT;
		m_allocSizeFix 	: BOOL;
		m_udPrgSize 	: UDINT;
		m_bNotFromTable 	: BOOL;
		m_maxProgSeqDuration_ms 	: UDINT;
		m_maxNbrIprCmds 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION GLOBAL ProgIp
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SetCalledIpr
		VAR_INPUT
			uiIprNo 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL BefIpr
		VAR_INPUT
			bSetNext 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			state 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL KillActiveObjects;
	
	FUNCTION GLOBAL SetNextInstruction;
	
	FUNCTION GLOBAL SetInstructionToProgStart
		VAR_INPUT
			nLabel 	: UINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL SetNextInstructionLabelNo
		VAR_INPUT
			nLabel 	: UINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: UINT;
		END_VAR;
	
	FUNCTION SetNextInstructionLabel
		VAR_OUTPUT
			ret_code 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL PushSubStack
		VAR_OUTPUT
			ret_code 	: UINT;
		END_VAR;
	
	FUNCTION PopSubStack
		VAR_OUTPUT
			ret_code 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL SetBreakpoint
		VAR_INPUT
			dOffset 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bBpValid 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL DeleteBreakpoint
		VAR_INPUT
			dOffset 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bBpValid 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL RemoveAllBreakpoints;
	
	FUNCTION SetSSBreakpoint
		VAR_INPUT
			dOffset 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bBpValid 	: BOOL;
		END_VAR;
	
	FUNCTION DeleteSSBreakpoint
		VAR_INPUT
			dOffset 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bBpValid 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL MakeSingleStep;
	
	FUNCTION GLOBAL StepOver;
	
	FUNCTION GLOBAL RunInterpreter;
	
	FUNCTION GLOBAL SetCalledFrom
		VAR_INPUT
			uiIprNo 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL InitVariables;
	
	FUNCTION GLOBAL Hold;
	
	FUNCTION GLOBAL StepOut;
	
	FUNCTION GLOBAL LoadProgFromTemp
		VAR_INPUT
			nProgNo 	: UDINT;
			bCheck 	: BOOL := TRUE;
			bDoNotLink 	: BOOL := FALSE;
			bBTnoRun 	: BOOL := FALSE;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL SetCodePointer
		VAR_INPUT
			udCodeOffset 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetInstructionToProgStartOfs
		VAR_INPUT
			offset 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL EndOfCode
		VAR_OUTPUT
			bEOC 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SetPrgHead
		VAR_INPUT
			pPrgHead 	: ^NewSubPrgHead;
		END_VAR;
	
	FUNCTION GLOBAL DebugInst
		VAR_INPUT
			pCode 	: ^instruct;
			pResu 	: ^results;
		END_VAR;
	
	FUNCTION GLOBAL GetCFLCycle
		VAR_OUTPUT
			udCycle 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetCalledIpr
		VAR_OUTPUT
			uiIpr 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL SetLoaded;
	
	FUNCTION GLOBAL SetFileCheck
		VAR_INPUT
			udFileCheck 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetFileCheck
		VAR_OUTPUT
			udFileCheck 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetMaxProgSeqDuration_ms
		VAR_OUTPUT
			maxProgSeqDuration_ms 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetMaxProgSeqDuration_ms
		VAR_INPUT
			maxProgSeqDuration_ms 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL InitModule;
	
	FUNCTION GLOBAL SetInstructionToLabel
		VAR_INPUT
			nLabel 	: UINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL GetCodeOfs
		VAR_OUTPUT
			ofs 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL HandleError;
	
	FUNCTION GLOBAL SetNextInstructionOfs
		VAR_INPUT
			offset 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: UINT;
		END_VAR;
	
	FUNCTION SkipComment;
	
	FUNCTION GLOBAL GetSubStack
		VAR_INPUT
			pNoOfSubLevels 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			pSubStack 	: ^ProgIp::StackInfo;
		END_VAR;
	
	FUNCTION GLOBAL SetMaxNbrIprCmds
		VAR_INPUT
			maxNbrIprCmds 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetMaxNbrIprCmds
		VAR_OUTPUT
			maxNbrIprCmds 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL pCmd::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd RAMex


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ProgIp::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_PROGIP
0$UINT, 0$UINT, (SIZEOF(::ProgIp))$UINT, 
0$UINT, 1$UINT, 0$UINT, 
TO_UDINT(65880937), "ProgIp", //Class
TO_UDINT(1945645538), "BaseIp", 0$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
(::ProgIp.m_Breakpoints.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3644967365), "m_Breakpoints", TO_UDINT(933570811), "RAMex", 1$UINT, 16$UINT, 
END_FUNCTION


#define USER_CNT_ProgIp 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ProgIp] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ProgIp::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= BaseIp::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= BaseIp::pCmd.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, BaseIp::pCmd.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_ProgIp;
	vmt.CmdTable.NewInstr		:= #pCmd::NewInst();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #SetCalledIpr();

#pragma warning (default : 74)
	BaseIp::pCmd.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF BaseIp::pCmd.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= ProgIp();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include ".\include\L2_Ipr.h"
//#include ".\RTOS_PrivDefs.h"
#include ".\RTOS_PrivHeader.h"
#include ".\LoaderItf.h"

#pragma using DebugIp
#pragma using IprMgr
#pragma using ProgMgr

VAR_PRIVATE
  pIprCbFunc : pVoid;
  pIprCbThis : pVoid;
END_VAR

// Initialisierungsfunktion für dieses Modul
FUNCTION GLOBAL ProgIp::InitModule

  pIprCbFunc := NIL;
  pIprCbThis := NIL;

END_FUNCTION

FUNCTION ProgIp::ProgIp
VAR_OUTPUT
	ret_code	: ConfStates;
END_VAR
VAR
	vmt	: _LSL_STD_VMETH;
	nCmdSize	: UINT;
END_VAR

	ret_code := C_OK;
	
	BaseIp2(FALSE);

	nCmdSize		:= BaseIP::pCmd.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;
	_memcpy((#vmt.CmdTable)$^USINT, BaseIP::pCmd.pMeth, nCmdSize);

	// Anzahl der virtuellen Methoden erhöht sich in ProgIP nicht
	// overwrite default methods here
	vmt.CmdTable.Init 		:= #Init();
	vmt.CmdTable.NewInstr := #NewInst();
	vmt.UserFcts[0]			  := #SetCalledIpr();

	// store new command table
	pCmd.pMeth		    := StoreCmd(pCmd:=#vmt.CmdTable, EXCLUSIVE);

	m_udLastCFL	      := ops.tAbsolute;
	m_loadState		    := LS_NONE;
	m_uiCalledFrom	  := 0xFFFF;
	m_uiCalledIpr	    := 0xFFFF;
	m_udSinglestepBp  := 0xFFFFFFFF;
  m_maxProgSeqDuration_ms := 3 ms;
  m_maxNbrIprCmds   := 0xFFFFffff;
	
	IF m_pPrgHead <> NIL THEN
		m_pPrgHead^.udFileCheck	:= 0xFFFFFFFF;
	END_IF;

END_FUNCTION
//Diese Funktion setzt den Codepointer auf die nächste Anweisung.
//Funktioniert noch nicht, bei Programmaufrufen und Return
FUNCTION GLOBAL ProgIp::MakeSingleStep
VAR
	bSetNext	: UDINT;
	retState 	: IPRSTATES;
END_VAR

	
	IF _m.head.funkst <> STOP_BP & 
		_m.head.funkst <> SINGLESTEP THEN 
		RETURN;
	END_IF;	
	
	_m.head.funkst := READY;
	_m.head.workState := SINGLESTEP;
	
	retState := BefIpr(#bSetNext);

	IF  (retState = READY | retState = SINGLESTEP)
		& bSetNext THEN
		SetNextInstruction();
		_m.head.funkst := SINGLESTEP;
	END_IF;
			
END_FUNCTION
//Wenn der Interpreter beim Singlesteppen ist dann wird er 
//gestartet (Status wird auf Ready gesetzt)
FUNCTION ProgIp::RunInterpreter
VAR
	pIpr	: ^ProgIp;
END_VAR

	IF _m.head.funkst = STOP_BP |
		_m.head.funkst = SINGLESTEP THEN 
		_m.head.funkst := READY;
		//wenn ein Interpreter von einem anderen aufgerufen wurde
		//dann muss derjenige warten bis der workstate auf READY ist
		IF m_uiCalledFrom <> GetInterpreterNumber() THEN
			pIpr := IprMgr::GetInterpreter(m_uiCalledFrom);
			// Nur wenn auch der Interpreter von dem dieser Ipr aufgerufen wurde 
			// die Nummer dieses Iprs in m_uiCalledIpr drinnen hat wartet er
			IF pIpr^.GetCalledIpr() = GetInterpreterNumber() THEN
				_m.head.workstate := BUSY;
			END_IF;
		ELSE
			_m.head.workstate := READY;
		END_IF;
	END_IF;	

END_FUNCTION
// Sucht alle Interpreter durch und vergleicht den this pointer
// wenn der Pointer gleich ist mit dem Interpereter dann wird die Nummer
// zurückgeschickt
FUNCTION BaseIp::GetInterpreterNumber
VAR_OUTPUT
	uiProgNo	: UINT;
END_VAR
VAR
END_VAR

	IF ops.pProg = NIL THEN
		uiProgNo := 0xFFFF;
		RETURN;
	END_IF;

	uiProgNo:= OPS.pProg^.uiProgs;
	WHILE uiProgNo  DO
		
		uiProgNo	-= 1;
		IF IprMgr::GetInterpreter(uiProgNo) = THIS THEN
			RETURN;
		END_IF;

	END_WHILE;

	uiProgNo := 16#FFFF;
	RETURN;
END_FUNCTION
//Bestimmt welchen Interpreter dieser aufgerufen hat
FUNCTION GLOBAL VIRTUAL ProgIp::SetCalledIpr
VAR_INPUT
	uiIprNo		: UINT;
END_VAR

	m_uiCalledIpr := uiIprNo;

END_FUNCTION

//Legt fest von welchem Interpreter dieser aufgerufen wurde
FUNCTION ProgIp::SetCalledFrom
VAR_INPUT
	uiIprNo		: UINT;
END_VAR

	m_uiCalledFrom := uiIprNo;

END_FUNCTION

//erst hier ist alles Initialisiert
FUNCTION GLOBAL ProgIp::InitVariables

	//Als Initialisierungswert für die beiden Variablen wird die Nummer des
	//eigenen Interpreters eingetragen
	m_uiCalledFrom	:= GetInterpreterNumber();
	m_uiCalledIpr	:= m_uiCalledFrom;

END_FUNCTION
//Der Interpreter springt über die nächste Anweisung
FUNCTION ProgIp::StepOver
VAR
	bSetNext	: UDINT;
END_VAR
		
	IF _m.head.funkst <> STOP_BP & 
		_m.head.funkst <> SINGLESTEP THEN 
		RETURN;
	END_IF;	

	//nur bei einem CALL oder einen RUNPROG muss etwas anderes als bei einem Singlestep gemacht werden
	IF _m.head.pCode^.opCode <> I_CALL & 
		_m.head.pCode^.opCode <> I_RUNPROG THEN
		MakeSingleStep();
		RETURN;
	END_IF;

	//setzte einen Breakpoint auf die nächste Anweisung
	SetSSBreakpoint(_m.head.pCode$UDINT + _m.head.pCode^.uiLng);

	_m.head.funkst := READY;
	_m.head.workState := READY;
	_m.head.funkst := BefIpr(#bSetNext);
	_m.head.workState := SINGLESTEP;

END_FUNCTION
//Stopt den Interpreter
FUNCTION ProgIp::Hold
END_FUNCTION
//Springt aus der Unterfunktion heraus
FUNCTION ProgIp::StepOut
END_FUNCTION
//Fügt einen Breakpoint auf den Offset ein
FUNCTION ProgIp::SetSSBreakpoint
VAR_INPUT
	dOffset		: UDINT;
END_VAR
VAR_OUTPUT		
	bBpValid	: BOOL;
END_VAR
	
	bBpValid := FALSE;
	IF m_udSinglestepBp <> 0xFFFFFFFF THEN
		RETURN;
	END_IF;

	bBpValid := TRUE;
	m_udSinglestepBp := dOffset;

END_FUNCTION
//Löscht einen Breakpoint
FUNCTION ProgIp::DeleteSSBreakpoint
VAR_INPUT
	dOffset		: UDINT;
END_VAR
VAR_OUTPUT		
	bBpValid	: BOOL;
END_VAR

	bBpValid := FALSE;
	IF dOffset = 0xFFFFFFFF THEN
		RETURN;
	END_IF;

	m_udSinglestepBp := 0xFFFFFFFF;
	bBpValid := TRUE;

END_FUNCTION
//Fügt einen Breakpoint auf den Offset ein
FUNCTION ProgIp::SetBreakpoint
VAR_INPUT
	dOffset		: UDINT;
END_VAR
VAR_OUTPUT		
	bBpValid	: BOOL;
END_VAR
VAR
	NewBp		: IprBreakpoint;
END_VAR

	NewBp.dOffset := dOffset;
	NewBp.dIprCRC := ProgMgr::GetUnlinkedProgramChkSum(#m_pPrgHead^.subProgHead);
	
	m_uiBpCnt := m_uiBpCnt+1;
	//Array um 4 Byte vergrössern und Offset für den Breakpoint speichern
	IF m_Breakpoints.SetSize(sizeof(IprBreakpoint)*m_uiBpCnt) <> C_OK 
	 | m_Breakpoints.SetDataAt(#(dOffset$USINT), sizeof(IprBreakpoint), (m_uiBpCnt-1)*sizeof(IprBreakpoint)) <> C_OK THEN
		bBpValid := FALSE;
		RETURN;
	END_IF;

	bBpValid := TRUE;
END_FUNCTION
//Löscht einen Breakpoint
FUNCTION ProgIp::DeleteBreakpoint
VAR_INPUT
	dOffset		: UDINT;
END_VAR
VAR_OUTPUT		
	bBpValid	: BOOL;
END_VAR
VAR
	i			: UINT;
	//dBpOffset	: UDINT;
	pData		: ^USINT;
	IprBp		: IprBreakpoint;
END_VAR
	
	i := 0;

	// Durchsuche die ganzen Breakpoints
	WHILE i < m_uiBpCnt DO
		//Auslesen vom Offset des i-ten Breakpoint
		IF m_Breakpoints.GetDataAt(#(IprBp$USINT), sizeof(IprBreakpoint), i*sizeof(IprBreakpoint)) <> C_OK THEN
			bBpValid := FALSE;
			RETURN;
		END_IF;
		
		//Der gesuchte Offset wurde gefunden
		IF IprBp.dOffset = dOffset THEN
			m_uiBpCnt := m_uiBpCnt-1;
			pData := _alloc((m_uiBpCnt-i)*sizeof(IprBreakpoint))$^usint;
			//Den Block der nach dem Breakpoint gespeichert wurde 4 Byte weiter vorkopieren 
			//und die Grösse des Speichers verringern
			IF pData <> NIL THEN //BUG 177
				IF 	m_Breakpoints.GetDataAt(pData, (m_uiBpCnt-i)*sizeof(IprBreakpoint), (i+1)*sizeof(IprBreakpoint)) <> C_OK |
					m_Breakpoints.SetDataAt(pData, (m_uiBpCnt-i)*sizeof(IprBreakpoint), (i)*sizeof(IprBreakpoint)) <> C_OK THEN
					bBpValid := FALSE;
					RETURN;
				END_IF;
				_free(pData);
			END_IF;

			IF m_Breakpoints.SetSize(m_uiBpCnt*sizeof(IprBreakpoint)) <> C_OK THEN
				bBpValid := FALSE;
				RETURN;
			END_IF;

			bBpValid := TRUE;
			RETURN;
		END_IF;
		i+=1;
	END_WHILE;
	bBpValid := FALSE;

END_FUNCTION

// DEVOS-611 [SA 40071]
// Inkrementiert den Codepointer solange dieser auf eine Instruktion zeigt, die 
// kein Kommentar ist. Dadurch werden beim Single-Steppen Kommentare übersprungen.
// (Anm.: ursprünglich war angedacht auch Label und FUNCTION (I_LBL, I_FUNCTION) 
// zu überspringen, aber lt. Mario Schmid wird der Interpreter beim Dr.Boy etwas 
// anders verwendet, das würde dann zu einem undurchsichtigen Verhalten beim 
// Single-Steppen führen).
FUNCTION ProgIp::SkipComment

  WHILE 
    _m.head.pCode^.opCode = I_COMMENT
  DO
    SetCodePointer(_m.head.pCode$UDINT + _m.head.pCode^.uiLng);// add length of last instruction
    uiActLine	+= 1;					// line in interpreter code
  END_WHILE;

END_FUNCTION

// set next instruction after the last one was executed

FUNCTION ProgIp::SetNextInstruction

  SetCodePointer(_m.head.pCode$UDINT + _m.head.pCode^.uiLng);// add length of last instruction

  uiActLine	+= 1;					// line in interpreter code
                    // = #instruction

  SkipComment();
                      
END_FUNCTION
// set next instruction after a jump or call was executed
//
FUNCTION ProgIp::SetNextInstructionLabelNo
VAR_INPUT
	nLabel		: UINT;
END_VAR
VAR_OUTPUT
	ret_code	: UINT;
END_VAR
VAR
	pLabel		: ^LABEL;
	szLabelName	: ARRAY[0..NLNG] OF CHAR;
	szTempLabel : ARRAY[0..NLNG] OF CHAR;
	i			: UINT;
	nProgNo		: UDINT;
	pTempProg	: pSubPrgHead;
	uiLabelCnt	: UINT;
END_VAR
        																				// get start of label descriptors
	pLabel	:= #m_pPrgHead^.subProgHead + m_pPrgHead^.subProgHead.udOffLbl;

	// number of labels is less or equal to label index
	IF pLabel^.uiLineNo <= nLabel THEN   							// label number is invalid
		SetRunTimeError();
    SetLastError(PROGIP_ERR_LABELINVALID);
		ret_code := FALSE;
		RETURN;
	END_IF;

	// Wenn das Programm "soft" ausgetauscht werden soll
	IF m_bSoftExchange = TRUE THEN
		// zuerst wird der Name des Labels gesucht und in szLabelName hineingeschrieben
		pLabel	+= sizeof(UINT) + pLabel^.uiLineNo*SIZEOF(Label);//pointer auf den Anfang der Strings setzten
		FOR i := 0 TO nLabel DO
			_strcpy(#szLabelName[0], pLabel$^char);
			pLabel += _strlen(#szLabelName[0]) + 1;
		END_FOR;

		// Das Temporäre programm wird in pTempProg gespeichert 
		nProgNo := ProgMgr::GetProgramNumber(#m_pPrgHead^.subProgHead.szName[0]);
		pTempProg := ProgMgr::GetProgram(nProgNo + MAX_IP_PROGS);
		
		// Jetzt wird im Temp. Programm nach einen Label mit den Namen gesucht zu dem er springen soll
		pLabel := pTempProg + pTempProg^.udOffLbl;
		uiLabelCnt := pLabel^.uiLineNo;//Labelanzahl steht in den ersten 2 Byte
		pLabel += sizeof(UINT) + pLabel^.uiLineNo*SIZEOF(Label);
		FOR i := 0 TO uiLabelCnt DO
			_strcpy(#szTempLabel[0], pLabel$^char);
			pLabel += _strlen(#szTempLabel[0]) + 1;
			
			//Wenn ein Label mit dem entsprechenden Namen gefundenwurde ...
			IF _stricmp(#szTempLabel[0], #szLabelName[0]) = 0 THEN
				
				nLabel := i;// i ist die LabelNummer
				//Programm austauschen
				_m.head.funkSt := ERROR;
				LoadProgFromTemp(nProgNo);
				_m.head.funkSt := BUSY;
				i := uiLabelCnt;
			END_IF;
		END_FOR;
		
		pLabel	:= #m_pPrgHead^.subProgHead + m_pPrgHead^.subProgHead.udOffLbl;
	END_IF;

	// add number of labels + offset to label-n
	pLabel		+= sizeof(UINT)+nLabel*SIZEOF(Label);	// add count- and label-size

	uiActLine	:= pLabel^.uiLineNo;						// set next instruction
	SetCodePointer((#m_pPrgHead^.subProgHead + //Offset des Programmkopfes
					m_pPrgHead^.subProgHead.udOffCode + //rel. Offset des Codebeginns
					pLabel^.udLineOffset)$UDINT); //rel. Offset des Labels
          
  SkipComment();

	ret_code	:= TRUE;

END_FUNCTION


FUNCTION GLOBAL ProgIp::SetNextInstructionOfs
	VAR_INPUT
		offset 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: UINT;
	END_VAR
VAR
	pCode : ^instruct;
  uiLine : UINT;
END_VAR

  // prüfen, ob Offset innerhalb des Programms liegt
	IF offset >= m_pPrgHead^.subProgHead.udLng THEN
		SetRunTimeError();
    SetLastError(PROGIP_ERR_ENDOFCODE);
		ret_code := FALSE;
		RETURN;
	END_IF;

	SetCodePointer((#m_pPrgHead^.subProgHead + //Offset des Programmkopfes
					m_pPrgHead^.subProgHead.udOffCode + //rel. Offset des Codebeginns
					offset)$UDINT); //rel. Offset des Labels

  // die zum Code gehörende Zeilennummer suchen und aktualisieren          
  uiLine := 0;
  pCode := #m_pPrgHead^.subProgHead(*Offset des Programmkopfes*) + m_pPrgHead^.subProgHead.udOffCode;
  WHILE pCode < _m.head.pCode DO
    uiLine += 1;
    pCode += pCode^.uiLng;
  END_WHILE;
  uiActLine := uiLine;

	ret_code	:= TRUE;

END_FUNCTION


// set next instruction after a jump or call was executed

FUNCTION ProgIp::SetNextInstructionLabel
VAR_OUTPUT
	ret_code	: UINT;
END_VAR

	ret_code := SetNextInstructionLabelNo(_m.head.pCode^.aPara[0]$UINT);

END_FUNCTION

// Called to start a interpreter program

FUNCTION ProgIp::SetInstructionToProgStart
VAR_INPUT
	nLabel		: UINT;
END_VAR
VAR_OUTPUT
	ret_code	: IPRSTATES;
END_VAR

	m_uiSubLevels	:= 0;

	IF SetNextInstructionLabelNo(nLabel) = FALSE THEN
		ret_code		:= ERROR;
		RETURN;
	END_IF;

	_m.head.funkst	:= READY;
	ret_code	:= BUSY;

END_FUNCTION

FUNCTION GLOBAL ProgIp::SetInstructionToProgStartOfs
VAR_INPUT
	offset : UDINT;
END_VAR
VAR_OUTPUT
	ret_code	: IPRSTATES;
END_VAR

	m_uiSubLevels	:= 0;

	IF SetNextInstructionOfs(offset) = FALSE THEN
		ret_code		:= ERROR;
		RETURN;
	END_IF;

	_m.head.funkst	:= READY;
	ret_code	:= BUSY;

END_FUNCTION

FUNCTION GLOBAL ProgIp::SetInstructionToLabel
VAR_INPUT
	nLabel		: UINT;
END_VAR
VAR_OUTPUT
	ret_code	: IPRSTATES;
END_VAR

	IF SetNextInstructionLabelNo(nLabel) = FALSE THEN
		ret_code		:= ERROR;
		RETURN;
	END_IF;

	_m.head.funkst	:= READY;
	ret_code	:= BUSY;

END_FUNCTION

// Prepares the stack for a return after a call.
// Checks if the stack is not full
FUNCTION GLOBAL ProgIp::PushSubStack
VAR_OUTPUT
	ret_code		: UINT;
END_VAR

	IF m_uiSubLevels >= MAXNESTING -1 THEN
		SetRunTimeError();
    SetLastError(PROGIP_ERR_STACKOVERFLOW);
		ret_code := FALSE;
		RETURN;
	END_IF;

	m_SubStack[m_uiSubLevels].pCall		:= (_m.head.pCode$hdint-(#m_pPrgHead^.subProgHead)$hdint)$^instruct;
	m_SubStack[m_uiSubLevels].uiLineNr	:= uiActLine;
	m_SubStack[m_uiSubLevels].uiCalledFrom	:= m_uiCalledFrom;
	m_SubStack[m_uiSubLevels].uiCalledIpr	:= m_uiCalledIpr;
	m_uiSubLevels += 1;

	ret_code := TRUE;

END_FUNCTION
// Sets the program pointer after a return from a call to a subroutine.
// Checks if the stack is not empty
FUNCTION ProgIp::PopSubStack
VAR_OUTPUT
	ret_code		: UINT;
END_VAR
VAR
	uiIprNo			: UINT;
	pIpr			: ^ProgIp;
END_VAR

	//Anm. CP: Hier darf er nur hineinspringen wenn er von einem anderen 
	//Interpreter aufgerufen wurde und jetzt wieder "zurückspringt"
	IF m_uiSubLevels < 1 THEN
		SetRunTimeError();
    SetLastError(PROGIP_ERR_ENDOFCODE);
		ret_code := FALSE;
		
		//zurücksetzten der Nummern der aufgerufenen/zu aufrufenden 
		uiIprNo := GetInterpreterNumber();
		IF m_uiCalledFrom <> uiIprNo THEN
			pIpr := IprMgr::GetInterpreter(m_uiCalledFrom);
			IF pIpr <> NIL THEN
				pIpr^.SetCalledIpr(m_uiCalledFrom);
			END_IF;
			m_uiCalledFrom := uiIprNo;
		END_IF;
		
		RETURN;
	END_IF;

	m_uiSubLevels	-= 1;
	SetCodePointer(	m_SubStack[m_uiSubLevels].pCall$hdint + 
					(#m_pPrgHead^.subProgHead)$hdint);
	//_m.head.pCode	:= ()$^instruct;
	uiActLine		:= m_SubStack[m_uiSubLevels].uiLineNr;

  //zurücksetzten der Nummern der aufgerufenen/zu aufrufenden 
  uiIprNo := GetInterpreterNumber();
  IF m_uiCalledFrom <> uiIprNo THEN
    pIpr := IprMgr::GetInterpreter(m_uiCalledFrom);
    IF pIpr <> NIL THEN
      pIpr^.SetCalledIpr(m_uiCalledFrom);
    END_IF;
  END_IF;

  m_uiCalledFrom := m_SubStack[m_uiSubLevels].uiCalledFrom;
	m_uiCalledIpr := m_SubStack[m_uiSubLevels].uiCalledIpr;

	ret_code		:= TRUE;

END_FUNCTION
// Call Kill() for all active objects

FUNCTION ProgIp::KillActiveObjects
VAR
	j			: UINT;
END_VAR

	FOR j:=0 TO ANZ_FPTRS-1 DO
		IF _m.head.fptrs[j] <> NIL THEN
			_m.head.fptrs[j]^.Kill();
			_m.head.fptrs[j] := NIL;
		END_IF;
	END_FOR;

END_FUNCTION
//    
//    This is the Interpreter
//    ----------------------------------------------------------
//		-> pointer to active interpreter
//		<- bSetNext	: usually TRUE, after GOTO or CALL FALSE
//		<- state	: ready, busy, error, error_busy

FUNCTION GLOBAL ProgIp::BefIpr
VAR_INPUT
	bSetNext		: ^UDINT;
END_VAR
VAR_OUTPUT
	state			: IPRSTATES;
END_VAR
VAR
	pResData		: ^UDINT;
	dPara			: DINT;
	pRead			: ^VOID;
	progAddr		: ^VOID;
	pOtherIpr			: ^ProgIp;
	pOtherHead		: ^IprHead;
END_VAR

	pRead 		:= #_m.head.pCode^.aPara[0];
	pResData 	:= #_m.resu.aData[0]$UDINT;
	bSetNext^	:= TRUE;
	state		  := READY;

	CASE _m.head.pCode^.opCode OF
	//--------------------------------------------------------------------
	//         0123  P,54678
	// <Write> <Dest) <Data>
	//--------------------------------------------------------------------

	I_WRITE:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

			progAddr		:= pRead+4;			// evaluate expression
			dPara			:= GetResu((#progAddr)$^void, _m.head.pResu);
//**			CLI();
			pResData^		:= WR(((pRead$^pVoid)^)$pSvrCh, dPara);
//**			STI();
			_m.resu.uiLng		:= 2+sizeof(DINT);	// len (2) + data (4 byte)
		END_IF;

	//--------------------------------------------------------------------
	//         P1234
	// <Delay> <Time>
	//--------------------------------------------------------------------

	I_DELAY:
		_m.resu.uiLng	:= SEND_STATE_ONLY;		// no return value specified

		CASE _m.head.funkst OF
		READY:
			_m.head.tStart			:= OPS.tAbsolute;
			state				:= BUSY;

		BUSY:
			dPara				:= GetResu((#pRead)$pVoid, _m.head.pResu);
			IF TO_DINT(OPS.tAbsolute - _m.head.tStart) < dPara THEN
				state			:= BUSY;
			ELSIF _m.head.workstate = SINGLESTEP & 
					m_udSinglestepBp = 0xFFFFFFFF THEN	
				state := SINGLESTEP;
				_m.head.workstate := READY;
			END_IF;
		END_CASE;


	// delays the program until the expression is true
	//	aPara[0]		<expr>		x byte
	I_WAITFOR:
		CASE _m.head.funkst OF	
		READY:							// start waiting
			_m.head.funkst := BUSY;		// .. at least for a moment
			GOTO CHECK_END_OF_WAIT;
		BUSY:
CHECK_END_OF_WAIT:
			IF GetResu((#pRead)$pVoid, _m.head.pResu) = 0 THEN
				state := BUSY;
			ELSIF _m.head.workstate = SINGLESTEP THEN	
				state := SINGLESTEP;
				_m.head.workstate := READY;
			END_IF;
		END_CASE;

	//--------------------------------------------------------------------
	// < command ><pSvrCh_cmd><command><dStruct><dStruct> ...
	//--------------------------------------------------------------------
	I_CMD:
		state	 := CallUserClassMethod();
    IF state = ERROR THEN
      SetLastError(PROGIP_ERR_ICMDFAILED);
    END_IF;
		IF state = READY & 
			_m.head.workstate = SINGLESTEP THEN
			state := SINGLESTEP;
			_m.head.workstate := READY;
		END_IF;

	//--------------------------------------------------------------------
	// <GO_TO> ,<uiLabelNo>
	//--------------------------------------------------------------------
	I_GOTO:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;
			IF SetNextInstructionLabel() = FALSE THEN
				GOTO SET_ERROR;
			ELSE
				bSetNext^		:= FALSE;
				IF _m.head.workstate = SINGLESTEP & 
					m_udSinglestepBp = 0xFFFFFFFF THEN
					_m.head.funkst := SINGLESTEP;
				END_IF;
			END_IF;
		END_IF;


		// aPara[0]		<label>		2 byte
		// aPara[2]		<expr>		x byte
	I_JMPIF:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

			// evaluate condition
			pRead += 2;
			IF	GetResu((#pRead)$pVoid, _m.head.pResu) <> 0 THEN
				IF SetNextInstructionLabel() = FALSE THEN
					GOTO SET_ERROR;
				END_IF;
				bSetNext^		:= FALSE;
				IF _m.head.workstate = SINGLESTEP THEN
					_m.head.funkst := SINGLESTEP;
				END_IF;
			END_IF;
		END_IF;

	//--------------------------------------------------------------------
	// <END_PRG>
	//--------------------------------------------------------------------

	I_ENDPROG:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

			IF m_bSoftExchange = TRUE THEN
				_m.head.funkst := ERROR;
				CheckForLoad();				
			END_IF;

		    state				:= QUIT;
		END_IF;
	//--------------------------------------------------------------------
	// <_CALL> , < uiLabelNo>
	//--------------------------------------------------------------------

	I_CALL:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

			IF PushSubStack()				= FALSE |
				SetNextInstructionLabel()	= FALSE THEN
				GOTO SET_ERROR;
			ELSE
				bSetNext^		:= FALSE;
				IF _m.head.workstate = SINGLESTEP THEN
					_m.head.funkst := SINGLESTEP;
				END_IF;
			END_IF;
		END_IF;

	I_RET:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

			IF PopSubStack() = FALSE THEN
				GOTO SET_ERROR;
			END_IF;
      
      IF _m.head.pCode^.opCode = I_RUNPROG THEN
        // In die Funktion wurde nicht durch einen normalen Unterprogrammaufruf 
        // verwzeigt, sondern ein I_RUNPROG Aufruf wurde durch einen I_RUNPROG Aufruf 
        // eines anderen Interpreters unterbrochen.
        // In so einem Fall muß der funkSt BUSY wiederhergestellt werden.
        state := BUSY;
        
        // Der Workstate des aufgerufenen Interpreters muß wieder auf BUSY gestellt 
        // werden, damit man sein Ende mitbekommt.
        pOtherIpr := IprMgr::GetInterpreter(m_uiCalledIpr);
        pOtherHead := pOtherIpr^.GetHead();
        pOtherHead^.WorkState := BUSY;
        
      END_IF;
		END_IF;

	I_INC:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

     #ifndef _LSL_USECLISTI
      //CriticalLoaderSectionStart();
			WR(pRead^$pSvrCh, RD(pRead^$pSvrCh)+1);
      //CriticalLoaderSectionStop();
     #else
			CLI();
			WR(pRead^$pSvrCh, RD(pRead^$pSvrCh)+1);
			STI();
     #endif
		END_IF;

	I_DEC:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

     #ifndef _LSL_USECLISTI
      //CriticalLoaderSectionStart();
			WR(pRead^$pSvrCh, RD(pRead^$pSvrCh)-1);
      //CriticalLoaderSectionStop();
     #else
			CLI();
			WR(pRead^$pSvrCh, RD(pRead^$pSvrCh)-1);
			STI();
     #endif
		END_IF;

	// ignore this line
	// 
	I_COMMENT:

	I_ENDFUNCTION:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;


			IF m_bSoftExchange = TRUE & m_uiSubLevels = 0 THEN
				_m.head.funkst := ERROR;
				CheckForLoad();				
			END_IF;

			IF PopSubStack() = FALSE THEN
				GOTO SET_ERROR;
			END_IF;
      
      IF _m.head.pCode^.opCode = I_RUNPROG THEN
        // In die Funktion wurde nicht durch einen normalen Unterprogrammaufruf 
        // verwzeigt, sondern ein I_RUNPROG Aufruf wurde durch einen I_RUNPROG Aufruf 
        // eines anderen Interpreters unterbrochen.
        // In so einem Fall muß der funkSt BUSY wiederhergestellt werden.
        state := BUSY;
        
        // Der Workstate des aufgerufenen Interpreters muß wieder auf BUSY gestellt 
        // werden, damit man sein Ende mitbekommt.
        pOtherIpr := IprMgr::GetInterpreter(m_uiCalledIpr);
        pOtherHead := pOtherIpr^.GetHead();
        pOtherHead^.WorkState := BUSY;
        
      END_IF;
		END_IF;

	//--------------------------------------------------------------------
	// <_NOP>
	//--------------------------------------------------------------------
	I_NOP,

	//--------------------------------------------------------------------
	// <LBL> ,<uiLabelNo>
	//--------------------------------------------------------------------
	I_LBL,I_FUNCTION:

	//--------------------------------------------------------------------
	// test if there is something to load into the programs
	//--------------------------------------------------------------------
	// should be put into the automatic cycle

	I_CHECK_FOR_LOAD:
		_m.head.funkst		:= BUSY;

		//Zeit merken die vergangen ist seit dem letzten Checkforload
		m_udCFLCycle := ops.tAbsolute - m_udLastCFL;
		m_udLastCFL := ops.tAbsolute;

		CheckForLoad();

		_m.resu.uiLng	:= SEND_STATE_ONLY;

	ELSE
  		state := BaseIp::BefIpr(bSetNext);
  		IF state = ERROR THEN
SET_ERROR:
			state  := ERROR;
   			_m.resu.uiLng := SEND_STATE_ONLY;
  		END_IF;
 	END_CASE;

END_FUNCTION
// Copy an interpreter program from temporary memory into
// the working memory, and mark it as active.
//
FUNCTION GLOBAL ProgIp::LoadProgFromTemp
	VAR_INPUT
		nProgNo 	: UDINT;
		bCheck 	: BOOL;
		bDoNotLink 	: BOOL;
    bBTnoRun    : BOOL; // := FALSE;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
VAR
	j			: UDINT;
	pProg		: pSubPrgHead;
	pSeq		: ^ProgIp;
	bReset 		: BOOL;
	udCheck		: UDINT;
END_VAR

	ret_code := C_SYNTAX_ERROR;
  
	// number of temporary program
	j := nProgNo + MAX_IP_PROGS;

	pProg := ProgMgr::GetProgram(j);
	// Try to link immediatly after download to enable
	// the downloading application to display the error message.
	IF bCheck THEN
		IF pProg^.udCRC <> ProgMgr::GetProgramChkSum(pProg) THEN
			RETURN;
		END_IF;
		IF ProgMgr::LinkVarias(j) = FALSE THEN
			SetLoadBit(nProgNo);	// .. and invalidate ProgSize
			RETURN;
		END_IF;
		pProg^.udCRC := ProgMgr::GetProgramChkSum(pProg); // .. set new checksum with linked variables
	END_IF;

	CASE _m.head.FunkSt OF
	READY,BUSY,ERROR_BUSY:				// .. set active later
		SetLoadBit(nProgNo);			// .. and invalidate ProgSize

	ELSE								// .. set immediatly active

		pSeq := IprMgr::GetInterpreter(nProgNo);
		IF m_loadState = LS_WAIT THEN
			bReset := TRUE;
		ELSE
			bReset := FALSE;
		END_IF;

		udCheck := pSeq^.GetFileCheck();

		// copy IP-code from temporary to working memory
		IF ProgMgr::ProgLoad(pProg, j,	nProgNo, bDoNotLink, bBTnoRun) THEN

			ProgMgr::AllocProg(MIN_PROG_SIZE, j);	// erase temporary code

			ClearLoadBit(nProgNo);			// now clear the bit of load
			IF bReset = TRUE THEN
				pSeq := IprMgr::GetInterpreter(nProgNo);
				pSeq^.SetLoaded();
			END_IF;

			pSeq^.SetFileCheck(udCheck);

			_m.head.funkSt := ERROR;
		END_IF;

	END_CASE;

	ret_code := C_OK;
  
END_FUNCTION

FUNCTION GLOBAL ProgIp::GetCodeOfs
VAR_OUTPUT
  ofs : UDINT;
END_VAR
  ofs := _m.head.pCode$UDINT - (#m_pPrgHead^.subProgHead + m_pPrgHead^.subProgHead.udOffCode)$UDINT;
END_FUNCTION

//Setzt den Codepointer auf den neuen Offset
FUNCTION GLOBAL ProgIp::SetCodePointer
VAR_INPUT
	udCodeOffset	: UDINT;
END_VAR
VAR
	i				: UINT;
	//dOffset			: UDINT;
	IprBp			: IprBreakpoint;
	dCodeOffset		: UDINT;
  cbData : LDR_IpChanged_Data;
  oldPCode : pVoid;
END_VAR
	
  oldPCode := _m.head.pCode;
	BaseIp::SetCodePointer(udCodeOffset);

  // prüfen, ob die Callback Funktion aufgerufen werden muß, wenn sich der 
  // Instruction Pointer geändert hat
  IF pIprCbFunc <> NIL & oldPCode <> _m.head.pCode THEN
    cbData.sizeOfStruct := SIZEOF(cbData);
    cbData.ofs := _m.head.pCode$UDINT - (#m_pPrgHead^.subProgHead + m_pPrgHead^.subProgHead.udOffCode)$UDINT;
    cbData.prgNbr := GetInterpreterNumber();
    cbData.pp := this;
    ESI := pIprCbThis; // nach einem Funktionsaufruf wird ESI automatisch wiederhergestellt 
                       // (der Compiler generiert den Code dafür)
    pIprCbFunc$IprCallback(IPRCB_IPCHANGED, #cbData);
  END_IF;    

	IF _m.head.pCode$UDINT = m_dTriggerOffset THEN
		m_dTriggerCnt += 1;
	END_IF;

	IF (m_uiBpCnt = 0) & (m_udSinglestepBp = 0xFFFFFFFF) THEN
		RETURN;
	END_IF;

	//Singlestep Breakpoints überprüfen
	IF m_udSinglestepBp = _m.head.pCode$UDINT THEN
		DeleteSSBreakpoint(_m.head.pCode$UDINT);
		_m.head.funkSt := SINGLESTEP;
		RETURN;
	END_IF;

	//von Benutzer gesetzte Breakpoints überprüfen
	IF m_uiBpCnt <> 0 THEN
		//Offset des Codebeginns suchen
		dCodeOffset := (#m_pPrgHead^.subProgHead)$UDINT + m_pPrgHead^.subProgHead.udOffCode;
		FOR i:=0 TO m_uiBpCnt-1 DO
			//Relativen Offset des Breakpoints auslesen
			m_Breakpoints.GetDataAt(#(IprBp.dOffset$USINT), sizeof(IprBreakpoint), i*sizeof(IprBreakpoint));
			IprBp.dOffset += dCodeOffset;//Offset absolut machen
			IF _m.head.pCode$UDINT = IprBp.dOffset THEN//und mit dem aktuellen Offset vergleichen
				_m.head.funkst := STOP_BP;
				RETURN;
			END_IF;
		END_FOR;
	END_IF;

END_FUNCTION
//Entfernt alle Breakpoints aus dem Speicher
FUNCTION GLOBAL ProgIp::RemoveAllBreakpoints
	m_uiBpCnt := 0;
	IF IsClientConnected(#m_Breakpoints$DINT) THEN
		m_Breakpoints.SetSize(0);
	END_IF;
END_FUNCTION
FUNCTION GLOBAL VIRTUAL ProgIp::Init

	IF _firstscan THEN
		//Breakpointanzahl aus der Grösse auslesen
		RemoveAllBreakpoints();
	END_IF;

END_FUNCTION
// Prüft, ob der Instruction-Pointer hinter dem Code-Ende steht
FUNCTION GLOBAL ProgIp::EndOfCode
VAR_OUTPUT
	bEOC		: BOOL;
END_VAR

	IF (_m.head.pCode$UDINT - (#m_pPrgHead^.subProgHead)$UDINT)$DINT >= 
		m_pPrgHead^.subProgHead.udLng$DINT THEN
		bEOC	:= TRUE;
	ELSE
		bEOC	:= FALSE;
	END_IF;

END_FUNCTION
// Zeiger auf den Interpreter-Code setzen
FUNCTION GLOBAL ProgIp::SetPrgHead
VAR_INPUT
	pPrgHead	: ^NewSubPrgHead;
END_VAR

	m_pPrgHead	:= pPrgHead;

END_FUNCTION

// Executes commands, sent by the debugging tool
FUNCTION ProgIp::pCmd::NewInst
VAR_INPUT
	pPara		: ^CmdStruct;
	pResult		: ^results;
END_VAR
VAR_OUTPUT
	ret_code	: iprStates;
END_VAR
VAR
	udCodeOffset	: UDINT;
	bBpCheck		: BOOL;
	pSubProg		: ^SubPrgHead;
	IprBp			: IprBreakpoint;
END_VAR

	CASE pPara^.uiCmd $ DebugIp::CmdIpr OF 
	//setzt den Triggeroffset eines Interpreters
	//aPara[0] : Programmnummer
	//aPara[1] : Offset auf den der Trigger gesetzt wird
	DebugIp::SET_TRIGGER:
		pSubProg 	:= ProgMgr::GetProgram(TO_UINT(pPara^.aPara[0]$BYTE));
		m_dTriggerCnt := 0;	
		m_dTriggerOffset := pPara^.aPara[1]$UDINT + (pSubProg$UDINT + pSubProg^.udOffCode);

	//liefert den Status des Programmnachladens
	DebugIp::GET_LOAD_STATE:
		pResult^.uiLng := sizeof(UDINT) + 2;
		pResult^.aData[0]$LOAD_STATE := m_loadState;

	//Setzt/Löscht einen Breakpoint im Interpreter
	//aPara[0] : Programmnummer
	//aPara[1] : Offset
	//aPara[2] : Checksumme des Interpreters
	//aPara[3] : 0 .. Bp löschen 	1 .. Bp setzten
	DebugIp::SET_BREAKPOINT:
		
		IprBp.dOffset := pPara^.aPara[1]$UDINT;
		IprBp.dIprCRC := pPara^.aPara[2]$UDINT;
		//udCodeOffset := pPara^.aPara[1]$UDINT;

		IF pPara^.aPara[3] = 0 THEN
			bBpCheck := DeleteBreakpoint(IprBp.dOffset);
		ELSE
			bBpCheck := SetBreakpoint(IprBp.dOffset);
		END_IF;
		pResult^.uiLng := 3;
		pResult^.aData[0] := bBpCheck;
		g_LoadTimeout += 200;

	//Führt die nächste Anweisung des Interpreters aus
	DebugIp::CMD_SINGLESTEP:
		MakeSingleStep();

	//Startet den Interpreter
	DebugIp::CMD_RUN_IPR:
		RunInterpreter();

	//Setzt den Codepointer auf einen Offset
	DebugIp::SET_CODE_POINTER:
		pSubProg 	:= ProgMgr::GetProgram(TO_UINT(pPara^.aPara[0]$BYTE));
		udCodeOffset := pPara^.aPara[1]$UDINT + (pSubProg$UDINT + pSubProg^.udOffCode);
		SetCodePointer(udCodeOffset);

	//liefert den FunkStatus des Interpreters
	DebugIp::GET_FUNK_STATE:
		pResult^.uiLng := 6;
		pResult^.aData[0]$iprStates := _m.head.funkSt;

	//führt einen StepOver aus
	DebugIp::CMD_STEPOVER:
		StepOver();

	//Springt aus der aktuellen Funktion heraus
	DebugIp::CMD_STEPOUT:
		StepOut();

	//Stopt den Interpreter
	DebugIp::CMD_HOLD:
		Hold();

	END_CASE;

	ret_code := READY;

END_FUNCTION
FUNCTION ProgIp::DebugInst
VAR_INPUT
	pCode		: ^Instruct;
	pResu		: ^Results;
END_VAR
VAR
	pRead			: ^void;
	pResData		: ^UDINT;
	SaveState		: IprStates;
	udCheck			: UDINT;
	pSubProg		: ^SubPrgHead;
  uiCnt       : UINT;
  pCodeStack  : ^INSTRUCT;
END_VAR

	pResData	:= #pResu^.aData[0]$UDINT;
	pRead		:= #pCode^.aPara[0];

	CASE pCode^.opCode OF
	// Liefert die Nummer des Interpreters der von diesem Ipr aufgerufen wurde
	I_GET_CALLED_IPR:		
		pResData^ := m_uiCalledIpr;
		pResu^.uiLng	:= 4; 

	// Bringt die Nummer des Iprs von dem dieser Ipr aufgerufen wurde
	I_GET_CALLED_FROM:
		pResData^ := m_uiCalledFrom;
		pResu^.uiLng	:= 4; 

	//--------------------------------------------------------------------
	// Beendet den Softload Modus
	// > 2Byte Programmnummer
	//--------------------------------------------------------------------
	I_END_SOFTLOAD_IPR:
		m_bCFLExchange := FALSE;
		m_bSoftExchange := FALSE;
		m_loadState := LS_NONE;

	//--------------------------------------------------------------------
	// > 2Byte Programmnummer
	// > 1Byte Modus  	0 .. CheckForLoad
	//					1 .. Label Exchange
	//--------------------------------------------------------------------
	I_TRY_SOFTLOAD_IPR:
		pRead += 2;
		CASE pRead^$USINT OF
		0:
			m_bCFLExchange := TRUE;
			m_bSoftExchange := FALSE;
		1:
			m_bCFLExchange := FALSE;
			m_bSoftExchange := TRUE;
		END_CASE;
		m_loadState := LS_WAIT;

	//--------------------------------------------------------------------
	// Set a Interpreter to ERROR state and
	// load it into the memory
	//--------------------------------------------------------------------
	I_STOP_IPR_CHECK_FOR_LOAD:
		SaveState := _m.head.funkSt;
		udCheck := m_pPrgHead^.subProgHead.udCRCHead;
		_m.head.funkSt := ERROR;

		// Now try to load the interpreter to the working memory
		CheckForLoad();

		this := IprMgr::GetInterpreter(pRead^$CHAR);

		IF SaveState = READY | 
			SaveState = BUSY THEN
			IprMgr::StartInterpreter(pRead^$UINT, udCheck <> m_pPrgHead^.subProgHead.udCRCHead);
		END_IF;

	//--------------------------------------------------------------------
	// Start an interpreter from ERROR state
	//--------------------------------------------------------------------
  (*** ++pr:test *** 
	I_START_IPR:
		IF _m.head.funkSt = ERROR THEN
      udCheck := m_pPrgHead^.subProgHead.udCRCHead;
      _m.head.funkSt := ERROR;
  
      // Now try to load the interpreter to the working memory
      CheckForLoad();
  
      this := IprMgr::GetInterpreter(pRead^$CHAR);
  
      IprMgr::StartInterpreter(pRead^$UINT, udCheck <> m_pPrgHead^.subProgHead.udCRCHead);
    END_IF;
   *** ++pr:test ***)

	//--------------------------------------------------------------------
	// <I_GET_TRIGGER_COUNT>
	//--------------------------------------------------------------------
	I_GET_TRIGGER_COUNT:
		pResData^	:= m_dTriggerCnt;
		pResu^.uiLng	:= sizeof(ProgIp::m_dTriggerCnt)+2;

	//--------------------------------------------------------------------
	// <I_GET_ACT_OFFSET>
	//--------------------------------------------------------------------
	I_GET_ACT_OFFSET:
		pSubProg 	:= ProgMgr::GetProgram(pRead^$CHAR);

		pResData^	:= _m.head.pCode$UDINT - (pSubProg$UDINT + pSubProg^.udOffCode);
		pResu^.uiLng	:= sizeof(UDINT)+2;

	//--------------------------------------------------------------------
	// <I_GET_STACKINFO>
  // Return:
  //    2Byte subLevels (=Anzahl Stackframes)
  //  Die folgende Struktur ist #subLevels mal vorhanden:
  //    4Byte codeOffset
  //    2Byte lineNr
  //    2Byte calledFrom
  //    2Byte calledIpr
	//--------------------------------------------------------------------
  I_GET_STACKINFO:
		pSubProg 	:= ProgMgr::GetProgram(pRead^$CHAR);

		pResData^$UINT := m_uiSubLevels;
		pResu^.uiLng	:= SIZEOF(m_uiSubLevels)+2;
    pResData += SIZEOF(m_uiSubLevels);
    uiCnt := 0;
    WHILE uiCnt < m_uiSubLevels DO
      pCodeStack := (m_subStack[uiCnt].pCall + (#m_pPrgHead^.subProgHead)$hdint)$^instruct;
      pResData^ := pCodeStack$UDINT - (pSubProg$UDINT + pSubProg^.udOffCode);
      pResData     += SIZEOF(UDINT);
      pResu^.uiLng += SIZEOF(UDINT);
      pResData^$UINT := m_subStack[uiCnt].uiLineNr;
      pResData     += SIZEOF(UINT);
      pResu^.uiLng += SIZEOF(UINT);
      pResData^$UINT := m_subStack[uiCnt].uiCalledFrom;
      pResData     += SIZEOF(UINT);
      pResu^.uiLng += SIZEOF(UINT);
      pResData^$UINT := m_subStack[uiCnt].uiCalledIpr;
      pResData     += SIZEOF(UINT);
      pResu^.uiLng += SIZEOF(UINT);
      
      uiCnt += 1;
    END_WHILE;
  
	// -------------------------------------------------------------------..
	//  get back the status of a program
	// <I_GETPROGSTATE> ,<Prognr>
	// para[0]	<ProgNo>	1 byte
	// -------------------------------------------------------------------

	I_GETPROGSTATE:

		(pResData+0)^$IprStates	:= _m.head.FunkSt;
		(pResData+2)^$UINT		:= uiActLine;
		pResu^.uiLng				:= 6;		// len(2)+state(2)+line(2)

	END_CASE;

END_FUNCTION
FUNCTION ProgIp::GetCFLCycle
VAR_OUTPUT
	udCycle		: UDINT;
END_VAR

	udCycle	:= m_udCFLCycle;

END_FUNCTION
FUNCTION ProgIp::GetCalledIpr
VAR_OUTPUT
	uiIpr		: UINT;
END_VAR

	uiIpr	:= m_uiCalledIpr;

END_FUNCTION
FUNCTION ProgIp::SetLoaded

	m_bCFLExchange := FALSE;
	m_bSoftExchange := FALSE;
	m_loadState := LS_LOADED;

END_FUNCTION
FUNCTION GLOBAL ProgIp::SetFileCheck
VAR_INPUT
	udFileCheck : UDINT;
END_VAR

	IF m_pPrgHead <> NIL THEN
		m_pPrgHead^.udFileCheck := udFileCheck;
	END_IF;

END_FUNCTION

FUNCTION GLOBAL ProgIp::GetFileCheck
VAR_OUTPUT
	udFileCheck : UDINT;
END_VAR

	IF m_pPrgHead = NIL THEN
		udFileCheck := 0;
	ELSE
		udFileCheck := m_pPrgHead^.udFileCheck;
	END_IF;

END_FUNCTION

FUNCTION GLOBAL ProgIp::GetMaxProgSeqDuration_ms
VAR_OUTPUT
  maxProgSeqDuration_ms : UDINT;
END_VAR

  maxProgSeqDuration_ms := m_maxProgSeqDuration_ms;

END_FUNCTION

FUNCTION GLOBAL ProgIp::SetMaxProgSeqDuration_ms
VAR_INPUT
  maxProgSeqDuration_ms : UDINT;
END_VAR

  m_maxProgSeqDuration_ms := maxProgSeqDuration_ms;

END_FUNCTION

FUNCTION GLOBAL ProgIp::SetMaxNbrIprCmds
VAR_INPUT
  maxNbrIprCmds : UDINT;
END_VAR

  m_maxNbrIprCmds := maxNbrIprCmds;

END_FUNCTION

FUNCTION GLOBAL ProgIp_GetHead
VAR_INPUT
  pp 	: ^ProgIp;
END_VAR
VAR_OUTPUT
  pHead 	: ^iprHead;
END_VAR
  pHead := pp^.GetHead();
END_FUNCTION

FUNCTION GLOBAL ProgIp_GetActLine
VAR_INPUT
  pp 	: ^ProgIp;
END_VAR
VAR_OUTPUT
  uiActLine	: UINT;
END_VAR
  uiActLine := pp^.uiActLine;
END_FUNCTION

FUNCTION GLOBAL ProgIp_DeleteBreakpoint
VAR_INPUT
  pp 	: ^ProgIp;
  dOffset 	: UDINT;
END_VAR
VAR_OUTPUT
  bBpValid 	: BOOL;
END_VAR
  bBpValid := pp^.DeleteBreakpoint(dOffset);
END_FUNCTION

FUNCTION GLOBAL ProgIp_StartProgram
VAR_INPUT
  pp 	: ^ProgIp;
  uiPrgNo 	: UINT;
  uiLabelNo 	: UINT;
END_VAR
VAR_OUTPUT
  state 	: iprStates;
END_VAR
  state := pp^.StartProgram(uiPrgNo, uiLabelNo);
END_FUNCTION
	
FUNCTION GLOBAL ProgIp_StartProgramOfs
VAR_INPUT
  pp 	: ^ProgIp;
  uiPrgNo 	: UINT;
  offset : UDINT;
END_VAR
VAR_OUTPUT
  state 	: iprStates;
END_VAR
  state := pp^.StartProgramOfs(uiPrgNo, offset);
END_FUNCTION
	
FUNCTION GLOBAL ProgIp_StopProgram
VAR_INPUT
  pp 	: ^ProgIp;
  uiProgNo 	: UINT;
END_VAR
VAR_OUTPUT
  state 	: iprStates;
END_VAR
  state := pp^.StopProgram(uiProgNo);
END_FUNCTION
	
FUNCTION GLOBAL ProgIp_RunProgram
VAR_INPUT
  pp 	: ^ProgIp;
  uiProgNo 	: UINT;
  uiLabelNo 	: UINT;
END_VAR
VAR_OUTPUT
  state 	: iprStates;
END_VAR
  state := pp^.RunProgram(uiProgNo, uiLabelNo);
END_FUNCTION

FUNCTION GLOBAL ProgIp_SetBreakpoint
VAR_INPUT
  pp 	: ^ProgIp;
  dOffset 	: UDINT;
END_VAR
VAR_OUTPUT
  bBpValid 	: BOOL;
END_VAR
  bBpValid := pp^.SetBreakpoint(dOffset);
END_FUNCTION

FUNCTION GLOBAL ProgIp_MakeSingleStep
VAR_INPUT
  pp 	: ^ProgIp;
END_VAR
  pp^.MakeSingleStep();
END_FUNCTION
  
FUNCTION GLOBAL ProgIp_SetCodePointer
VAR_INPUT
  pp 	: ^ProgIp;
  udCodeOffset 	: UDINT;
END_VAR
  pp^.SetCodePointer(udCodeOffset);
END_FUNCTION

FUNCTION GLOBAL ProgIp_InitVariables
VAR_INPUT
  pp 	: ^ProgIp;
END_VAR
  pp^.InitVariables();
END_FUNCTION
  
FUNCTION GLOBAL ProgIp_SetPrgHead
VAR_INPUT
  pp 	: ^ProgIp;
  pPrgHead 	: ^NewSubPrgHead;
END_VAR
  pp^.m_pPrgHead := pPrgHead;
END_FUNCTION

FUNCTION GLOBAL ProgIp_SetNextInstructionLabelNo
VAR_INPUT
  pp 	: ^ProgIp;
  nLabel 	: UINT;
END_VAR
VAR_OUTPUT
  ret_code 	: UINT;
END_VAR
  ret_code := pp^.SetNextInstructionLabelNo(nLabel);
END_FUNCTION

FUNCTION GLOBAL ProgIp_SetNextInstruction
VAR_INPUT
  pp 	: ^ProgIp;
END_VAR
  pp^.SetNextInstruction();
END_FUNCTION

FUNCTION GLOBAL ProgIp_SetInstructionToProgStart
VAR_INPUT
  pp 	: ^ProgIp;
	nLabel		: UINT;
END_VAR
VAR_OUTPUT
	ret_code	: IPRSTATES;
END_VAR
  ret_code := pp^.SetInstructionToProgStart(nLabel);
END_FUNCTION

FUNCTION GLOBAL ProgIp_SetMaxProgSeqDuration_ms
VAR_INPUT
  pp 	: ^ProgIp;
  maxProgSeqDuration_ms : UDINT;
END_VAR
  pp^.SetMaxProgSeqDuration_ms(maxProgSeqDuration_ms);
END_FUNCTION

FUNCTION GLOBAL ProgIp_SetMaxNbrIprCmds
VAR_INPUT
  pp 	: ^ProgIp;
  maxNbrIprCmds : UDINT;
END_VAR
  pp^.SetMaxNbrIprCmds(maxNbrIprCmds);
END_FUNCTION

FUNCTION GLOBAL ProgIp_InstallIprCallback
VAR_INPUT
  pThis : pVoid;
  pFunc : pVoid;
END_VAR
  pIprCbThis := pThis;
  pIprCbFunc := pFunc;
END_FUNCTION

FUNCTION GLOBAL ProgIp_GetProgsToLoad
	VAR_INPUT
		pBitmask 	: ^pVoid;
	END_VAR
	VAR_OUTPUT
		usLen 	: USINT;
	END_VAR

  pBitmask^ := #uiProgsToLoad[ 0 ];
  usLen := sizeof( uiProgsToLoad );

END_FUNCTION

FUNCTION GLOBAL ProgIp_GetSubStack
VAR_INPUT
  pp 	: ^ProgIp;
  pNoOfSubLevels : ^UINT;
END_VAR
VAR_OUTPUT
  pSubStack 	: ^StackInfo;
END_VAR
  pSubStack$^ProgIp::StackInfo := pp^.GetSubStack(pNoOfSubLevels);
END_FUNCTION

FUNCTION GLOBAL ProgIp::HandleError
VAR
  cbData : LDR_Error_Data;
END_VAR

  IF GetLastError() = PROGIP_NO_ERROR THEN
    SetLastError(PROGIP_ERR_GENERAL);
  END_IF;

  IF pIprCbFunc <> NIL THEN
    cbData.sizeOfStruct := SIZEOF(cbData);
    cbData.errorCode := GetLastError();
    cbData.prgNbr := GetInterpreterNumber();
    cbData.pp := this;
    ESI := pIprCbThis; // nach einem Funktionsaufruf wird ESI automatisch wiederhergestellt 
                       // (der Compiler generiert den Code dafür)
    pIprCbFunc$IprCallback(IPRCB_ERROR, #cbData);
  END_IF;    

  SetLastError(PROGIP_NO_ERROR);

END_FUNCTION

FUNCTION GLOBAL ProgIp::GetSubStack
	VAR_INPUT
		pNoOfSubLevels 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		pSubStack 	: ^StackInfo;
	END_VAR

  if (pNoOfSubLevels <> NIL) then
    //set number of sublevels
    pNoOfSubLevels^ := m_uiSubLevels;
    //get pointer on subcallstack
    pSubStack := #m_subStack[0];
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL ProgIp::GetMaxNbrIprCmds
	VAR_OUTPUT
		maxNbrIprCmds 	: UDINT;
	END_VAR

  maxNbrIprCmds := m_maxNbrIprCmds;

END_FUNCTION
