//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "PtrChk"
	Revision           = "0.0"
	GUID               = "{F5DCFDFC-D03E-4D6E-AF33-78D388A84DC2}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
	</Channels>
</Class>
*)
PtrChk : CLASS
	TYPE
	  PtrXch : STRUCT
	    pMeth : ^void;
	    pPtr : ^pVoid;
	  END_STRUCT;
	END_TYPE
  //Servers:
  //Clients:
  //Variables:
		m_pStartModule 	: ^void;
		m_pEndModule 	: ^void;
		m_udPointers 	: UDINT;
		m_pPointers 	: ^PtrXch;
		m_bCorrect 	: BOOL;
  //Functions:
	
	FUNCTION GLOBAL InitPtr
		VAR_INPUT
			udStartModule 	: UDINT;
			udEndModule 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL CheckPtr
		VAR_INPUT
			pChMeth 	: ^pVoid;
		END_VAR;
	
	FUNCTION GLOBAL IsOk
		VAR_OUTPUT
			bOk 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Delete;
	
	FUNCTION AWL GLOBAL Apply;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB PtrChk::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_PTRCHK
0$UINT, 0$UINT, (SIZEOF(::PtrChk))$UINT, 
0$UINT, 0$UINT, 0$UINT, 
TO_UDINT(3131664890), "PtrChk", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
END_FUNCTION


#define USER_CNT_PtrChk 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_PtrChk] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION PtrChk::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include "RTOS_MemIntern.h"
#include <LSL_St_IfLinker.h>

//[#ENGLISH]
//This function works like a constructor. It initializes the data 
//elements of a PtrChk-object.
FUNCTION GLOBAL PtrChk::InitPtr
	VAR_INPUT
		udStartModule 	: UDINT;
		udEndModule 	: UDINT;
	END_VAR

	m_pStartModule	:= udStartModule$^void;
	m_pEndModule	:= udEndModule$^void;

	m_udPointers	:= 0;
	m_pPointers		:= _alloc(sizeof(PtrXch))$^PtrXch;

	m_bCorrect		:= TRUE;

END_FUNCTION
//[#ENGLISH]
//Checks if a pointer is within a given range (static variables).
//Stores such pointers to a pointer-buffer.
//[>pMeth]pointer to a method
//[>pChMeth]pointer to the method list entry
FUNCTION GLOBAL PtrChk::CheckPtr
	VAR_INPUT
		pChMeth 	: ^pVoid;
	END_VAR
VAR
	pMeth		: ^void;
	pXch		: ^PtrXch;
END_VAR

	pMeth	:= pChMeth^;

	IF pMeth >= m_pStartModule & pMeth < m_pEndModule THEN
		m_udPointers	+= 1;
		m_pPointers		:= _realloc_LDR(m_pPointers, m_udPointers * sizeof(PtrXch))$^PtrXch;
		IF m_pPointers THEN
			pXch	:= m_pPointers + (m_udPointers-1) * sizeof(PtrXch);
//			#ifdef ONLINE_DOWNLOAD
			// the OS must deliver the pointer to the method in 
			// the new module, it gets the pointer to the method
			// in the old module
			pXch^.pMeth	:= OS_LNK_XCH_PTRS(pMeth);
//			#else
//			pXch^.pMeth	:= pMeth;		// just a test
//			#endif
			pXch^.pPtr	:= pChMeth;
		ELSE
			m_udPointers	:= 0;		// init for next allocation
			m_pPointers		:= NIL;
			m_bCorrect		:= FALSE;	// results are invalid
		END_IF;
	END_IF;

END_FUNCTION
//[#ENGLISH]
//Returns if all the allocations were correct, and if the module
//can be exchanged later.
FUNCTION GLOBAL PtrChk::IsOk
	VAR_OUTPUT
		bOk 	: BOOL;
	END_VAR

	bOk	:= m_bCorrect;

END_FUNCTION
//[#ENGLISH]
//Destructor of the PtrChk-class. It frees the internal pointer buffer
//and the object itself.
FUNCTION GLOBAL PtrChk::Delete

	IF m_pPointers THEN
		_free(m_pPointers);
	END_IF;

	_free(this);

END_FUNCTION
//[#ENGLISH]
//This function exchanges all the previously calculated method pointers.

#ifdef _LSL_TARGETARCH_ARM
FUNCTION GLOBAL PtrChk::Apply
var 
  pFunct : ^udint;
  pMeth : ^udint;
  anz : udint;
  ptr : ^PtrXch;
end_var 

  anz := m_udPointers;
  ptr := m_pPointers;
  
  while(anz > 0) do 
    pFunct := ptr^.pMeth$^udint; // load new function pointer
    pMeth  := ptr^.pPtr$^udint;  // load address of meth table entry
    pMeth^ := pFunct$udint;       // update meth table
    ptr += sizeof(PtrXch);        // point to next pair
    anz -= 1;
  end_while;
  
END_FUNCTION
#else
FUNCTION AWL GLOBAL PtrChk::Apply

		L.ECX		m_udPointers		// check if there are function 
		JECXZ		ENDE				// pointers to exchange

		L.EDI		m_pPointers			// load start of list

LOOP
		L.EAX		(EDI + PtrXch.pMeth)// load new function pointer
		L.EDX		(EDI + PtrXch.pPtr)	// load address of meth table entry
		S.EAX		(EDX)				// update meth table

		ADD.EDI		sizeof(PtrXch)		// point to next pair
		DEC			ECX
		JNZ			LOOP				// loop counter > 0

ENDE
END_FUNCTION
#endif
