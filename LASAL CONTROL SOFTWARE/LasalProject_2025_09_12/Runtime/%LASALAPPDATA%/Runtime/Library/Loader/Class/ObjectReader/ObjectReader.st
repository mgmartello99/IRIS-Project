//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

TYPE
	L2_ClsInfo	: STRUCT
		pCls	: ^ClsHdr;		// Zeiger auf die allg. Klassenbeschreibung
		pOld	: ^Obj;			// Zeiger auf das letzte Objekt/Klasse vor diesem ON
		nObj	: UINT;			// Anzahl der Objekte pro Klasse
	END_STRUCT;
END_TYPE
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "ObjectReader"
	Revision           = "0.1"
	GUID               = "{18591AA0-7AC2-4689-9DFB-36A58A9C006D}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Server0" GUID="NULL" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FimLuc"/>
		<Dokumentation Revision="0.1" Date="2015-10-07" Author="FimLuc" Company="Sigmatek" Description="MMConnectionReader und Prüfung auf Table-End eingefügt"/>
	</RevDoku>
</Class>
*)
ObjectReader : CLASS
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		pTable 	: ^void;			//! <Variable Comment="Zeiger auf die Konfigurationstabelle" Name="pTable"/>
		pON 	: ^void;			//! <Variable Comment="Zeiger auf Objekte des ON" Name="pON"/>
		pNxtObj 	: ^Obj;			//! <Variable Comment="Zeiger auf den nächsten freien Speicher in pON" Name="pNxtObj"/>
		pClsList 	: ^L2_ClsInfo;			//! <Variable Comment="Liste mit den Klassen, die in dem ON verwendet werden" Name="pClsList"/>
		nClasses 	: UDINT;			//! <Variable Comment="Anzahl der verwendeten Klassen" Name="nClasses"/>
		pObjON 	: ^pVirtualBase;			//! <Variable Comment="Liste mit Zeigern auf die Objekte in diesem ON" Name="pObjON"/>
		nObjs 	: UDINT;			//! <Variable Comment="Anzahl der Objekte in diesem ON" Name="nObjs"/>
		nSize 	: UDINT;			//! <Variable Comment="Größe aller Objekte in einem ON" Name="nSize"/>
		pInit 	: ^void;
		pTableEnd 	: ^void;
  //Functions:
	
	FUNCTION GLOBAL CreateON
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetUsedClasses
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION ReadObjects
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION CallConstructors
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION ReadObject
		VAR_INPUT
			pCls 	: ^ClsHdr;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION InitObject
		VAR_INPUT
			pCls 	: ^ClsHdr;
			pObj 	: ^Obj;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION AllocON
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GetCount
		VAR_OUTPUT
			nCnt 	: UDINT;
		END_VAR;
	
	FUNCTION GetChPtr
		VAR_INPUT
			pThis 	: ^VirtualBase;
		END_VAR
		VAR_OUTPUT
			pClt 	: ^CltCh;
		END_VAR;
	
	FUNCTION GetObjectOff
		VAR_OUTPUT
			pThis 	: ^VirtualBase;
		END_VAR;
	
	FUNCTION GetObjectNo
		VAR_OUTPUT
			pThis 	: ^VirtualBase;
		END_VAR;
	
	FUNCTION GetSymbol
		VAR_OUTPUT
			udValue 	: UDINT;
		END_VAR;
	
	FUNCTION InitSvrChs
		VAR_INPUT
			pCls 	: ^ClsHdr;
			pThis 	: ^VirtualBase;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION InitString
		VAR_INPUT
			pObj 	: ^VirtualBaseInit;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL CallConstructor
		VAR_INPUT
			pCls 	: ^ClsHdr;
			pObj 	: ^VirtualBase;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL SetExternConnection
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SetTable
		VAR_INPUT
			pConfig 	: ^void;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL _dtor;
	
	FUNCTION GLOBAL ReadLexem
		VAR_OUTPUT
			pLexem 	: ^CLexem;
		END_VAR;
	
	FUNCTION GLOBAL GetUInt
		VAR_OUTPUT
			uiVal 	: UINT;
		END_VAR;
	
	FUNCTION InitCltChs
		VAR_INPUT
			pCls 	: ^ClsHdr;
			pThis 	: ^VirtualBase;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL NewObj
		VAR_INPUT
			pClsName 	: ^CHAR;
			pObjName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			pNewObj (EAX) 	: ^VirtualBase;
		END_VAR;
	
	FUNCTION GLOBAL UpdClsList;
	
	FUNCTION doRetentiveCheck;
	
	FUNCTION RetentiveSvrChs
		VAR_INPUT
			pCls 	: ^ClsHdr;
			pThis 	: ^VirtualBase;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL RemSvrInit
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION RemSvrInit_Cls
		VAR_INPUT
			pCls 	: ^ClsHdr;
			pObj 	: ^Obj;
			usSwitch 	: USINT;
		END_VAR;
	
	FUNCTION SkipDints
		VAR_INPUT
			nbr 	: UDINT;
		END_VAR;
	
	FUNCTION MakeObject
		VAR_INPUT
			pNxtObj 	: ^Obj;
			pDsc 	: ^ObjDsc;
			pCls 	: ^ClsHdr;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SkipText;
	
	FUNCTION InitAllObjsByPrjcfg
		VAR_INPUT
			f4Byte 	: BOOL;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ObjectReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_OBJECTREADER
0$UINT, 1$UINT, (SIZEOF(::ObjectReader))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(1461090386), "ObjectReader", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::ObjectReader.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
END_FUNCTION


#define USER_CNT_ObjectReader 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ObjectReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ObjectReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

#pragma usingLtd VirtualBaseInit

//{{LSL_IMPLEMENTATION
#pragma using ClassReader

#include "RTOS_PrivHeader.h"
#include "RTOS_mem.h"

#include ".\include\L2_Ipr.h"
#include <LSL_ST_OSFILE.H>

#define ON_VERSION 0$UINT			// ON - Tabellenversion
#define KIND_OF_TABLE	16#FFFF	// Art der Tabelle, in alten Tabellen steht 16#FFxx

#define LDR_SVRTYPE_RETENTIVEFLAG 16#0008$uint
#define LDR_SVRTYPE_RETENTIVEFILE 16#0010$uint
#define LDR_SVRTYPE_EXISTED       16#0020$uint
#define LDR_SVRTYPE_CONSTRCALLED  16#0040$uint

#define LDR_RETENTIVE_NOT_CHECKED   0
#define LDR_RETENTIVE_IMPOSSIBLE    1
#define LDR_RETENTIVE_FILEOK        2
#define LDR_RETENTIVE_SRAMOK        4

#ifdef FAR_OBJECT
VAR_PRIVATE 
  FarPThis : array[0..65500] of ^void;
  FarPBuff : array[0..65500] of ^void;
  FarErOut : array[0..65500] of usint;
  FarIndex : udint;
END_VAR

function global __cdecl InitFarObject
  FarIndex := 0;
  _memset(#FarErOut[0], 0, sizeof(FarErOut));
end_function

function global __cdecl AddFarObject
var_input
  pthis : ^void;
  pbuff : ^void;
end_var

  if(FarIndex <= 65500) then
    FarPThis[FarIndex] := pthis;
    FarPBuff[FarIndex] := pbuff;
    FarIndex += 1;
  end_if;

END_FUNCTION

function global __cdecl ChkFarObject
  var_output
    error_pthis : ^void;
  end_var
  var
  	no  : udint;
    ph  : ^udint;
    chk : udint;
    txt : array[0..255] of char;
  end_var

  error_pthis := NIL;

  no := FarIndex;
  while no > 0 do
    no  -= 1;
    ph  := FarPBuff[no]$^udint;
    chk := (ph^) xor ((ph+4)^) xor ((ph+8)^) xor ((ph+12)^);
 
    if(chk <> 0) then
      error_pthis  := FarPThis[no];
      if(FarErOut[no] = 0) then
        _strcpy(#txt[0], "ERROR: Writeaccess exceeds Memberarea of Object at %m");
        _itoa(error_pthis$udint, #txt[_strlen(#txt[0])]);
        LSLCLI_LoaderTracePrint(#txt[0], 12);
        TRACE(#txt[0]);
        FarErOut[no] := 1;
      end_if;
    end_if;
  end_while;
  
end_function
#endif

#ifdef LDR_RETSVR
FUNCTION GLOBAL GetNbrNotFound
VAR_OUTPUT
  ret0 : udint;
END_VAR;
FUNCTION GLOBAL InitRetainSvrFile
VAR_INPUT
  usProbe 	: DINT;
END_VAR
VAR_OUTPUT
  ok 	: DINT;
END_VAR;
FUNCTION GLOBAL AWL GetVersion_sRam
VAR_OUTPUT
	Version		: UDINT;
END_VAR;
#endif

// Loader:
#pragma using InitReader
#pragma using TaskReader
#pragma using ConnectReader
#pragma using ProjectReader
#pragma using MMConnectionReader
// Gelinkt:
#pragma using VirtualBaseInit


VAR_EXTERNAL
	sbCallInit		: TCallInit;	// call InitFromTable for VBI-objects

#ifdef LDR_RETSVR
  usHasRetentive : usint;
  usCheckRetentive : usint;
  usReportRetentive : usint;
  udSRAMVersion : udint;
#endif
END_VAR



////////////////////////////////////
FUNCTION GLOBAL Find_File
VAR_INPUT
	CRC32		:  UDINT;
	ppRamAdr	: ^void;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR;

FUNCTION GLOBAL Find_FileEx
VAR_INPUT
	CRC32		:  UDINT;
	ppRamAdr	: ^void;
  bDontAdd : BOOL;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR;

FUNCTION GLOBAL AWL Find_sRam
VAR_INPUT
	CRC32		: UDINT;
END_VAR
VAR_OUTPUT
	pRamAdr		: ^XramCell;
END_VAR;

FUNCTION GLOBAL Find_sRamEx
VAR_INPUT
	CRC32		: UDINT;
  bDontAdd : BOOL;
END_VAR
VAR_OUTPUT
	pRamAdr		: ^XramCell;
END_VAR;

// neue funktion für den C-IPC
FUNCTION GLOBAL AWL Find_sRamFile
VAR_INPUT
	CRC32		:  UDINT;
	ppRamAdr	: ^UDINT;
	ppFileAdr	: ^pXFileCell_t;
	uiType		: UDINT;				// 0=RamZelle 1=RamExZelle 	
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR;

FUNCTION GLOBAL AWL Find_sRamFileEx
VAR_INPUT
	CRC32		:  UDINT;
	ppRamAdr	: ^UDINT;
	ppFileAdr	: ^pXFileCell_t;
	uiType		: UDINT;				// 0=RamZelle 1=RamExZelle 	
  bDontAdd  : BOOL;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR;


VAR_EXTERNAL
	aRamHdr			: RAMhdr;
END_VAR

TYPE
  ASYNC_FILE_STATE : STRUCT
    XRamAddr : XRamCell;
    state    : UDINT;
    pDataObj : ^UDINT;
    hRequest : DINT;
    pNext    : ^ASYNC_FILE_STATE;
    wrCnt    : DINT;
  END_STRUCT;
END_TYPE

VAR_PRIVATE
  AsyncState : ASYNC_FILE_STATE;
END_VAR

////////////////////////////////////////




FUNCTION GLOBAL PutCRCintoMap
VAR_INPUT
	CRC		:  UDINT;
	pObj	: ^Obj;
END_VAR;
FUNCTION GLOBAL _LookupChPtr
VAR_INPUT
	pCls		: ^ClsHdr;
	pName		: ^char;
END_VAR
VAR_OUTPUT
	pCh			: ^ChDsc;
END_VAR;
FUNCTION GLOBAL _LookUpObjLex
VAR_INPUT
	pLexem          : ^CLexem;
END_VAR
VAR_OUTPUT
	ret				: ^SvrCh;
END_VAR;
FUNCTION GLOBAL _LookupCls
VAR_INPUT
	pName		: ^char;
END_VAR
VAR_OUTPUT
	pCls		: ^ClsHdr;
END_VAR;

#ifdef LDR_RETSVR
FUNCTION retentiveWrite
  VAR_INPUT
    pSvr : ^SvrCh;
    flags : uint;
  END_VAR
  
  if( flags and LDR_SVRTYPE_RETENTIVEFILE )then
  // der Wert pSvr^.ddata soll ins File rein
    pSvr^.pSvrDsc$^RetSvr^.pSaveObj$^RetSvrFile^.WriteNew( pSvr^.ddata );
  else
  // der Wert pSvr^.ddata soll ins SRAM
    if( udSRAMVersion < 2 )then
      pSvr^.pSvrDsc$^RetSvr^.pSaveObj$^RetSvrRAM^.Data.Write( pSvr^.ddata );
    else
      pSvr^.pSvrDsc$^RetSvr^.pSaveObj$^RetSvrRAM^.WriteNew( pSvr^.ddata );
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL retentiveWriteSplitter
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
var
  pSvr : ^SvrCh;
  flags : uint;
  ddata : dint;
end_var

  pSvr := ESI$^SvrCh;
  
  //ddata sichern
  ddata := pSvr^.ddata;
  
  if( pSvr^.pSvrDsc <> NIL )then
    // zuerst die Original-Write aufrufen
    result := pSvr^.pSvrDsc$^RetSvr^.pMeth $ M_WR_DIRECT( input );
    
    //die Original-Write kann ddata verändern
    if( ddata <> pSvr^.ddata )then
      //in den Flags steht, ob das ins SRAM oder ins File soll
      flags := pSvr^.pSvrDsc$^RetSvr^.flags;
      retentiveWrite( pSvr, flags );
    end_if; 
  else
    result := M_WR_DIRECT( input );
  end_if;

END_FUNCTION
#endif

//    
//[#DEUTSCH]
//Erstellt aus einer Tabelle mit dem neuen Format einen kompletten ON.
//[>pConfTable]Zeiger auf die Konfigurationstabelle
FUNCTION GLOBAL ObjectReader::CreateON
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
VAR
//dummy:array[0..100]of udint;
	InitRd		: InitReader;
	TaskRd		: TaskReader;
	ConRd		  : ConnectReader;
  pExtern : ^void;
  MMReader  : MMConnectionReader;
END_VAR

	ok	:= FALSE;

	// Liste aller verwendeten Klassen in diesem ON auswerten
 #ifndef OTTOSPEED 
	UpdClsList();
 #else
  // wird zusätzlich in schleife von AllocON() gemacht
 #endif

	IF AllocON() = FALSE THEN
		RETURN;
	END_IF;

	IF ReadObjects() = FALSE THEN
		RETURN;
	END_IF;

	IF ConRd.SetInternConnections(this) = FALSE THEN
		RETURN;
	END_IF;

	IF InitRd.SetInitValues(this) = FALSE THEN	// skalare Initwerte des Projekts vorm ctor eintragen
		RETURN;
	END_IF;
  
  IF ConnectReader::InitvalsInPrjcfg() THEN // Falls im prjcfg-File Initwerte eingetragen sind
    IF InitAllObjsByPrjcfg(TRUE) = FALSE THEN // skalare Initwerte des prjcfg-Files vorm ctor eintragen
      RETURN;
    END_IF;
  END_IF;
    
	IF CallConstructors() = FALSE THEN
		RETURN;
	END_IF;

#ifdef LDR_RETSVR
  if( RemSvrInit() = FALSE )then  // nachdem alle Konstruktoren aufgerufen wurden, werden die remanenten Server initialisiert
    return;
  end_if;
#endif 
 
  IF ConnectReader::InitvalsInPrjcfg() THEN // Falls im prjcfg-File Initwerte eingetragen sind
    // Strings initialisieren (muss vor SetInitStrings aufgerufen werden, damit StringRam 
    // einen DataPtr mit dem Wert 0 vorfindet)
    IF InitAllObjsByPrjcfg(FALSE) = FALSE THEN 
      RETURN;
    END_IF;
  END_IF;
    
	IF InitRd.SetInitStrings(this) = FALSE THEN	// muß wegen virtueller Meths nach dem ctor kommen
		RETURN;
	END_IF;

  IF ConnectReader::InitvalsInPrjcfg() THEN // Falls im prjcfg-File Initwerte eingetragen sind
    // Strings initialisieren (muss nach SetInitStrings noch einmal aufgerufen werden, damit Werte, 
    // die in SetInitStrings gesetzt wurden, überschrieben werden können)
    IF InitAllObjsByPrjcfg(FALSE) = FALSE THEN 
      RETURN;
    END_IF;
  END_IF;
    
	IF TaskRd.ReadTasks(this) = FALSE THEN
		RETURN;
	END_IF;
  
  // ab hier muss tabellenende geprüft werden
  IF (pTableEnd <> NIL) THEN
  
    pExtern := pTable;

    IF ((pTable < pTableEnd) & (ConRd.SkipExtConnection(this) <> FALSE)) THEN
    
  #ifdef __LSLLDR_TIMESLOTS__ 
      if ((pTable < pTableEnd) & (TaskRd.ReadTaskSlots(this) = FALSE)) then
        return;
      end_if;
  #endif
   
  #ifdef __LSLLDR_MULTIMASTER__
     if (pTable < pTableEnd) then
        MMReader.ReadConnections(this);
     end_if;
  #endif
  
     if (pTable < pTableEnd) then
        TaskRd.SkipTasks2(this);
     end_if;
  
    END_IF;

    pTable  := pExtern; 
 
  END_IF;

	ok	:= TRUE;

END_FUNCTION //GLOBAL ObjectReader::CreateON


//[#DEUTSCH]
//Erstellt aus dem Anfang der ON - Tabelle eine Liste mit Verweisen
//auf alle in diesem ON verwendeten Klassen.
FUNCTION GLOBAL ObjectReader::GetUsedClasses
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
VAR
	i			  : UDINT;
	pCls		: ^ClsHdr;
	udRev		: Revision;
	pName		: ^CLexem;
	pInfo		: ^L2_ClsInfo;
END_VAR

	ok	:= TRUE;
  
  IF nClasses = 0 THEN        // Klassenliste des ON ist noch nicht gelesen worden
  
    nClasses	:= pTable^$UDINT;
    pTable	+= sizeof(UDINT);	// Anzahl überlesen
    IF nClasses = 0 THEN
      RETURN;
    END_IF;
    
    pClsList	:= (LDR_alloc_descr(sizeof(L2_ClsInfo) * nClasses)) $ ^L2_ClsInfo;
    pInfo		:= pClsList;
  
    FOR i := 1 TO nClasses DO
      pName	  := pTable $ ^CLexem;
      pTable	+= pName^.Size();	// Klassenname + Abschluß-Nuller überlesen
      udRev	  := pTable^ $ Revision;
      pTable  += sizeof(Revision);		// Revision überlesen
      pCls	  := _LookupClsIdExact(NIL, pName, udRev, 1);
      IF pCls = NIL THEN
        IF ProjectReader::CreateClass(pName, udRev, #pCls) <> C_OK | pCls = NIL THEN
          ok	:= FALSE;
          RETURN;
        END_IF;
      END_IF;
  
      pInfo^.pCls := pCls;
      pInfo^.pOld	:= pCls^.pLastObj;
      pInfo^.nObj	:= GetUInt();	// Anzahl der Objekte dieser Klasse in diesem ON
  
      pInfo		+= sizeof(L2_ClsInfo);
    END_FOR;
  
  END_IF;
  
END_FUNCTION // ObjectReader::GetUsedClasses
//[#DEUTSCH]
//Merkt sich die Anzahl der bisher installierten Objekte.
//Diese Information wird benötigt, wenn später für das ON alle Objekte 
//einer Klasse aufgelistet werden sollen, bei denen der Konstruktor noch 
//nicht aufgerufen wurde.
FUNCTION GLOBAL ObjectReader::UpdClsList
VAR
	i			  : UDINT;
	pCls		: ^ClsHdr;
	pInfo		: ^L2_ClsInfo;
END_VAR

  pInfo		:= pClsList;
  
  FOR i := 1 TO nClasses DO
    pCls        := pInfo^.pCls;
    pInfo^.pOld	:= pCls^.pLastObj;
    pInfo		+= sizeof(L2_ClsInfo);
  END_FOR;
  
END_FUNCTION

//[#DEUTSCH]
//Liest alle anzulegenden Objekte eines ONs ein und erstellt sie.
FUNCTION  ObjectReader::ReadObjects
VAR_OUTPUT
	ok		: BOOL;
END_VAR
#ifdef OTTOSPEED
VAR
	pInfo	: ^L2_ClsInfo;
	pCls	: ^ClsHdr;
	i,j		: UDINT;
	pObj	: ^pVirtualBase;
END_VAR

	pInfo	:= pClsList;
	pObj	:= pObjON;			// Liste aller bisher installierter Objekte/ON
  
  i := nClasses;
  while i do
    i    -= 1;
		pCls := pInfo^.pCls;

    j := pInfo^.nObj;
    while j do
      j -= 1;
      IF (pNxtObj $ HDINT AND 3) <> 0 THEN
        pNxtObj += 4 - (pNxtObj $ HDINT AND 3); // Ausrichtung der Objekte auf 4 Byte Adressen
      END_IF;
			pObj^	:= LSL_GetPtr(pNxtObj);
			pObj	+= sizeof(pVirtualBase);

			IF ReadObject(pCls) = FALSE THEN
	      ok := FALSE;
				RETURN;
			END_IF;
    end_while;
    
		pInfo += sizeof(L2_ClsInfo);
  end_while;

	ok := TRUE;
#else
VAR
	pInfo	: ^L2_ClsInfo;
	pCls	: ^ClsHdr;
	nObj	: UINT;
	i,j		: UDINT;
	pObj	: ^pVirtualBase;
END_VAR

	pInfo	:= pClsList;
	ok		:= FALSE;
	pObj	:= pObjON;			// Liste aller bisher installierter Objekte/ON
  
	FOR i:=1 TO nClasses DO		// alle verwendeten Klassen durchlaufen
		pCls	:= pInfo^.pCls;
		nObj	:= pInfo^.nObj;

		FOR j:= 1 TO nObj DO	// alle Objekte einer Klasse in diesem ON anlegen
      IF (pNxtObj $ HDINT AND 3) <> 0 THEN
        pNxtObj += 4 - (pNxtObj $ HDINT AND 3); // Ausrichtung der Objekte auf 4 Byte Adressen
      END_IF;
			pObj^	:= LSL_GetPtr(pNxtObj);
			pObj	+= sizeof(pVirtualBase);

			IF ReadObject(pCls) = FALSE THEN
				RETURN;
			END_IF;
		END_FOR;
		pInfo += sizeof(L2_ClsInfo);
	END_FOR;

	ok	:= TRUE;
#endif


END_FUNCTION // ObjectReader::ReadObjects

//[#DEUTSCH]
//Ruft für alle Objekte aller Klassen in diesem ON den Konstruktor auf.
FUNCTION  ObjectReader::CallConstructors
VAR_OUTPUT
	ok			: BOOL;
END_VAR
VAR
	pCls		: ^ClsHdr;
	pObj		: ^Obj;
	pInfo		: ^L2_ClsInfo;
	nCls		: UDINT;
END_VAR

	ok	:= FALSE;

	pInfo	:= pClsList;
	FOR nCls := 1 TO nClasses DO
		pCls	:= pInfo^.pCls;
		pObj	:= pInfo^.pOld;

		IF pObj = NIL THEN		// das 1. Objekt in diesem ON ermitteln
			pObj	:= pCls^.pFirstObj;
		ELSE
			pObj	:= pObj^.pNxtObj;
		END_IF;

		WHILE pObj <> NIL DO	// alle Objekte/Klasse dieses ON durchlaufen
    
      // Wenn der Constructor bereits aufgerufen wurde, dann nicht nochmals machen!
#ifdef LDR_RETSVR
      if( ( pObj^.pObjDsc^.Flags and LDR_SVRTYPE_CONSTRCALLED ) = 0 )then
#endif    
			IF CallConstructor(pCls, LSL_GetPtr(pObj)) <> C_OK THEN
        TRACE0_ERR("Constructor of '{0}' failed", LSL_GetObjName(LSL_GetPtr(pObj)));
        LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
				RETURN;
			END_IF;
#ifdef LDR_RETSVR      
      end_if;
#endif     
			pObj	:= pObj^.pNxtObj;
		END_WHILE;
		pInfo	+= sizeof(L2_ClsInfo);
	END_FOR;

	ok	:= TRUE;

END_FUNCTION // ObjectReader::CallConstructors

(* Initialisiert die Objekte aller Klassen in diesem ON anhand der im prjcfg-File angegebenen Initwerte *)
FUNCTION ObjectReader::InitAllObjsByPrjcfg
  VAR_INPUT
    f4Byte : BOOL; // Flag ist True wenn 4-Byte Werte initialisiert werden sollen (False bei einem String)
  END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
VAR
	pCls		: ^ClsHdr;
	pObj		: ^Obj;
	pInfo		: ^L2_ClsInfo;
	nCls		: UDINT;
END_VAR

	ok	:= FALSE;

	pInfo	:= pClsList;
	FOR nCls := 1 TO nClasses DO
		pCls	:= pInfo^.pCls;
		pObj	:= pInfo^.pOld;

		IF pObj = NIL THEN		// das 1. Objekt in diesem ON ermitteln
			pObj	:= pCls^.pFirstObj;
		ELSE
			pObj	:= pObj^.pNxtObj;
		END_IF;

		WHILE pObj <> NIL DO	// alle Objekte/Klasse dieses ON durchlaufen

      ConnectReader::InitByPrjcfg(pObj, f4Byte);
    
			pObj	:= pObj^.pNxtObj;
		END_WHILE;
		pInfo	+= sizeof(L2_ClsInfo);
	END_FOR;

	ok	:= TRUE;

END_FUNCTION // ObjectReader::CallConstructors

//[#DEUTSCH]
//Ein Objekt einer bestimmten Klasse auslesen und anlegen
FUNCTION  ObjectReader::ReadObject
VAR_INPUT
	pCls		: ^ClsHdr;
END_VAR
VAR_OUTPUT
	ok			: BOOL;
END_VAR
VAR
	pDsc		: ^ObjDsc;
  nSize   : UDINT;
END_VAR
	
  pDsc    := pTable $ ^ObjDsc;
	ok      := MakeObject( pNxtObj, pDsc, pCls );
	pTable  += sizeof(ObjDsc) + pDsc^.SymName.Length();
  nSize   := pCls^.pDsc^.lObj + sizeof(Obj);  // Obj - Größe ist in lObj nicht inkludiert

#ifdef FAR_OBJECT
  _memset(pNxtObj + nSize, 16#A5, 16);
  AddFarObject(pNxtObj+sizeof(Obj), pNxtObj+nSize);
  pNxtObj += 16;
#endif

	pNxtObj	+= nSize;

END_FUNCTION // ObjectReader::ReadObject
//[#DEUTSCH]
//Loader - Standard - Konstruktor für jedes Objekt aufrufen.
//Dabei werden die Standard - Methodenlisten zugewiesen und die Clients
//auf 'Nicht verbunden' gesetzt.
FUNCTION  ObjectReader::InitObject
VAR_INPUT
	pCls		: ^ClsHdr;
	pObj		: ^Obj;
END_VAR
VAR_OUTPUT
	ok			: bool;
END_VAR
VAR
	pThis		: ^VirtualBase;
END_VAR
	ok		:= FALSE;

	pThis	:= LSL_GetPtr(pObj);

	// Server - Kanäle mit Standard - Methoden - Listen initialisieren
	IF InitSvrChs(pCls, pThis) <> C_OK THEN
    TRACE0_ERR("Channel initialization for object '{0}' failed", LSL_GetObjName(pThis));
    LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
    RETURN;
	END_IF;

	// Client - Kanäle auf 'Not Connected' setzen
  IF InitCltChs(pCls, pThis) = FALSE THEN
    RETURN;
  END_IF;
  
  pCls  := pCls^.pBaseCls;
  IF pCls <> NIL THEN
    ok  := InitObject(pCls, pObj);
  ELSE
    ok	:= TRUE;
  END_IF;

END_FUNCTION // ObjectReader::InitObject
FUNCTION  ObjectReader::AllocON
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCls	,
	nObj	,
	udCnt	,
	udSize	: UDINT;
	pInfo	  : ^L2_ClsInfo;
END_VAR

  IF nClasses = 0 THEN
    // das ist der Fall, wenn keine Objekte im ON platziert werden
    ok := TRUE;
    RETURN;
  END_IF;

 #ifdef OTTOSPEED
	nSize	:= 0;
	udCnt	:= 0;
	pInfo	:= pClsList;
  nCls  := nClasses;

	WHILE nCls DO
    pInfo^.pOld	:= pInfo^.pCls^.pLastObj;
  
		nObj	:= pInfo^.nObj;	// Anzahl der Objekte in dieser Klasse
		udCnt	+= nObj;			  // Gesamtanzahl der Objekte
    udSize := pInfo^.pCls^.pDsc^.lObj + sizeof(Obj);
    IF (udSize AND 3) <> 0 THEN
      udSize += 4 - (udSize AND 3); // Ausrichtung der Objekte auf 4 - Byte - Adressen
    END_IF;
    
   #ifdef FAR_OBJECT
    udSize += 16;    
   #endif
    
		nObj	*= udSize;	  // Größe aller Obj/Klasse
		nSize	+= nObj;			// Gesamtgröße aller Objekte
		pInfo	+= sizeof(L2_ClsInfo);
		nCls	-= 1;
	END_WHILE;
 #else
	pInfo	:= pClsList;
	nSize	:= 0;
	udCnt	:= 0;
	nCls	:= 0;

	WHILE nCls < nClasses DO
		nObj	:= pInfo^.nObj;	// Anzahl der Objekte in dieser Klasse
		udCnt	+= nObj;			  // Gesamtanzahl der Objekte
    udSize := pInfo^.pCls^.pDsc^.lObj + sizeof(Obj);
    IF (udSize AND 3) <> 0 THEN
      udSize += 4 - (udSize AND 3); // Ausrichtung der Objekte auf 4 - Byte - Adressen
    END_IF;
    
   #ifdef FAR_OBJECT
    udSize += 16;    
   #endif
    
		nObj	*= udSize;	  // Größe aller Obj/Klasse
		nSize	+= nObj;			// Gesamtgröße aller Objekte
		pInfo	+= sizeof(L2_ClsInfo);
		nCls	+= 1;
	END_WHILE;
 #endif

	pON		  := _alloc(nSize);		// Speicher für alle Objekte des ON
	pNxtObj	:= pON $ ^Obj;
	// Puffer mit Zeigern auf die Objekte des ON
	pObjON	:= _alloc(udCnt * sizeof(pVirtualBase)) $ ^pVirtualBase;

	ok		:= pON <> NIL & pObjON <> NIL;

	IF ok THEN
		_memset(pON, 0, nSize);
		_memset(pObjON, 0, udCnt * sizeof(pVirtualBase));
    nObjs := udCnt;
	END_IF;

END_FUNCTION
FUNCTION  ObjectReader::GetCount
VAR_OUTPUT
	nCnt		: UDINT;
END_VAR

	nCnt	:= pTable^ $ UDINT;	// Anzahl der Verbindungen
	pTable	+= sizeof(UDINT);

END_FUNCTION // ObjectReader::GetCount
//[#DEUTSCH]
//Liefert einen Zeiger auf einen Kanal, der per Namen angegeben ist
FUNCTION  ObjectReader::GetChPtr
VAR_INPUT
	pThis	: ^VirtualBase;
END_VAR
VAR_OUTPUT
	pClt	: ^CltCh;
END_VAR
VAR
	pCls	: ^ClsHdr;
	pObj	: ^Obj;
	pCh		: ^ChDsc;
END_VAR

  IF pThis = NIL THEN
    pClt  := NIL;
    TRACE0_ERR("Channel '{0}' is assigned to a NIL - pointer", pTable $ ^char);
    LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
    RETURN;
  END_IF;
  
	pObj	:= LSL_GetHdr(pThis);
	pCls	:= pObj^.pClsHdr;

  IF pTable^ $ char = 0 THEN    // wenn ein 0-String angegeben ist, dann wird das Objekt angesprochen
  
    pClt := pThis $ ^CltCh;
    pTable  += 1;               // 0-er überlesen
    
  ELSE
    pCh := _LookupChPtr(pCls, pTable $ ^char);
  
    IF pCh = NIL THEN			// Angabe des Client-Kanals ist ungültig
      pClt	:= NIL;
      TRACE1_ERR("Channel '{0}::{1}' is unknown", LSL_GetObjName(pThis), pTable $ ^char);
      LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
      RETURN;
    END_IF;
    
  
    pClt	:= pThis + pCh^.pDsc^.uiOff;
    SkipText();	// Kanalnamen überlesen

  END_IF;
  
END_FUNCTION // ObjectReader::GetChPtr
FUNCTION  ObjectReader::GetObjectOff
VAR_OUTPUT
	pThis		: ^VirtualBase;
END_VAR

	pThis := (pOn + GetCount()) $ ^VirtualBase;

END_FUNCTION // ObjectReader::GetObjectOff
FUNCTION  ObjectReader::GetObjectNo
VAR_OUTPUT
	pThis		: ^VirtualBase;
END_VAR
VAR
	udObj		: UDINT;
END_VAR

	udObj	:= GetCount();	// Objekt-Nr im ON
  
  IF udObj >= nObjs THEN
    TRACE_ERR("Invalid object number");
    LSLCLI_LoaderTracePrint("Invalid object number", 12);
    pThis := NIL;
    RETURN;
  END_IF;

	pThis	:= (pObjON + sizeof(pVirtualBase) * udObj)^ $ pVirtualBase;

END_FUNCTION // ObjectReader::GetObjectNo

FUNCTION  ObjectReader::GetSymbol
VAR_OUTPUT
	udValue		: UDINT;
END_VAR

	ReadLexem();

	udValue	:= 0;

END_FUNCTION // ObjectReader::GetSymbol
//    This is just the header of a function that can be
//    used as a constructor.
//    The constructure gets a pointer to a completly allocated
//    object. The object header and the channel descriptor
//    pointers are already initialized.
//    Each class MUST have a constructor. Its name is equal to
//    the class name.
//    
//    ->this    : pointer to the constructed object
//    <-ret_code: TRUE ok
//                FALSE construction of the object failed

FUNCTION _STD_CO
VAR_INPUT
	ESI			: ^void;	// ESI is used as this-pointer
END_VAR
VAR_OUTPUT
#pragma warning(disable:76)
	ret_code	: CONFSTATES;
#pragma warning(default:76)
END_VAR

END_FUNCTION
//Calls for the constructor for a new object of the class. If the
//constructor is not implemented, then the base class constructor
//is called.
//[>pCls]		pointer to the class descriptor
//[>pObj]		pointer to the object's data block
//[<ret_code]	user defined return code
FUNCTION GLOBAL ObjectReader::CallConstructor
	VAR_INPUT
		pCls 	: ^ClsHdr;
		pObj 	: ^VirtualBase;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	IF pCls = NIL THEN
		ret_code := C_OK;
	ELSIF pCls^.pConstructor <> NIL THEN
	  ret_code := pCls^.pConstructor $ _Std_CO(pObj);

#ifdef LDR_RETSVR
    // der Constructor erstellt die richtige Methodentabelle
    // die write müssen wir verbiegen
    if( usHasRetentive )then
      if( RetentiveSvrChs( pCls, pObj ) <> C_OK )then
        ret_code := C_SYSEXIT;
      end_if;
    end_if;
#endif
	ELSE
		ret_code := CallConstructor(pCls^.pBaseCls, pObj);
	END_IF;

END_FUNCTION

// Initializes the server channels of an object. The methods point to
// dummy methods.
//[>pThis]		pointer to current object
//[>pCls]		pointer to it's class
//[<ret_code]	C_OK if methods could be allocated, syntax is ok,..
FUNCTION ObjectReader::InitSvrChs
VAR_INPUT
	pCls			: ^ClsHdr;
	pThis			: ^VirtualBase;
END_VAR
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR
VAR
	uiCh			: UINT;
	uiSvr			: UINT;
	pChDsc			: ^ChDscEntry;
	ppCD			: ^ChDsc;
	pCh				: ^SvrCh;
#ifdef LDR_RETSVR
  flags     : uint;
#endif
END_VAR


	uiSvr   := pCls^.pDsc^.nSvrChs;
	uiCh	:= 0;
	ppCD	:= #pCls^.aDscChs[0];

	WHILE uiCh < uiSvr DO

		pChDsc	:= ppCD^.pDsc; 
		pCh := pThis+pChDsc^.uiOff;

#ifdef LDR_RETSVR
    flags   := pChDsc^.uiFlags; // <-- damit muss ich nicht ständig dereferenzieren und kann flags auch beschreiben!

    // Retentive Flag ist gesetzt
    if( flags and LDR_SVRTYPE_RETENTIVEFLAG )then

      if( usCheckRetentive = LDR_RETENTIVE_NOT_CHECKED )then
        doRetentiveCheck();
      end_if;

      // wenns nicht geht, dann Flags zurücksetzen
      if( usCheckRetentive and LDR_RETENTIVE_IMPOSSIBLE )then
        flags := flags and not( LDR_SVRTYPE_RETENTIVEFLAG );
        flags := flags and not( LDR_SVRTYPE_RETENTIVEFILE );
        
        usCheckRetentive := LDR_RETENTIVE_IMPOSSIBLE;
        
        // Tracemeldung
        if( ( usReportRetentive and LDR_RETENTIVE_IMPOSSIBLE ) = 0 )then
          usReportRetentive := usReportRetentive or LDR_RETENTIVE_IMPOSSIBLE;
          usReportRetentive := usReportRetentive or LDR_RETENTIVE_FILEOK;
          usReportRetentive := usReportRetentive or LDR_RETENTIVE_SRAMOK;
          TRACE_WARN( "Retentive servers are not supported!" );
          LSLCLI_LoaderTracePrint( "Retentive servers are not supported!", 12 );          
        end_if;
        
      else
      
        // wenns ins File soll und das nicht möglich ist, solls in SRAM und umgekehrt
        if( flags and LDR_SVRTYPE_RETENTIVEFILE )then
          if( ( usCheckRetentive and LDR_RETENTIVE_FILEOK ) = 0 )then
            flags := flags and not( LDR_SVRTYPE_RETENTIVEFILE );
            
            // Tracemeldung
            if( ( usReportRetentive and LDR_RETENTIVE_FILEOK ) = 0 )then
              usReportRetentive := usReportRetentive or LDR_RETENTIVE_FILEOK;
              TRACE_ERR( "Retentive servers cannot be stored into a file!" );
              LSLCLI_LoaderTracePrint( "Retentive servers cannot be stored into a file!", 12 );                     
            end_if;
            
            // File --> SRAM
            if( ( usCheckRetentive and LDR_RETENTIVE_SRAMOK ) = 0 )then
              flags := flags and not( LDR_SVRTYPE_RETENTIVEFLAG );
              usCheckRetentive := LDR_RETENTIVE_IMPOSSIBLE;
              if( ( usReportRetentive and LDR_RETENTIVE_IMPOSSIBLE ) = 0 )then
                usReportRetentive := usReportRetentive or LDR_RETENTIVE_IMPOSSIBLE;
                usReportRetentive := usReportRetentive or LDR_RETENTIVE_FILEOK;
                usReportRetentive := usReportRetentive or LDR_RETENTIVE_SRAMOK;
                TRACE_WARN( "Retentive servers are not supported!" );
                LSLCLI_LoaderTracePrint( "Retentive servers are not supported!", 12 );          
              end_if;          
            end_if;
          else
            // Vorbereitungen für das Speichern in ein File 
            InitRetainSvrFile( 0 );
          end_if;
        else
          if( ( usCheckRetentive and LDR_RETENTIVE_SRAMOK ) = 0 )then
            flags := flags or LDR_SVRTYPE_RETENTIVEFILE;
            
            // Tracemeldung
            if( ( usReportRetentive and LDR_RETENTIVE_SRAMOK ) = 0 )then
              usReportRetentive := usReportRetentive or LDR_RETENTIVE_SRAMOK;
              TRACE_ERR( "Retentive servers cannot be stored into the SRAM!" );
              LSLCLI_LoaderTracePrint( "Retentive servers cannot be stored into the SRAM!", 12 );
            end_if;
  
            // SRAM --> File
            if( ( usCheckRetentive and LDR_RETENTIVE_FILEOK ) = 0 )then
              flags := flags and not( LDR_SVRTYPE_RETENTIVEFLAG );
              flags := flags and not( LDR_SVRTYPE_RETENTIVEFILE );
              usCheckRetentive := LDR_RETENTIVE_IMPOSSIBLE;
              if( ( usReportRetentive and LDR_RETENTIVE_IMPOSSIBLE ) = 0 )then
                usReportRetentive := usReportRetentive or LDR_RETENTIVE_IMPOSSIBLE;
                usReportRetentive := usReportRetentive or LDR_RETENTIVE_FILEOK;
                usReportRetentive := usReportRetentive or LDR_RETENTIVE_SRAMOK;
                TRACE_WARN( "Retentive servers are not supported!" );
                LSLCLI_LoaderTracePrint( "Retentive servers are not supported!", 12 );          
              end_if;          
            else
              // Vorbereitungen für das Speichern in ein File
              InitRetainSvrFile( 0 );
            end_if;
  
          end_if;        
        end_if;
      end_if;
      
      // Retentive Flag noch immer gesetzt
      if( flags and LDR_SVRTYPE_RETENTIVEFLAG )then  
        usHasRetentive := 1;  
      end_if;
      
      // die Flags speichere ich hier temporär rein bis die richtige Struktur an diese Stelle kommt!
      pCh^.pSvrDsc$uint := flags;
      
    end_if;

#endif

		CASE pChDsc^.uiMode OF
    _CH_CMD:
			pCh^.pMeth := sbCallInit.pCmdMeth$^ChMeth;	// RD,WR,Init,CyWork...
 		ELSE
			IF uiCh = 0 &   			// the 1st server must be a command server
				pCls^.pBaseCls = NIL THEN	// .. but only in the base classes
				ret_code := C_SYNTAX_ERROR;
        TRACE0_ERR("Wrong channel type for the topmost server of object '{0}'", LSL_GetObjName(pThis));
        LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
        RETURN;
			END_IF;
			// if the access methods are not overwritten, a standard
			// direct read access and no write access to the server channel
			// are set up as default
			pCh^.pMeth := sbCallInit.pDataMeth;
		END_CASE;
		uiCh += 1;

		ppCD	+= sizeof(ChDsc);

	END_WHILE;

	ret_code	:= C_OK;

END_FUNCTION
FUNCTION ObjectReader::InitString
VAR_INPUT
	pObj		: ^VirtualBaseInit;
END_VAR
VAR_OUTPUT
	ok			: BOOL;
END_VAR
VAR
	uiLen		: UINT;
  uiType  : UINT;
//  pCh     : ^CltChCmd;    // 17.01.05 GanBer
END_VAR

	ok	:= TRUE;
  
  uiType  := GetUInt();     // ist ein Objekt oder ein Client zu intialisieren?
	uiLen	  := GetUInt();   	// Länge überlesen
  IF uiType AND 1 THEN        // unterstes Bit: Client
    pTable += uiLen;        //Daten überlesen
    RETURN;

   //17.01.05 GanBer
   // Es funktioniert nicht, eine String, StringRam oder ähnliches mit einem Initwert vom
   // Client zu initialisiern, da noch nicht alle ONs existieren und die Verbindung am Client
   // eventuell zu einem ON geht, der noch nicht angelegt ist.
  (*
    pCh := pObj $ ^CltChCmd;
    IF IsClientConnected(#pCh^.dData) = FALSE THEN
      pTable	+= uiLen;			  // Daten überlesen
      RETURN; // nicht verbundener Client wird nicht initialisiert
    END_IF;
    pObj  := pCh^.pCmd $ ^VirtualBaseInit; // das verbundene Objekt wird initialisiert
  *)
  END_IF;
  
	pObj^.InitFromTable(uiLen, pTable $ ^USINT);
	pTable	+= uiLen;			  // Daten überlesen

END_FUNCTION
//[#DEUTSCH]
//Alle Arten von Verbindungen setzen, die aus diesem ON hinausgehen
FUNCTION GLOBAL ObjectReader::SetExternConnection
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    ConRd		: ConnectReader;
    pExtern : ^void;
  END_VAR

  pExtern := pTable;

	ok :=	ConRd.SetExtConnection(this);
  
  pTable  := pExtern;   // falls weitere ONs nachgeladen werden, dann können die externen
                        // Verbindungen erneut geprüft werden, bzw. müssen bestehende Verbindungen
                        // zu überschriebenen Objekten neu angelegt werden

END_FUNCTION // ObjectReader::SetExternConnection


FUNCTION GLOBAL ObjectReader::SetTable
	VAR_INPUT
		pConfig 	: ^void;
	END_VAR
	VAR_OUTPUT
		ok 	      : BOOL;
	END_VAR
  VAR
  	udTableLen : UDINT;
  END_VAR


  IF pConfig = NIL THEN
    TRACE_ERR("Configuration table not found");
    LSLCLI_LoaderTracePrint("Configuration table not found", 12);
    GOTO SET_ERROR;
  END_IF;
  
	pTable := pConfig;
  
  // Längen - DWort überlesen
  udTableLen := GetCount();

  pTableEnd := (pTable + udTableLen);

	// Art der Tabelle prüfen
	IF pTable^$UINT <> KIND_OF_TABLE THEN
    TRACE_ERR("Configuration table has a wrong ID");
    LSLCLI_LoaderTracePrint("Configuration table has a wrong ID", 12);
  SET_ERROR:
    ok  := FALSE;
    pTable  := NIL;
    pTableEnd := NIL;
		RETURN;
	END_IF;

	GetUInt();		  // Tabellenart überlesen

	GetUInt();		  // Version prüfen

//	pTable  += sizeof(UDINT);	    // Offset Externals überlesen
  
  pTable  += sizeof(Revision);  // Revision des ON überlesen
  
  ok  := TRUE;

END_FUNCTION


FUNCTION GLOBAL ObjectReader::_dtor

  _free(pClsList);
  pClsList  := NIL;

END_FUNCTION


FUNCTION GLOBAL ObjectReader::ReadLexem
VAR_OUTPUT
  pLexem    : ^CLexem;
END_VAR

	pLexem	:= pTable $ ^CLexem;
	pTable	+= pLexem^.Size();
  
END_FUNCTION


FUNCTION GLOBAL ObjectReader::GetUInt
	VAR_OUTPUT
		uiVal 	: UINT;
	END_VAR
  
  uiVal   := pTable^ $ UINT;
  pTable  += sizeof(UINT);

END_FUNCTION


FUNCTION ObjectReader::InitCltChs
	VAR_INPUT
		pCls 	: ^ClsHdr;
		pThis 	: ^VirtualBase;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
VAR
	ppCD		: ^ChDsc;
	pChDsc		: ^ChDscEntry;
	uiChs		: UINT;
	uiCh		: UINT;
	pCh			: ^CltCh;
	pEmbObj		: ^VirtualBase;
	pDsc		: ^ClsHdrConst;
END_VAR

	pDsc	:= pCls^.pDsc;
	ppCD	:= #pCls^.aDscChs[pDsc^.nSvrChs];
	uiChs	:= pDsc^.nCltChs;

	FOR uiCh := 1 TO uiChs DO

		pChDsc	:= ppCD^.pDsc;
    
		pCh			:= (pThis + pChDsc^.uiOff)$^CltCh;
    
		CASE pChDsc^.uiMode OF
		_CH_TEMP_VBI_EMB,			// Objektkanäle, intern
		_CH_CLT_EMB:		;

		_CH_TEMP_VBI_OBJ,			// Objektkanäle, extern
		_CH_CLT_OBJ:
			IF (ppCD^.pCls <> NIL) & (ppCD^.pCls^.pDsc^.ClsType AND CTY_OSI_CLASS) THEN	
				// connected to predefined obj
				pEmbObj		:= LSL_GetPtr(ppCD^.pCls^.pFirstObj);
				pCh^.pCh	:= pEmbObj$^SvrCh;
				pCh^.pCmd	:= pEmbObj;
			ELSE
				GOTO DEFAULT_CONNECTION;
			END_IF;
      
		ELSE
		DEFAULT_CONNECTION:
      pCh^.pCh  := #pCh^.pCmd $ SvrCh;
			// connect the constant read and write methods as default
			pCh^.pCmd	:= sbCallInit.pCltMeth$^VirtualBase;

		END_CASE;
		
		ppCD	+= sizeof(ChDsc);
	END_FOR;
  
  ok  := TRUE;

END_FUNCTION

FUNCTION AWL _struprcpy
VAR_INPUT
	dst		: ^void;
	src		: ^void;
END_VAR

#ifdef _LSL_TARGETARCH_ARM
  STMDB     sp!, {r5}
StrUpCpyBbB
  LDRB      r5, [src], #1
  STRB      r5, [dst], #1
  CMP       r5, #0
  BEQ       StrUpCpyEnd
  
  CMP       r5, #'a'
  BLO       StrUpCpyBbB
  CMP       r5, #'z'
  BHI       StrUpCpyBbB
  
  SUB       r5, r5, #'a'-'A'
  STRB      r5, [dst, #-1]
  B         StrUpCpyBbB

StrUpCpyEnd
  LDMIA     sp!, {r5}
#else
  push esi

  l.edi dst
  l.esi src

_struprcpy_loop
  l.al (esi)
  
  cmp.al 'a'
  jb _struprcpy_next
  cmp.al 'z'
  ja _struprcpy_next
  add.al ('A'-'a')
  
_struprcpy_next  
  s.al (edi)
  inc esi
  inc edi
  
  o.al al
  jnz _struprcpy_loop
   
  pop esi
#endif
END_FUNCTION


// This function creates a new object of a specified class. The class
// may be complex, too. All the internal connections are set. Till now 
// there is no possibility to set the init values.
//[>pClsName]	class name
//[>pObjName]	object name, if NIL a default name is constructed
//[<pNewObj]	pointer to the objects data area, NIL if creation failed
FUNCTION GLOBAL ObjectReader::NewObj
	VAR_INPUT
		pClsName 	: ^CHAR;
		pObjName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		pNewObj (EAX) 	: ^VirtualBase;
	END_VAR
VAR
	pCls			: ^ClsHdr;
	szName		: ARRAY [0..NLNG+1] OF CHAR;
  udAll,
	udLen			: UDINT;
	pObj			: ^Obj;
  pObjDsc   : ^ObjDsc;
//  crc : UDINT;
END_VAR

  pNewObj := NIL;

 #ifndef _LSL_USECLISTI
  CriticalLoaderSectionStart();
 #endif

  _struprcpy(#szName[0], pClsName);

  pCls := _LookupCls(#szName[0]);
  IF pCls	<> NIL THEN
    IF(pObjName = NIL) | (pObjName^ = 0) THEN		// create a default name
      szName[0] := 228;//this number is only for a clearly name of the object  
      udLen := _strlen(pClsName) + 1;
      _memcpy(#szName[1], pClsName, udLen);
      _itoa(pCls^.nObjs, #szName[udLen]);
      pObjName := #szName[0];
    END_IF;

    // the function may only be called with non-complex classes, as the internal connections
    // between embedded objects are no longer stored with the classes, but in the ON - config tables
    udLen   := sizeof(ObjDsc) + _strlen(pObjName) + 1;
    udAll   := udLen + sizeof(Obj) + pCls^.pDsc^.lObj;
    pObjDsc := _alloc_align(udAll) $ ^ObjDsc;
  
    IF pObjDsc <> NIL THEN
      _memset(pObjDsc, 0, udAll);
      pObjDsc^.SymName $ CLocLex.InitText(pObjName);

      //crc := pObjDsc^.SymName.udCrc;
  
      pObj := pObjDsc + udLen;
  
      IF MakeObject(pObj, pObjDsc, pCls) = TRUE THEN
        pNewObj := LSL_GetPtr(pObj);
        IF CallConstructor(pCls, pNewObj) <> C_OK THEN
          pNewObj := NIL;
        END_IF;
      END_IF;
    END_IF;
  END_IF;

 #ifndef _LSL_USECLISTI
  CriticalLoaderSectionStop();
 #endif

END_FUNCTION

FUNCTION ObjectReader::MakeObject
	VAR_INPUT
		pNxtObj 	: ^Obj;
		pDsc 	: ^ObjDsc;
		pCls 	: ^ClsHdr;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR

	ok			:= FALSE;

	pNxtObj^.pClsHdr	:= pCls;
	pNxtObj^.pNxtObj	:= NIL;
	pNxtObj^.pObjDsc	:= pDsc;

	IF pCls^.nObjs = 0 THEN						// in die Objektliste der Klasse einfügen
		pCls^.pFirstObj	:= pNxtObj;
	ELSE
		pCls^.pLastObj^.pNxtObj	:= pNxtObj;
	END_IF;

	pCls^.pLastObj	:= pNxtObj;
	pCls^.nObjs		+= 1;

	IF InitObject(pCls, pNxtObj) = FALSE THEN	// Kanäle initialisieren
		RETURN;
	END_IF;

	PutCRCintoMap(pDsc^.SymName.udCrc, pNxtObj);

//  if(pNewCrc <> NIL) then
//    pNewCrc^ := pDsc^.SymName.udCrc;
//  end_if;
  
	ok	:= TRUE;

END_FUNCTION


FUNCTION ObjectReader::SkipText

  pTable	+= _strlen(pTable $ ^char) + 1;
  
END_FUNCTION

#ifdef LDR_RETSVR
FUNCTION ObjectReader::doRetentiveCheck
var
  pRamTest : ^ClsHdr;
  pFileTest : ^ClsHdr;
end_var

  usHasRetentive := 0;
  
  udSRAMVersion := GetVersion_sRam();
  
  // Das ganze geht nicht für CCL081 und IPC!
  if( //( _WhoAmI = DESTPLC_CCL081CET ) | 
      //( _WhoAmI = DESTPLC_CCL081 )    | 
      ( _WhoAmI = DESTPLC_IPC_TEXT )  |
      ( _WhoAmI = DESTPLC_IPC_800 )   |
      ( _WhoAmI = DESTPLC_IPC_1024 ) )then
    usCheckRetentive := LDR_RETENTIVE_IMPOSSIBLE;
  else
  
    // Retentiver Server soll in ein File rein
    // Plattform ohne Filesystem oder mit Filesystem am Flashspeicher (readonly und viel zu lahm!)
    if( ( _WhoAmI = DESTPLC_CCL721 )    | 
        ( _WhoAmI = DESTPLC_CCL722 )    | 
        ( _WhoAmI = DESTPLC_DCL642 )    |
        ( _WhoAmI = DESTPLC_DTC081 )    |
        ( _WhoAmI = DESTPLC_DTC081_IP ) |
        ( _WhoAmI = DESTPLC_HZS511 )    |
        ( _WhoAmI = DESTPLC_DCC080 )    |
        ( _WhoAmI = DESTPLC_HERZ )      |
        ( _WhoAmI = DESTPLC_AK500 )     |
        ( _WhoAmI = DESTPLC_RK500 )     |
        ( _WhoAmI = DESTPLC_TSTROM ) )then
      usCheckRetentive := usCheckRetentive and not( LDR_RETENTIVE_FILEOK );              
    else

      // Klasse "RetSvrFile" im Projekt suchen
      pFileTest := _LookupCls( "RetSvrFile" );
      if( pFileTest <> NIL )then
        //prüfen, ob das mit dem File auch hinhaut
        if( InitRetainSvrFile( 1 ) = 1 )then
          usCheckRetentive := usCheckRetentive or LDR_RETENTIVE_FILEOK;
        end_if;
      else
        if( ClassReader::NewCls( "RetSvrFile" ) <> NIL )then
          //prüfen, ob das mit dem File auch hinhaut
          if( InitRetainSvrFile( 1 ) = 1 )then
            usCheckRetentive := usCheckRetentive or LDR_RETENTIVE_FILEOK;
          end_if;
        end_if;
      end_if;
    end_if;
      
    // Retentiver Server soll ins SRAM -> wir benötigen die Klasse "RetSvrRAM" dafür
    // Plattform ohne SRAM (Ausnahme: CCL081 und IPC, da die bereits abgefangen sind)
    if( _WhoAmI = DESTPLC_AUW11X )then
      usCheckRetentive := usCheckRetentive and not( LDR_RETENTIVE_SRAMOK );              
    else
    
      // Klasse "RetSvrRAM" im Projekt suchen
      pRamTest := _LookupCls( "RetSvrRAM" );
      if( pRamTest = NIL )then
        if( ClassReader::NewCls( "RetSvrRAM" ) = NIL )then
          usCheckRetentive := usCheckRetentive and not( LDR_RETENTIVE_SRAMOK );
        end_if;
      end_if;
      
      pRamTest := _LookupCls( "RetSvrRAM" );
      if( pRamTest <> NIL )then      
      
        // beim CIPC muss die Ram-Klasse eine bestimmte Version haben
        if( _whoami = 32 )then
          if( pRamTest^.pDsc^.udRev.Lo < 1 )then
            usCheckRetentive := usCheckRetentive and not( LDR_RETENTIVE_SRAMOK );
          else
            usCheckRetentive := usCheckRetentive or LDR_RETENTIVE_SRAMOK;
          end_if;
        else
          usCheckRetentive := usCheckRetentive or LDR_RETENTIVE_SRAMOK;
        end_if;
      end_if;
    end_if;
    
    // Wenn File und SRAM nicht möglich sind ...
    if( usCheckRetentive and ( LDR_RETENTIVE_SRAMOK  or LDR_RETENTIVE_FILEOK ) )then
    else
      usCheckRetentive := LDR_RETENTIVE_IMPOSSIBLE;
    end_if;
  end_if;
        
END_FUNCTION

// hier werden die Methodenpointer verbogen und die Speicherobjekte angelegt
FUNCTION ObjectReader::RetentiveSvrChs
	VAR_INPUT
		pCls 	: ^ClsHdr;
		pThis 	: ^VirtualBase;
	END_VAR
	VAR_OUTPUT
		ret_code 	: CONFSTATES;
	END_VAR
  VAR
    uiCh			: UINT;
    uiSvr			: UINT;
    pChDsc		: ^ChDscEntry;
    ppCD			: ^ChDsc;
    pCh				: ^SvrCh;
    pRetSvr   : ^RetSvr;
    pSaveObj  : ^void;
    pObj      : ^Obj;
    name      : array[ 0 .. 224 ] of usint;
    len       : udint;
    NbrNotFound : udint;
    flags     : uint;
   #ifdef OTTOSPEED 
    i : udint;
   #else
    i : dint;
   #endif
    pNewRamObj  : ^Obj;
    pRAMaddr  : ^RamCell;
	  pFileAdr  : ^XFileCell;
  END_VAR

  if( pCls^.pBaseCls <> NIL )then
    RetentiveSvrChs( pCls^.pBaseCls, pThis );
  end_if;

	uiSvr := pCls^.pDsc^.nSvrChs;
	uiCh	:= 0;
	ppCD	:= #pCls^.aDscChs[ 0 ];
  
  // alle Server der Klasse durchmarschieren
	while( uiCh < uiSvr )do

		pChDsc	:= ppCD^.pDsc;
    pCh     := pThis + pChDsc^.uiOff;
    flags   := pCh^.pSvrDsc$uint; // Flags vom temporären Speicher merken
    
    // es handelt sich um einen retentiven Server
    if( flags and LDR_SVRTYPE_RETENTIVEFLAG )then
    
      // in pSvrDsc wird nun eine Struktur hinterlegt
      pRetSvr$^void := _alloc_resize_LDR( sizeof( RetSvr ) );
      if( pRetSvr = NIL )then
        ret_code := C_SYSTEM_ERROR;
        return;
      end_if;     
      pCh^.pSvrDsc$^void := pRetSvr$^void;
      
      pRetSvr^.flags := flags;    // Flags in die Struktur reinspeichern
      if( pCh^.pMeth^.pWr$^void = #retentiveWriteSplitter() )then
        pCh^.pMeth^.pWr := #M_WR_DIRECT();
      end_if;
      pRetSvr^.pMeth := pCh^.pMeth^.pWr$^void;  // alte write Methode speichern
      pCh^.pMeth^.pWr := #retentiveWriteSplitter(); // neue write Methode setzen
      
      // Speicherobjekt anlegen
      pObj := LSL_GetHdr( pThis );
      
      // der Name für das Speicherobjekt wird aus dem Objektnamen, dem Servernamen und "RemSvr" zusammengebastelt
      len := pObj^.pObjDsc^.SymName.Length();
      _memset( #name[ 0 ], 0, 224 );
      _memcpy( #name[ 0 ], #pObj^.pObjDsc^.SymName.Text[ 0 ], len );
    
     #ifdef OTTOSPEED
      i := len;
      while(i) do
        i -= 1;
        if(name[i] = '\') then
          name[i] := '#';
        end_if;
      end_while;
      name[ len ] := '#';
      i := pChDsc^.Name.Length();
      _memcpy( #name[ len + 1 ], #pChDsc^.Name.Text[ 0 ], i );
      len += i + 1;
     #else 
      for i := 0 to len$dint - 1 do
        if( name[ i ] = '\' )then
          name[ i ] := '#';
        end_if;
      end_for;
      name[ len ] := '#';
      _memcpy( #name[ len + 1 ], #pChDsc^.Name.Text[ 0 ], pChDsc^.Name.Length() );
      len += pChDsc^.Name.Length() + 1;
     #endif
      
      name[ len ] := '#';
      _memcpy( #name[ len + 1 ], "RemSvr", 6 );

      //ermittlen, wie viele File-Objekte bereits _nicht_ gefunden wurden (anhand des Namens).
      //so kann ich feststellen, ob es bereits existiert hat und den Initwert übermalen
      NbrNotFound := GetNbrNotFound();
      pSaveObj := NIL;
      
      // ein Speicherobjekt soll im File angelegt werden
      if( flags and LDR_SVRTYPE_RETENTIVEFILE )then
        pSaveObj := NewObj( "RetSvrFile", #name[ 0 ]);
                
        if( pSaveObj <> NIL )then
          //so, hats das Objekt nun schon gegeben?
          if( GetNbrNotFound() = NbrNotFound ) then
            // das merke ich mir mal, zu diesem Zeitpunkt die Daten auslesen geht nämlich nicht
            pRetSvr^.flags := pRetSvr^.flags or LDR_SVRTYPE_EXISTED;
          else
            // ***** CONVERT *****
            // Erst suchen ob es ein RetentiveRam server WAR - wenn ja den Wert übernehmen
            
            pNewRamObj := pSaveObj - sizeof(Obj);

            if(udSRAMVersion < 2) then
              // Format 1
                pRAMaddr$UDINT := Find_sRamEx(pNewRamObj^.pObjDsc^.SymName.udCRC, TRUE)$UDINT;

              if(pRAMaddr <> NIL) then
                // Server wurde im RetentiveRam gefunden - Daten übernehmen
                if(pRAMaddr$^XramCell^.udType and 16#80000000) = 16#80000000 then
                  // Die Daten sind gültig
               	  pCh^.dData := pRAMaddr^.udData$dint;
                  LDR_ForceSramReorgOnNextRun();
                end_if;
              end_if;
            else
              // Format 2
              if(Find_sRamFileEx(pNewRamObj^.pObjDsc^.SymName.udCRC, #pRAMaddr$UDINT, #pFileAdr, 0, TRUE) = 0) then
                if(pRAMaddr <> NIL) then
                  // Server wurde im RetentiveRam gefunden - Daten übernehmen
                  if(pFileAdr^.udType and 16#80000000) = 16#80000000 then
                  // Die Daten sind gültig
                    pCh^.dData := pRAMaddr^$dint;
                    LDR_ForceSramReorgOnNextRun();
                  end_if;
                end_if;
              end_if;
            end_if;
            // ***** CONVERT *****

            // der Initwert schlägt zu und wird remanent gespeichert
            pSaveObj$^RetSvrFile^.WriteNew( pCh^.ddata );
          end_if;
        end_if;

      // ein Speicherobjekt soll im SRAM angelegt werden
      else
        pSaveObj := NewObj( "RetSvrRAM", #name[ 0 ] );

        if( pSaveObj <> NIL )then
          //so, hats das Objekt nun schon gegeben?
          if( GetNbrNotFound() = NbrNotFound  ) then
            // das merke ich mir mal, zu diesem Zeitpunkt die Daten auslesen geht nämlich nicht
            pRetSvr^.flags := pRetSvr^.flags or LDR_SVRTYPE_EXISTED;
          else
            // ***** CONVERT *****
            // Erst suchen ob es ein RetentiveFile server WAR - wenn ja den Wert übernehmen
            // Dieser Programmteil war vorher im else Zweig - Objekt nicht gefunden.
            // Manchmal kommt es zu einer Situation, dass anscheinend dieses Objeckt schon
            // vorhanden war.
            pNewRamObj := pSaveObj - sizeof(Obj);

            AsyncState.state := 0;
  //              AsyncState.pDataObj := #pCh^.dData$UDINT;
            AsyncState.pDataObj := NIL;
            AsyncState.pNext := NIL;

            if(Find_FileEx(pNewRamObj^.pObjDsc^.SymName.udCRC, #AsyncState.XRamAddr$^void, TRUE) = 0) then
              // Server wurde im RetentiveFile gefunden - Daten übernehmen
                pCh^.dData := AsyncState.XRamAddr.udData$dint;
                LDR_ForceSramReorgOnNextRun();
            end_if;
            // ***** CONVERT *****

            // der Initwert schlägt zu und wird remanent gespeichert
            if( udSRAMVersion < 2 )then
              pSaveObj$^RetSvrRAM^.Data.Write( pCh^.ddata );
            else
              pSaveObj$^RetSvrRAM^.WriteNew( pCh^.ddata );
            end_if;
          end_if;
        end_if;
      end_if;

      if( pSaveObj <> NIL )then
      
        // merken, dass der Constructor bereits ausgeführt wurde
        pObj := LSL_GetHdr( pSaveObj );
        pObj^.pObjDsc^.Flags := pObj^.pObjDsc^.Flags or LDR_SVRTYPE_CONSTRCALLED;
      
        // das Speicherobjekt muss ich mir merken, wenns angelegt werden konnte
        pRetSvr^.pSaveObj := pSaveObj;
      else
        ret_code := C_SYSTEM_ERROR;
        return;
      end_if;

    end_if;

    uiCh += 1;

    ppCD	+= sizeof( ChDsc );

	end_while;

	ret_code := C_OK;

END_FUNCTION

// Initialisiert die remanenten Server
FUNCTION  ObjectReader::RemSvrInit
VAR_OUTPUT
	ok			: BOOL;
END_VAR
var
  pInfo		: ^L2_ClsInfo;
  nCls		: UDINT;
end_var

	ok := TRUE;

  if( usHasRetentive = 0 )then
    return;
  end_if;
  
  // an dieser Stelle können wird den temporären Speicher für die remanenten Server
  // im File freigeben. -> Lesezugriffe gehen sowieso auf die Klasse RetSvrFile und
  // Schreibzugriffe müssen per Definition sofort durchgeführt werden => Buffer
  // wird nicht mehr benötigt
  // -- eben nicht!
  //FreeMemoryRetainSvrFile();

  // alle Klassen und alle Objekte durchlatschen
  pInfo := pClsList;
  nCls  := nClasses;
  while nCls DO
    RemSvrInit_Cls(pInfo^.pCls, pInfo^.pOld, 0);
    pInfo	+= sizeof(L2_ClsInfo);
    nCls  -= 1;
  end_while;

END_FUNCTION // ObjectReader::RemSvrInit

FUNCTION ObjectReader::RemSvrInit_Cls
VAR_INPUT
  pCls : ^ClsHdr;
	pObj		: ^Obj;
  usSwitch : usint;
END_VAR
VAR
  pNewObj : ^VirtualBase;
  uiCh			: UINT;
  uiSvr			: UINT;
  pChDsc		: ^ChDscEntry;
  ppCD			: ^ChDsc;
  pCh				: ^SvrCh;
END_VAR

  if( usSwitch = 0 )then  // nicht mehr das Objekt ermitteln, das ist schon geschehen!
		IF pObj = NIL THEN		// das 1. Objekt in diesem ON ermitteln
			pObj	:= pCls^.pFirstObj;
		ELSE
			pObj	:= pObj^.pNxtObj;
		END_IF;
  end_if;

    if( pCls^.pBaseCls <> NIL )then
      RemSvrInit_Cls( pCls^.pBaseCls, pObj, 1 );  // Rekursiver Aufruf mit bereits gefundenem Objekt
    end_if;

		WHILE pObj <> NIL DO	// alle Objekte/Klasse dieses ON durchlaufen
      pNewObj := LSL_GetPtr( pObj );
      
      uiSvr := pCls^.pDsc^.nSvrChs;
      uiCh	:= 0;
      ppCD	:= #pCls^.aDscChs[0];
      
      // alle Server der Klasse...
      while( uiCh < uiSvr )do
    
        pChDsc	:= ppCD^.pDsc;
        pCh := pNewObj + pChDsc^.uiOff;
        
        // so, der Server ist retentiv (zumindest so vorgesehen)
        if( pChDsc^.uiFlags and LDR_SVRTYPE_RETENTIVEFLAG )then
          // ein Speicherobjekt hat für diesen Server bereits existiert --> aus SRAM/File lesen und in ddata übernehmen
          if( pCh^.pSvrDsc$^RetSvr^.flags and LDR_SVRTYPE_EXISTED )then
            if( pChDsc^.uiFlags and LDR_SVRTYPE_RETENTIVEFILE )then
              pCh^.ddata := pCh^.pSvrDsc$^RetSvr^.pSaveObj$^RetSvrFile^.Data.Read();
            else
              pCh^.ddata := pCh^.pSvrDsc$^RetSvr^.pSaveObj$^RetSvrRAM^.Data.Read();
            end_if;
          end_if;
        end_if;
        uiCh += 1;
    
        ppCD	+= sizeof( ChDsc );
    
      end_while;
        
      pObj	:= pObj^.pNxtObj;
		END_WHILE;

END_FUNCTION

#endif

// Überspringt eine bestimmte Anzahl von 4 Byte Werten in der Tabelle
FUNCTION ObjectReader::SkipDints
	VAR_INPUT
		nbr 	: UDINT;
	END_VAR

	pTable += nbr * sizeof(DINT);

END_FUNCTION
