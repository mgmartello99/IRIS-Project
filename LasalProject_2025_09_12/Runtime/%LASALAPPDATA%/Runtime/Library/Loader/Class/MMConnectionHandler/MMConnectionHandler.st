//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "MMConnectionHandler"
	Revision           = "0.0"
	GUID               = "{AB090D79-C6A2-4E53-B744-415628D3FBE5}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(810,120)"
	Comment            = "Baut Verbindungen zu den Station auf&#13;&#10;Verbindet jede Remote Client-Server Verbindung inkl Refreshlisten Eintrag&#13;&#10;Ist für die Übertragung der Daten verantwortlich">
	<Channels>
		<Server Name="ClassSvr" GUID="{E4ABAE40-62B6-4C92-A88B-A410F4CBC70C}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FimLuc"/>
		<Dokumentation Revision="0.0" Date="2015-10-07" Author="FimLuc" Company="Sigmatek" Description="erstellt"/>
	</RevDoku>
</Class>
*)
MMConnectionHandler : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION RefreshAllStationState
		VAR_OUTPUT
			bAllConnected 	: BOOL;
		END_VAR;
				//! <Function Comment="Versucht zu jeder Station eine Verbingung auf zu bauen" Name="ConnectToAllStations"/>
	FUNCTION ConnectToAllStations
		VAR_OUTPUT
			bAllConnected 	: BOOL;
		END_VAR;
	
	FUNCTION ConnectToStation
		VAR_INPUT
			pStation 	: ^MMStation;
			bUser 	: BOOL;
		END_VAR
		VAR_OUTPUT
			bConnected 	: BOOL;
		END_VAR;
	
	FUNCTION DoThreadCmd
		VAR_INPUT
			pCmdLine 	: ^_MMThreadCmdLine;
		END_VAR;
	
	FUNCTION Initialize;
	
	FUNCTION StationCheckSvr
		VAR_INPUT
			pStation 	: ^MMStation;
		END_VAR
		VAR_OUTPUT
			bRead 	: BOOL;
		END_VAR;
				//! <Function Comment="Versucht eine Station zu verbinden" Name="StationConnect"/>
	FUNCTION StationConnect
		VAR_INPUT
			pStation 	: ^MMStation;			//! <Variable Comment="Zeiger auf die Station zu der eine Verbindung aufgebaut werden soll" Name="StationConnect.pStation"/>
			bUserStart 	: BOOL;
		END_VAR
		VAR_OUTPUT
			bConnected 	: BOOL;
		END_VAR;
	
	FUNCTION StationCRCChanged
		VAR_INPUT
			pStation 	: ^MMStation;
		END_VAR
		VAR_OUTPUT
			bChanged 	: BOOL;
		END_VAR;
	
	FUNCTION StationCreateRefreshListEntries
		VAR_INPUT
			pStation 	: ^MMStation;
		END_VAR;
	
	FUNCTION StationDisconnect
		VAR_INPUT
			pStation 	: ^MMStation;
			bUserStop 	: BOOL;
		END_VAR;
	
	FUNCTION StationFileCheckUsage
		VAR_INPUT
			pFilename 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			nRes 	: DINT;
		END_VAR;
	
	FUNCTION StationFileDeleteUnused;
	
	FUNCTION StationFileRead
		VAR_INPUT
			pStation 	: ^MMStation;
			udNewCrc 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bValid 	: BOOL;
		END_VAR;
	
	FUNCTION StationFileWrite
		VAR_INPUT
			pStation 	: ^MMStation;
		END_VAR;
	
	FUNCTION StationGetDescCrc
		VAR_INPUT
			pComDef 	: ^Comdef;
		END_VAR
		VAR_OUTPUT
			udCrC 	: UDINT;
		END_VAR;
	
	FUNCTION StationReset
		VAR_INPUT
			pStation 	: ^MMStation;
		END_VAR;
	
	FUNCTION SvrGetLasalId
		VAR_INPUT
			pSymbolServer 	: ^MMServer;
			pComDef 	: ^Comdef;
		END_VAR
		VAR_OUTPUT
			bValidLasalId 	: BOOL;
		END_VAR;
	
	FUNCTION ThreadMMConn
		VAR_INPUT
			pthis 	: ^void;
		END_VAR;
	
	FUNCTION ThreadMMConnHandler
		VAR_INPUT
			pthis 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL OnMultiMasterInit
		VAR_OUTPUT
			bHasObjects 	: BOOL;
		END_VAR;
	
	FUNCTION GetLoaderVersion
		VAR_INPUT
			pComDef 	: ^Comdef;
			pLoaderVersion 	: ^Revision;
		END_VAR;
	
	FUNCTION DoCheck4WriteCmds;
	
	FUNCTION SetServerStationStateFlag
		VAR_INPUT
			pStation 	: ^MMStation;
			bOnline 	: BOOL;
		END_VAR;
	
	FUNCTION ThreadMMComCB
		VAR_INPUT
			pthis 	: ^void;
		END_VAR;
	
	FUNCTION DoCheck4ReadCmds;
	
	FUNCTION GLOBAL OnMultiMasterStartThreads;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MMConnectionHandler::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MMCONNECTIONHANDLER
0$UINT, 0$UINT, (SIZEOF(::MMConnectionHandler))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2885323246), "MMConnectionHandler", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::MMConnectionHandler.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
END_FUNCTION


#define USER_CNT_MMConnectionHandler 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MMConnectionHandler] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MMConnectionHandler::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

#pragma usingLtd DebugIp
#pragma usingLtd MMServer
#pragma usingLtd MMStation

//{{LSL_IMPLEMENTATION
#include <LSL_ST_OSFILE.H>
#include <LSL_ST_LSLFILE.H>
#include <LSL_ST_MT.H>
#include <RTOS_Mem.h>
#include <LSL_StiTask.h>
#include ".\LoaderItf.h"

#define MailBox2Size              50   // anzahl der möglichen Nachrichten in der Mailbox
#define ThreadDelayTime           10   //ms
#define ThreadDelayTimeConnetion  250  //ms
#define ThreadDelayTimeComCB      10   //ms

#define MMB_HEADER_CHECK    16#6273722E // ".rsb" in HEX
#define MMB_VERSION         0$UDINT     // HI & LOW Byte für Version 
#define MMB_HEADER_OFFSET   12$UDINT    // start der daten in der datei

#define MAXPARAMLEN         254   // max. Anzahl Parameter in einem Ip-Befehl (ohne P_EOL)

#define DNYLIST_FIRST_IDX   1000  // Index an dem die dyn. Refreshliste beginnt

#pragma using MMStationReader
#pragma using MMServerReader
#pragma using MMServer

#ifdef MM_DEBUG
#include <LSL_ST_SYSMSG.h>
#endif

// struktur für mailbox kommandos
TYPE
   _TxCommandParams: STRUCT
      para      : ARRAY [0..99] OF USINT;	// parameters
      paraLen   : UDINT;                  // length of parameters
      result    : RESULTS; 		            // result buffer
      status    : IPRSTATES;              // status, result value of TxCommand
      reason    : comlinkReason;          // reason code in the case of an error
	 END_STRUCT;
   
   
   _UserCB: STRUCT
      pUserCallback     : ^void;
      pUserCallbackThis : ^void;
	 END_STRUCT;
   
END_TYPE

(******************************************************************
** private variables
******************************************************************)
VAR_GLOBAL//PRIVATE
  Thread2Handle           : MT_TASKHANDLE; // Thread Handle
  Thread2HandleConnection : MT_TASKHANDLE; // Thread Handle
  Thread2HandleComCB      : MT_TASKHANDLE; // Thread Handle
  MailBox2Handle          : MT_MAILBOX;   // mailbox handle
  mt_api                  : ^LSL_MT_TYPE; // multitask interface
  
  EventHandler       : MT_SEMAHANDLE;
  
  // MMStationReader
  m_pMultiMasterStationReader : ^MMStationReader;
  // liste die auf speicheradresse der MMServer-Objekte zeigt
  m_pMMServer       : ^void;
  
  // Usercallback
  m_pUserCallback      : ^void;
  m_nUserCallbackCount : UDINT;
  
  m_bConnectionThreadRunning : BOOL;
  
  m_pBufferIn      : ^void;
  m_udBufferInLen  : UDINT;
  m_pBufferOut     : ^void;
  m_udBufferOutLen : UDINT;
  m_pChgBytes       : ^void;
  m_udChgBytesLen   : UDINT;
  
  MM_firstInitActive : BOOL;

  
END_VAR

VAR_PRIVATE
#ifdef MM_DEBUG
  OS_pLslSysMsg : ^OS_LSLSYSMSG;
  LogBuf0 : ARRAY[0..99999] OF CHAR;
  hLog_mm : UDINT;
#endif  
END_VAR

(******************************************************************
** forward declarations
******************************************************************)
FUNCTION GLOBAL LDR_MM_UserCallbackPrototyp
VAR_INPUT
  pThis           : ^void;
  udStationId     : UDINT;
  szStationName   : ^CHAR;
  udServerHandle	: UDINT;
  szServerName  	: ^CHAR;
  udState 	      : _MMState;
END_VAR;

FUNCTION  ReadFromMultiMasterSymbol
VAR_INPUT
  lasalId    : UDINT;
	pComDef    : ^Comdef;
	pBuffer    : pVoid;
  pBufferLen : UDINT;
END_VAR
VAR_OUTPUT
	retVal : DINT;
END_VAR;

FUNCTION  WriteToMultiMasterSymbol
VAR_INPUT
  pHandle     : UDINT; 
	pComDef    : ^Comdef;
END_VAR
VAR_OUTPUT
	retVal : DINT;
END_VAR;


(******************************************************************
** Debug Funktionen
******************************************************************)
#ifdef MM_DEBUG
FUNCTION GLOBAL LDR_MM_Trace
VAR_INPUT
  fmt : ^CHAR;
  p1 : UDINT;
  p2 : UDINT;
  p3 : UDINT;
END_VAR
VAR
	buf : ARRAY[0..99] OF CHAR;
END_VAR

  _strcpy(#buf[0], "%08X ");
  _strcat(#buf[0], fmt);

  OS_SYSMSG_LPRINTFLN4(hLog_mm, 1, #buf[0], OS_SSR_CurrentTaskHandle(), p1, p2, p3);
END_FUNCTION

FUNCTION GLOBAL LDR_MM_Trace_s
VAR_INPUT
  fmt : ^CHAR;
  s1_ : ^CHAR;
  p1 : UDINT;
  p2 : UDINT;
END_VAR
VAR
	buf : ARRAY[0..99] OF CHAR;
END_VAR

  _strcpy(#buf[0], "%08X ");
  _strcat(#buf[0], fmt);

  OS_SYSMSG_LPRINTFLN4(hLog_mm, 1, #buf[0], OS_SSR_CurrentTaskHandle(), s1_$UDINT, p1, p2);
END_FUNCTION
#endif

(******************************************************************
** Helfer Funktionen
******************************************************************)
(*
  Ermittelt den gesuchten Server
  Falls Station des Servers Online ist!
  Liefert den Serverpointer wenn die LasalId gültig ist
  ansonsten NIL
*)
FUNCTION FindValidMultiMasterSymbol
	VAR_INPUT
		udStationId 	: UDINT;
		pszSvrName 	    : ^CHAR;
	END_VAR
	VAR_OUTPUT
		pSymbol 	: ^MMServer;
	END_VAR
  VAR
    pStation : ^MMStation;  
  END_VAR
    
   pSymbol := NIL;
 
  IF ((m_pMultiMasterStationReader <> NIL) & (pszSvrName <> NIL) & (m_pMMServer <> NIL)) THEN
    pStation := m_pMultiMasterStationReader^.GetStationAt(udStationId);
    IF ((pStation <> NIL) & (pStation^.IsReady() = true)) THEN
      pSymbol := MM_GetServer(udStationId, pszSvrName)$^MMServer;
    END_IF;
  END_IF;

END_FUNCTION

#if 0 // Funktion wird nirgends verwendet
(*
  Holt sich den ServerWert mittels I_READ
*)
FUNCTION  ReadFromMultiMasterSymbol
VAR_INPUT
  lasalId    : UDINT;
	pComDef    : ^Comdef;
	pBuffer    : pVoid;
  pBufferLen : UDINT;
END_VAR
VAR_OUTPUT
	retVal : DINT;
END_VAR
VAR
	para		  : _TxCommandParams;
END_VAR

  // nur wenn lasalID gütlig ist
	IF (lasalId <> 0) THEN

    // paramter erstellen
		para.para[0] := P_VARIA;
		para.para[1]$UDINT := lasalId;
		para.para[5] := P_EOL;

    // kommando absetzen
		para.status := TXCOMMANDEX( I_READ, 		    // command
                                6,              // paralen
                                #para.para[0],			  // parameters
                                pComDef,	      // identifies the channel
                                #para.result, 			  // result buffer
                                SIZEOF(para.result),	// size of result buffer
                                #para.reason			    // reason code in the case of an error
							                );
                          
    // falls gut gegangen, Wert in den Buffer kopieren                          
		IF (para.status = READY) THEN
      _memcpy(pBuffer, #para.result.aData, pBufferLen);
			retVal := 0;
		ELSE
			retVal := -1;
		END_IF;
	ELSE
		retVal := -1;
	END_IF;

END_FUNCTION // ReadFromMultiMasterSymbol
#endif

(*
  Schreibt den Werte mittels I_WRITE auf den MultiMasterServer
*)
FUNCTION  WriteToMultiMasterSymbol
VAR_INPUT
  pHandle     : UDINT; 
	pComDef    : ^Comdef;
END_VAR
VAR_OUTPUT
	retVal : DINT;
END_VAR
VAR
	para		  : _TxCommandParams;
  pSvrObj     : ^MMServer;
END_VAR

	IF (pHandle <> 0) THEN
    
    pSvrObj := pHandle$^MMServer;
  
		para.paraLen := 0;
  
    para.para[para.paraLen]$UDINT := pSvrObj^.m_udLasalId;
    para.paraLen += SIZEOF(UDINT);
    
    para.para[para.paraLen]$USINT := P_IMMED;
    para.paraLen += SIZEOF(USINT);
    
    pSvrObj^.GetBufferAt(MM_BufferOut, #para.para[para.paraLen], SIZEOF(UDINT), 0);
    para.paraLen += SIZEOF(UDINT);
    
    para.para[para.paraLen]$USINT := P_EOL;
    para.paraLen += SIZEOF(USINT);

		para.status := TXCOMMANDEX( I_WRITE, 		          // command
                                para.paraLen,         // paralen
                                #para.para[0],			  // parameters
                                pComDef,	            // identifies the channel
                                #para.result, 			  // result buffer
                                SIZEOF(para.result),	// size of result buffer
                                #para.reason			    // reason code in the case of an error
                               );
                               
		IF (para.status = READY) THEN
			retVal := 0;
		ELSE
			retVal := -1;
		END_IF;

	ELSE
		retVal := -1;
	END_IF;

END_FUNCTION // WriteToMultiMasterSymbol
(*
  Sendet das NewInst Kommando
*)
FUNCTION SendNewInst
	VAR_INPUT
    pHandle     : UDINT; 
		pNewInstParams 	: ^sNewInst;
	END_VAR
  VAR
  	pSvrObj   : ^MMServer;
    para      : ARRAY [0..99] OF USINT;
    reason    : comlinkReason;          // reason code in the case of an error
  END_VAR

  IF (pHandle = 0) THEN
    RETURN;
  END_IF;
  
  pSvrObj := pHandle$^MMServer;

  // Station wegen ComDef holen
  IF (pSvrObj^.m_pStation <> NIL) THEN
    
    pSvrObj^.m_pStation$^MMStation^.ComDefLock();
    
    // parameter zusammenstellen
    para[0]$UDINT := pSvrObj^.m_udLasalId;
    para[4]$UINT  := pNewInstParams^.Para.uiCmd;       // NewInst. number 

    para[6]$USINT := P_USER_STREAM;
    _memcpy(#para[7], #pNewInstParams^.Para.aPara, sizeof(pNewInstParams^.Para.aPara));
    para[7+sizeof(pNewInstParams^.Para.aPara)] := P_EOL;

    MM_TRACE("SendNewInst: calling TXCOMMANDEX(I_CMD)", 0, 0, 0);

     //  New Inst kommando absetzen
    pNewInstParams^.IprState := TXCOMMANDEX
                              ( I_CMD, 	                                      // command
                                8+sizeof(pNewInstParams^.Para.aPara) ,        // para len
                                #para[0],			                                // parameters
                                pSvrObj^.m_pStation$^MMStation^.GetComDef(),	            // identifies the channel
                                #pNewInstParams^.Results,                     // result buffer
                                SIZEOF(pNewInstParams^.Results),	            // size of result buffer
                                #reason			                                  // reason code in the case of an error
                              );

    MM_TRACE("SendNewInst: TXCOMMANDEX(I_CMD), ret=%d", pNewInstParams^.IprState, 0, 0);
                              
//              IF (pNewInstParams^.used = fromNewInst) THEN
//                pNewInstParams^.used := sentNewInst;
//              ELSIF(pNewInstParams^.used = fromGetState) THEN
//                pNewInstParams^.used := sentGetState;
//              END_IF;

    // falls geglückt                        
//              IF (pNewInstParams^.IprState = READY) THEN
      pNewInstParams^.used := finishedNewInst;
//              END_IF;

    pSvrObj^.m_pStation$^MMStation^.ComDefUnlock();

  END_IF;

END_FUNCTION
(*
  Liest die Daten aus MultiMaster-Data-In, die mit dem NewInst Befehl READ_DATA gelesen werden
  muss ausserhalb gemutext werden
*)
FUNCTION ReadString
  VAR_INPUT
    pHandle    : UDINT; 
	  pComDef    : ^Comdef;
  END_VAR
  VAR_OUTPUT
    status    : DINT; 
  END_VAR 
  VAR
    para		    : _TxCommandParams;
    pSvrObj     : ^MMServer;
    udStringLenNew : UDINT;
    udStringLen : UDINT;
    udReadLen   : UDINT;
    udSize      : UDINT;
    udLen       : UDINT;
  END_VAR

  status := READY;
  
  IF (pHandle = 0) THEN
    RETURN;
  END_IF;
  
  pSvrObj := pHandle$^MMServer;
 
  // parameter zusammenstellen
  para.para[0]$UDINT := pSvrObj^.m_udLasalId;
  para.para[4]$UINT  := VirtualBaseInit::READ_DATA;       // NewInst. number 
  para.para[6] := P_EOL;

  // kommando absetzen
  para.status := TXCOMMANDEX( I_CMD, 		  // command
                              7,              // para len
                              #para.para[0],			  // parameters
                              pComDef,	      // identifies the channel
                              #para.result, 			  // result buffer
                              SIZEOF(para.result),	// size of result buffer
                              #para.reason			    // reason code in the case of an error
                            );
  // falls geglückt                        
  IF (para.status = READY) THEN
  
    udLen := para.result.uiLng - 2 - 4; // - sizeof(wLen) - sizeof(dwStringLen) ;
    udSize := (sizeof(para.result.aData) - sizeof(UDINT));
    
    udReadLen := udLen;
    IF (udLen > udSize) THEN
      udReadLen := udSize;
    END_IF;
    
    udStringLen := para.result.aData[0]$UDINT;
   
    udStringLenNew := udStringLen;
    
    IF udStringLenNew = 0 THEN
      // nothing to read
      pSvrObj^.WriteBufferOff(MM_BufferIn, udStringLenNew, 0, udStringLenNew$^USINT);
      RETURN;
    END_IF;
    
    IF (m_pBufferIn = NIL) THEN
      m_pBufferIn := _alloc_resize_LDR(udStringLenNew);
      m_udBufferInLen := udStringLenNew;
    ELSIF (m_udBufferInLen < udStringLenNew) THEN
      m_pBufferIn := _realloc_LDR(m_pBufferIn, udStringLenNew);
      m_udBufferInLen := udStringLenNew;
    END_IF;

    IF (m_pBufferIn = NIL) THEN
      // speicher konnte nicht allokiert werden
      status := ERROR;
      pSvrObj^.AddStatus(MM_OUTOFMEMORY);
      RETURN;
    END_IF;

    _memcpy(m_pBufferIn, #para.result.aData[4], udReadLen);

    IF ((udStringLen <> udReadLen) & (udReadLen <> (udSize - 1)))	THEN // Wenn Ok und Restlänge & Restbuffer, dann weiterlesen

      para.para[0]$UDINT := pSvrObj^.m_udLasalId;
      para.para[4]$UINT  := VirtualBaseInit::READ_DATA_OFF;       // NewInst. number 
      para.para[6]$USINT := P_IMMED;
      para.para[7]$UDINT := 0;   // offset;
      para.para[11]$UDINT := P_EOL;

      WHILE (TRUE) DO
        
        udStringLen -= udReadLen;
        
        IF (udStringLen <= 0) THEN
          EXIT;
        END_IF;

        para.para[7]$UDINT += udReadLen;
        // kommando absetzen
        para.status := TXCOMMANDEX( I_CMD, 		  // command
                                    13,              // para len
                                    #para.para[0],			  // parameters
                                    pComDef,	      // identifies the channel
                                    #para.result, 			  // result buffer
                                    SIZEOF(para.result),	// size of result buffer
                                    #para.reason			    // reason code in the case of an error
                                  );
        // falls geglückt                        
        IF (para.status = READY) THEN
        
            udLen := para.result.uiLng - 2; // - sizeof(wLen);
            udSize := (sizeof(para.result.aData) - sizeof(UDINT));
          
            udReadLen := udLen;
            IF (udLen > udSize) THEN
              udReadLen := udSize;
            END_IF;
            
           _memcpy(m_pBufferIn + para.para[7]$UDINT, #para.result.aData[0], udReadLen);
             
        ELSE
          status := ERROR;
          pSvrObj^.AddStatus(MM_READFAILED);
          EXIT;
        END_IF;
        
      END_WHILE;
        
    END_IF; 
    
    pSvrObj^.WriteBufferOff(MM_BufferIn, udStringLenNew, 0, m_pBufferIn$^USINT);

  ELSE
  status := ERROR;
  pSvrObj^.AddStatus(MM_READFAILED);
  END_IF;
      
END_FUNCTION
(*
  NewInst Befehl WRITE_DATA für StringServer
*)
FUNCTION WriteString
  VAR_INPUT
    pHandle    : UDINT; 
	  pComDef    : ^Comdef;
  END_VAR
  VAR_OUTPUT
    status    : DINT; 
  END_VAR 
  VAR
    para		  : _TxCommandParams;
    udLen     : UDINT;
    udOffest  : UDINT;
    udWrite   : UDINT;
    pSvrObj   : ^MMServer;
    bClear    : BOOL;
  END_VAR

  status := 0;
  
  IF (pHandle = 0) THEN
    RETURN;
  END_IF;

  pSvrObj := pHandle$^MMServer;
 
  udLen := pSvrObj^.GetBufferLen(MM_BufferOut);
  
  bClear := (udLen = 0);
 
  udOffest := 0;
  
  IF (bClear = FALSE) THEN
    IF (m_pBufferOut = NIL) THEN
      m_pBufferOut := _alloc_resize_LDR(udLen);
      m_udBufferOutLen := udLen;
    ELSIF (m_udBufferOutLen < udLen) THEN
      m_pBufferOut := _realloc_LDR(m_pBufferOut, udLen);
      m_udBufferOutLen := udLen;
    END_IF;
    
    IF (m_pBufferOut = NIL) THEN
      // speicher konnte nicht allokiert werden
      status := ERROR;
      pSvrObj^.AddStatus(MM_OUTOFMEMORY);
      RETURN;
    END_IF;

    // gesamte daten holen
    pSvrObj^.GetBufferAt(MM_BufferOut, m_pBufferOut$^USINT, udLen, 0);
  END_IF;
  
  WHILE ((udLen > 0) | (bClear = TRUE))DO

    IF ((udLen > 60)) THEN
      udWrite := 60;
    ELSE
      udWrite := udLen;
    END_IF;
    
    IF (bClear = TRUE) THEN
      udWrite := 1;
    END_IF;

    IF ((udWrite + 15) > MAXPARAMLEN) THEN
      status := -1;	
      EXIT;
    END_IF;

    // parameter zusammenstellen
    para.paraLen := (2 + 1 + 15 + udWrite);
    para.para[0]$UDINT := pSvrObj^.m_udLasalId;
    para.para[4]$UINT  := VirtualBaseInit::WRITE_DATA_OFF;       // NewInst. number 
    para.para[6]$USINT := P_USER_STREAM;
    para.para[7]$UDINT := udWrite;
    para.para[11]$UDINT := udOffest;   // offset

    IF (bClear = TRUE) THEN
      // nur 0
      para.para[15] := 0;
    ELSE
      _memcpy(#para.para[15], m_pBufferOut + udOffest, udWrite);
    END_IF;

   
    para.para[15 + udWrite]$USINT := P_EOL;

    //  kommando absetzen
    para.status := TXCOMMANDEX( I_CMD, 		            // command
                                para.paraLen,         // para len
                                #para.para[0],			  // parameters
                                pComDef,	            // identifies the channel
                                #para.result, 			  // result buffer
                                SIZEOF(para.result),	// size of result buffer
                                #para.reason			    // reason code in the case of an error
                              );
                         
    IF (para.status <> READY) THEN
      status := ERROR;	
      pSvrObj^.AddStatus(MM_SENDFAILED);
      EXIT;
    END_IF;
    
    IF (bClear = TRUE) THEN
      bClear := FALSE;
    ELSE
      udLen -= udWrite;
      udOffest += udWrite;
    END_IF;
  
 END_WHILE;

END_FUNCTION
(*
  Schreibt die Daten aus MultiMaster-Data-In, für MerkerEx Server die mit dem Befehl I_GET_DATA gelesen werden
*)
FUNCTION ReadDataMerkerEx
  VAR_INPUT
    pHandle    : UDINT; 
	  pComDef    : ^Comdef;
  END_VAR
  VAR_OUTPUT
    status    : DINT; 
  END_VAR 
  VAR
    pSvrObj     : ^MMServer;
    udNewSize   : UDINT;
    udSize      : UDINT;
    para		  : _TxCommandParams;
    udOffest  : UDINT;
    udRead    : UDINT;
    udHandle  : UDINT;
    udBufferLen : UDINT;
    udMax     : UDINT;
  END_VAR

  status := -1;
  
  IF (pHandle = 0) THEN
    RETURN;
  END_IF;

  
  pSvrObj := pHandle$^MMServer;
  
  IF ((pSvrObj^.m_pStation = NIL) | (pSvrObj^.m_pStation$^MMStation^.m_bLdrVersionOk = FALSE))THEN
    RETURN;
  END_IF;
  
  udBufferLen := pSvrObj^.GetBufferLen(MM_BufferIn);

  // parameter zusammenstellen
  para.para[0]$UDINT  := pSvrObj^.m_udLasalId;
  para.para[4]        := 0;  // read  
  para.para[5]$UDINT  := pSvrObj$UDINT;  
  para.para[9]$UDINT  := udBufferLen;
  
    // kommando absetzen
  para.status := TXCOMMANDEX( I_INIT_MERKEREX, 		  // command
                              13,              // para len
                              #para.para[0],			  // parameters
                              pComDef,	      // identifies the channel
                              #para.result, 			  // result buffer
                              SIZEOF(para.result),	// size of result buffer
                              #para.reason			    // reason code in the case of an error
                            );
  // falls geglückt                        
  IF ((para.status <> READY) | para.result.uiLng < 0) THEN
    status := ERROR;
    pSvrObj^.AddStatus(MM_READFAILED);
  ELSE  
    udHandle := para.result.aData[0]$UDINT;
    udSize := para.result.aData[4]$UDINT;
    status := 0;
  END_IF;


  IF (status = 0) THEN
   
    IF (udHandle <> 0) THEN
    
      IF udSize = 0 THEN
        // nothing to read
        pSvrObj^.SetBufferSizeForce(MM_BufferIn, 0);
        RETURN;
      END_IF;
      
      IF (m_pBufferIn = NIL) THEN
        m_pBufferIn := _alloc_resize_LDR(udSize);
        m_udBufferInLen := udSize;
      ELSIF (m_udBufferInLen < udSize) THEN
        m_pBufferIn := _realloc_LDR(m_pBufferIn, udSize);
        m_udBufferInLen := udSize;
      END_IF;
      
      IF (m_pBufferIn = NIL) THEN
        status := ERROR;
        pSvrObj^.AddStatus(MM_OUTOFMEMORY);
        RETURN;
      END_IF;
      
      udNewSize := udSize;
      
      udMax := sizeof(results.aData) - 2;
 
      udOffest := 0;
      WHILE (udSize > 0) DO

        IF ((udSize > udMax)) THEN
          udRead := udMax;
        ELSE
          udRead := udSize;
        END_IF;

        // parameter zusammenstellen
        //<I_MERKEREX> <>
        //   0 1 2 3                        4 5 6 7     8 9 10 11   12 13 14 15  ab 16
        //  <Handle from I_INIT_MERKEREX>  <Callerid>  <datalen>   <offset>     <data>

        para.para[0]$UDINT  := udHandle;
        para.para[4]$UDINT  := pSvrObj$UDINT;
        para.para[8]$UDINT  := udRead$UDINT;         
        para.para[12]$UDINT := udOffest$UDINT; 
        
        // kommando absetzen
        para.status := TXCOMMANDEX( I_MERKEREX, 		      // command
                                    16,                   // para len
                                    #para.para[0],			  // parameters
                                    pComDef,	            // identifies the channel
                                    #para.result, 			  // result buffer
                                    SIZEOF(para.result),	// size of result buffer
                                    #para.reason			    // reason code in the case of an error
                                  );
        // falls geglückt                        
        IF ((para.status <> READY) | para.result.uiLng < 0) THEN
          status := ERROR;
          pSvrObj^.AddStatus(MM_READFAILED);
          EXIT;
        ELSE
          // daten kopieren
          udRead := para.result.uiLng - 2;
          _memcpy(m_pBufferIn + udOffest, #para.result.aData[0], cntr:=udRead); 
        END_IF;

        udSize -= udRead;
        udOffest += udRead;

     END_WHILE;
     
     // daten geblockt in buffer schreiben
     pSvrObj^.SetBufferSizeForce(MM_BufferIn, udNewSize);
     pSvrObj^.WriteBufferOff(MM_BufferIn, udNewSize, 0, m_pBufferIn$^USINT);
     
    END_IF;
    
    
  END_IF;
    
END_FUNCTION
(*
  Schreibt die Daten aus MultiMaster-Data-Out, für MerkerEx Server die mit dem Befehl I_SET_DATA 
*)
FUNCTION WriteDataMerkerEx
  VAR_INPUT
    pHandle    : UDINT; 
	  pComDef    : ^Comdef;
  END_VAR
  VAR_OUTPUT
    status    : DINT; 
  END_VAR 
  VAR
    pSvrObj   : ^MMServer;
    udMax     : UDINT;
    udSize    : UDINT;
    udPartSize : UDINT;
    para		  : _TxCommandParams;
    udOffest  : UDINT;
    udWrite   : UDINT;
    udHandle  : UDINT;
    foundChange : UDINT;
  END_VAR

  status := -1;
  
  IF (pHandle = 0) THEN
    RETURN;
  END_IF;

  
  pSvrObj := pHandle$^MMServer;
  
  IF ((pSvrObj^.m_pStation = NIL) | (pSvrObj^.m_pStation$^MMStation^.m_bLdrVersionOk = FALSE))THEN
    RETURN;
  END_IF;

  udSize := pSvrObj^.GetBufferLen(MM_BufferOut);

  IF (m_pBufferOut = NIL) THEN
    m_pBufferOut := _alloc_resize_LDR(udSize);
    m_udBufferOutLen := udSize;
  ELSIF (m_udBufferOutLen < udSize) THEN
    m_pBufferOut := _realloc_LDR(m_pBufferOut, udSize);
    m_udBufferOutLen := udSize;
  END_IF;
  
  IF (m_pBufferOut = NIL) THEN
    status := ERROR;
    pSvrObj^.AddStatus(MM_OUTOFMEMORY);
    RETURN;
  END_IF;

  IF (m_pChgBytes = NIL) THEN
    m_pChgBytes := _alloc_resize_LDR(udSize);
    m_udChgBytesLen := udSize;
  ELSIF (m_udChgBytesLen < udSize) THEN
    m_pChgBytes := _realloc_LDR(m_pChgBytes, udSize);
    m_udChgBytesLen := udSize;
  END_IF;
  
  IF (m_pChgBytes = NIL) THEN
    status := ERROR;
    pSvrObj^.AddStatus(MM_OUTOFMEMORY);
    RETURN;
  END_IF;

  // gesamte daten und die Info wo was geschrieben wurde holen
  pSvrObj^.GetBufferAtWithChgBytes(MM_BufferOut, m_pBufferOut$^USINT, udSize, 0, m_pChgBytes$^USINT);

  udOffest := 0;

NextPart:
  // von udOffset weg das Ende des nächsten zu sendenden Teils suchen
  udPartSize := udOffest;
  foundChange := 0;
  WHILE udPartSize < udSize DO
    IF (m_pChgBytes$^USINT + udPartSize)^ = 0 THEN
      IF foundChange THEN
        EXIT;
      END_IF;
    ELSE
      foundChange := 1;
    END_IF;  
    udPartSize += 1;
  END_WHILE;
  
  IF foundChange = 0 THEN
    status := 0;
    RETURN;
  END_IF;

  // parameter zusammenstellen
  para.para[0]$UDINT  := pSvrObj^.m_udLasalId;
  para.para[4]        := 1;  // write  
  para.para[5]$UDINT  := pSvrObj$UDINT;  
  para.para[9]$UDINT  := udPartSize;
  
    // kommando absetzen
  para.status := TXCOMMANDEX( I_INIT_MERKEREX, 		  // command
                              13,              // para len
                              #para.para[0],			  // parameters
                              pComDef,	      // identifies the channel
                              #para.result, 			  // result buffer
                              SIZEOF(para.result),	// size of result buffer
                              #para.reason			    // reason code in the case of an error
                            );
  // falls geglückt                        
  IF ((para.status <> READY) | para.result.uiLng < 0) THEN
    status := ERROR;
    pSvrObj^.AddStatus(MM_SENDFAILED);
  ELSE  
    udHandle := para.result.aData[0]$UDINT;
    status := 0;
  END_IF;

  
  IF (status = 0) THEN
    
    udMax := MAXPARAMLEN - 16;
    
    IF (udHandle <> 0) THEN
      
      foundChange := 0;
      WHILE (udOffest < udPartSize) DO
      
        // Das was nicht geändert wurde überspringen
        WHILE ((m_pChgBytes$^USINT + udOffest)^ = 0) & (udOffest < udPartSize) DO
          udOffest += 1;
        END_WHILE;
        
        IF ((udPartSize - udOffest) > udMax) THEN
          udWrite := udMax;
        ELSE
          udWrite := udPartSize - udOffest;
        END_IF;

        IF ((udWrite + 16) > MAXPARAMLEN) THEN
          status := -1;	
          RETURN;
        END_IF;

        // parameter zusammenstellen
        //<I_MERKEREX> <>
        //   0 1 2 3                        4 5 6 7     8 9 10 11   12 13 14 15  ab 16
        //  <Handle from I_INIT_MERKEREX>  <Callerid>  <datalen>   <offset>     <data>

        para.para[0]$UDINT  := udHandle;
        para.para[4]$UDINT  := pSvrObj$UDINT;
        para.para[8]$UDINT  := udWrite$UDINT;         
        para.para[12]$UDINT := udOffest$UDINT; 
        
        _memcpy(#para.para[16], m_pBufferOut + udOffest, udWrite);

        // kommando absetzen
        para.status := TXCOMMANDEX( I_MERKEREX, 		  // command
                                    16+udWrite,              // para len
                                    #para.para[0],			  // parameters
                                    pComDef,	      // identifies the channel
                                    #para.result, 			  // result buffer
                                    SIZEOF(para.result),	// size of result buffer
                                    #para.reason			    // reason code in the case of an error
                                  );
        // falls geglückt                        
        IF ((para.status <> READY) | para.result.uiLng < 0) THEN
          status := ERROR;
          pSvrObj^.AddStatus(MM_SENDFAILED);
          EXIT;
        ELSE
          udWrite := para.result.uiLng - 2;
        END_IF;

        udOffest += udWrite;

      END_WHILE;
     
      // Prüfen, ob noch was zu senden ist
      IF status = 0 THEN
        GOTO NextPart;          
      END_IF;
     
    END_IF;
    
  END_IF;
  
END_FUNCTION
(*
  Es wird einmal für alles ein Usercallback ausgeführt
*)
FUNCTION InvokeUserCallback
	VAR_INPUT
		pUserCB 	: ^_UserCB;
	END_VAR
  VAR
  	iSvr            : UDINT; // schleifenzähler  	
    cntServer       : UDINT; // Anzahl der Server
    pServer 	      : ^MMServer; // Zeiger auf Server
    iStat            : UDINT; // schleifenzähler
    cntStations     : UDINT; // Anzahl der Stationen
    pStation 	      : ^MMStation; // Zeiger auf Station
    pIterSvr        : ^void;
  END_VAR
  
  pStation := NIL;
  
  IF ((m_pMultiMasterStationReader = NIL) | (pUserCB= NIL) | (pUserCB^.pUserCallback = NIL)| (pUserCB^.pUserCallbackThis = NIL))THEN
    RETURN;
  END_IF;
  
  // Anzahl der Stationen
  cntStations := m_pMultiMasterStationReader^.GetStationsCount();
  
  // alle Stationen durchlaufen
  IF ((cntStations > 0) & (cntStations < -1$UDINT)) THEN
    cntStations -= 1;
    FOR iStat:=0 TO cntStations BY 1 DO
      pStation := m_pMultiMasterStationReader^.GetStationAt(iStat);
      IF (pStation <> NIL) THEN
      
        // für alle stationen einaml den callback ausführen
        pUserCB^.pUserCallback$LDR_MM_UserCallbackPrototyp(pUserCB^.pUserCallbackThis, pStation^.GetId(), #pStation^.m_szName[0], 0, NIL, pStation^.m_udState$_MMState); 
              
        IF (pStation^.m_udState$_MMState = _MMState::Online_NotAllServerAvailable) THEN
          // nur wenn der State Online_NotAllServerAvailable ist einmal für alle nicht gefundenen Server den Callback auslösen
            pServer := NIL;
            
            cntServer := pStation^.GetSvrCount();
             
            IF ((cntServer > 0) & (cntServer < -1$UDINT) & (m_pMMServer <> NIL)) THEN
              cntServer -= 1;
              pIterSvr := m_pMMServer + (pStation^.GetSvrStartIdx() * sizeof(UDINT));
              FOR iSvr:=0 TO cntServer BY 1 DO
                pServer := pIterSvr^$^MMServer;
                IF (pServer <> NIL) THEN
                  IF (pServer^.m_udLasalId <= 0) THEN
                      
                      pUserCB^.pUserCallback$LDR_MM_UserCallbackPrototyp(pUserCB^.pUserCallbackThis, pStation^.GetId(), #pStation^.m_szName[0], pServer$UDINT, #pServer^.m_szServerName[0], _MMState::SvrNotFoundAtStation); 

                  END_IF;
                END_IF;
                pIterSvr += sizeof(UDINT);
              END_FOR;
            END_IF;
            
        END_IF;
      
      END_IF;
    END_FOR;
  END_IF;
  
    
END_FUNCTION


(* Stellt den Befehl zum Löschen des Servers aus der Refreshliste in die Mailbox *)
FUNCTION LaunchDelFromRfl
  VAR_INPUT
    pSvrObj 	: ^MMServer;
  END_VAR
  VAR
    cmd       : _MMThreadCmdLine;
  END_VAR

  cmd.cmd := MM_DELFROMRFL;
  cmd.SvrHandle := pSvrObj$UDINT;
  cmd.udStationId := -1$UDINT;
  
  IF(MMThread_AddCmd(#cmd) <> 1) THEN
    MM_TRACE("LaunchDelFromRfl Er", 0, 0, 0);
  END_IF;

END_FUNCTION

(*
  Setzt das Status Flag des Servers
*)
FUNCTION UpdateSvrInitialiezedFlag
	VAR_INPUT
		pSvrObj 	: ^MMServer;
	END_VAR
  
  IF ((pSvrObj = NIL) | (pSvrObj^.m_pStation = NIL)) THEN
    RETURN;
  END_IF;

  IF (pSvrObj^.IsInitializedFlagSet() = FALSE) THEN
    pSvrObj^.SetInitialized();
    pSvrObj^.m_pStation$^MMStation^.DecreaseSvrInitCnt();
  END_IF;

  IF (pSvrObj^.m_uiPriority = MM_GetValueOnce) THEN 
    // Befehl zum Löschen des Servers aus der Refreshliste in die Mailbox stellen.
    LaunchDelFromRfl(pSvrObj);
  END_IF;
  
  pSvrObj^.AddStatus(MM_VALID_VALUE);

END_FUNCTION

(* Löscht den Server aus der Refreshliste mit einem TXUPD Aufruf *)
FUNCTION DoDelFromRfl
  VAR_INPUT
    pSvrObj 	: ^MMServer;
  END_VAR
  VAR
    Lslcommregdata   : Lslcommregdata; 
  END_VAR
  
  pSvrObj^.m_pStation$^MMStation^.ComDefLock();
  
  IF ((pSvrObj <> NIL) & (pSvrObj^.m_pStation <> NIL)) THEN
    Lslcommregdata.LASALID := 0;
    // Pos in der Liste  
    Lslcommregdata.VarPos := pSvrObj^.m_uiReflistOff;
    // Server Channel auf 0 setzen 
    Lslcommregdata.channel := 0;
    // Bei der Refreshzeit wird das spezielle Bit für eine globale Variable gesetzt. Das ist 
    // notwendig, weil sonst der Loader bei der Bearbeitung des CMD_TXUPD Befehls abstürzt, 
    // weil ein GetdataBufferFlag Aufruf mit einem NULL-Pointer gemacht wird.
    Lslcommregdata.uiTIME := 16#4000;
    Lslcommregdata.VarlistID := 0;
    // Update der rfl
    TXUPD(#Lslcommregdata, pSvrObj^.m_pStation$^MMStation^.GetComDef());
  ELSE
    MM_TRACE("DoDelFromRfl: no server or station !", 0, 0, 0);
  END_IF;

  pSvrObj^.m_pStation$^MMStation^.ComDefUnlock();
  
END_FUNCTION

(******************************************************************
** Threading Funktionen
******************************************************************)
(*
  Fügt ein Kommando zu der Mailbox hinzu, damit das Kommando im 
  RmThread ausgeführt werden kann 
*)
FUNCTION __CDECL GLOBAL MMThread_AddCmd
VAR_INPUT
  pCmd : ^_MMThreadCmdLine;
END_VAR
VAR_OUTPUT
  retCode : DINT;
END_VAR
  
  retcode := false;
  
  IF (Thread2Handle = NIL) THEN
    // kein THread zum abarbeiten der kommandos da
    RETURN;
  END_IF;
  
  IF ((pCmd^.cmd <> MM_NONE) & (MailBox2Handle <> NIL))THEN
    retCode := OS_MT_PUTCOND(MailBox2Handle, pCmd);
  END_IF;
  
  IF (retCode <> 1) THEN
    IF (pCmd^.SvrHandle <> 0) THEN
      TRACE0_ERR("To many multimaster commands. Failed to execute Write or NewInst to server '{0}'.", LSL_GetObjName(pCmd^.SvrHandle$^VirtualBase));
    ELSE
      TRACE_ERR("To many multimaster commands. Failed to execute command.");
    END_IF;
  END_IF;

  
END_FUNCTION
(*
  Callack-Funktion der Refreshliste
*)
FUNCTION GLOBAL __CDECL ComlinkCallback
VAR_INPUT
  pComdef  : ^COMDEFT;
  pData    : ^d2LSE;
END_VAR
VAR
  pSvrObj          : ^MMServer;
END_VAR
   
   // index in der MultiMasterData Struktur
   pSvrObj := pData^.VarlistID$^MMServer;
  
   // Daten in Struktur schreiben
   pSvrObj^.m_OpsAbs := ops.tAbsolute;
   pSvrObj^.m_uiReflistOff := pData^.uiOffs;

   // Falls String, dann noch den StringWert via NewInst holen
   IF (pSvrObj^.m_flServerType <> _MM_CHTY_4BYTE) THEN
      pSvrObj^.m_bReadReq := TRUE;
      pSvrObj^.m_bReadNotify := TRUE;
   ELSE
      pSvrObj^.WriteBufferOff(MM_BufferIn, sizeof(UDINT), 0, #pData^.data$USINT);
      UpdateSvrInitialiezedFlag(pSvrObj);
   END_IF;

END_FUNCTION
(*
  Thread für die MMConnectionHandler
*)
(******************************************************************
** globale Hilfsfunktionen für Multimaster Klassen
******************************************************************)
(*
  erstellt aus StationsID und Servernamen den Objektnamen 
*)
FUNCTION GLOBAL CreateMMServerObjName
  VAR_INPUT
    udStation       : UDINT; 
    pszSvrName      : ^CHAR;
    pOut_szObjName  : ^CHAR;
  END_VAR
  VAR
  	pStation : ^MMStation;
    udStlen  : UDINT;
    udSvrLen : UDINT;
    acObjName : ARRAY[ 0..NLNG ] OF CHAR;
  END_VAR

  pOut_szObjName^ := 0;
  
  IF (m_pMultiMasterStationReader = NIL) THEN
    RETURN;
  END_IF;

  pStation := m_pMultiMasterStationReader^.GetStationAt(udStation);
  
  IF (pStation = NIL) THEN
    RETURN;
  END_IF;

  _strcpy(#acObjName[0] , #pStation^.m_szName[0]);
  udStlen := _strlen(#acObjName[0]);
  
  acObjName[udStlen] := '.';
  
  udSvrLen := _strlen(pszSvrName);
  
  _memcpy(#acObjName[udStlen+1], pszSvrName, udSvrLen);
   
  acObjName[udStlen+1+udSvrLen] := 0;
  
  _memcpy(pOut_szObjName, #acObjName[0], udStlen+udSvrLen+2);

END_FUNCTION
(*
  Gets Station
*)
FUNCTION GLOBAL MM_GetStation
  VAR_INPUT
    id    : UDINT; 
  END_VAR
  VAR_OUTPUT
    pStation : ^void;
  END_VAR

  pStation := NIL;
  IF (m_pMultiMasterStationReader <> NIL) THEN
    pStation := m_pMultiMasterStationReader^.GetStationAt(id);
  END_IF;

END_FUNCTION
(*
  Gets ServerObject 
*)
FUNCTION GLOBAL MM_GetServer
  VAR_INPUT
    StationId   : UDINT;
    pszSvrName  : ^Char;  
  END_VAR
  VAR_OUTPUT
    pSrv : ^void;
  END_VAR
  VAR
    acObjName : ARRAY[ 0..NLNG ] OF CHAR;
  END_VAR
  
  CreateMMServerObjName(StationId, pszSvrName, #acObjName[0]);
  pSrv := _LookUpObj(#acObjName[0]);
   
END_FUNCTION
(*
  Invokes UserCallback für Server
*)
FUNCTION GLOBAL MM_InvokeUserCallbackServer
  VAR_INPUT
    udServerHandle	: UDINT;
    udState 	      : UDINT; 
  END_VAR
  
  IF(udServerHandle > 0) THEN
    MM_InvokeUserCallback(udServerHandle$^MMServer^.m_pStation$^MMStation^.GetId(), udServerHandle, udState);
  END_IF;
  
 END_FUNCTION 
(*
  Invokes UserCallback
*)
FUNCTION GLOBAL MM_InvokeUserCallback
  VAR_INPUT
    udStationId     : UDINT;
    udServerHandle	: UDINT;
    udState 	      : UDINT; 
  END_VAR
  VAR
  	pStation        : ^MMStation;
    pServer         : ^MMServer;
    pUserCB         : ^_UserCB;
    nItrUserCB      : UDINT;
    nEnd            : UDINT;
  END_VAR

  IF (m_nUserCallbackCount = 0) THEN
    RETURN;
  END_IF;


  pStation := NIL;
  pServer := NIL;
  
 IF ((m_pMultiMasterStationReader <> NIL) & (m_pUserCallback <> NIL)) THEN
    pStation := m_pMultiMasterStationReader^.GetStationAt(udStationId);
    IF (udServerHandle > 0) THEN
       pServer := udServerHandle$^MMServer;
    END_IF;

    IF (pStation <> NIL) THEN
     nEnd := m_nUserCallbackCount - 1;
     pUserCB := m_pUserCallback$^_UserCB;
     FOR nItrUserCB := 0 TO nEnd BY 1 DO
        IF (pServer <> NIL) THEN
           pUserCB^.pUserCallback$LDR_MM_UserCallbackPrototyp(pUserCB^.pUserCallbackThis, udStationId, #pStation^.m_szName[0], udServerHandle, #pServer^.m_szServerName[0], udState$_MMState); 
        ELSE
           pUserCB^.pUserCallback$LDR_MM_UserCallbackPrototyp(pUserCB^.pUserCallbackThis, udStationId, #pStation^.m_szName[0], 0, NIL, udState$_MMState); 
        END_IF;
        pUserCB := (pUserCB + sizeof(_UserCB))$^_UserCB;
     END_FOR;

    END_IF;
   
 END_IF;
    
END_FUNCTION
(******************************************************************
** private Funktionen
******************************************************************)
FUNCTION MMConnectionHandler::ThreadMMConn
	VAR_INPUT
		pthis 	: ^void;
	END_VAR
  VAR
  	rmtCmd  : _MMThreadCmdLine; // zeiger auf Kommando aus der Mailbx
    bAllConnected : BOOL;
    topsStart,
    topsEnd, 
    tops      : UDINT;
  END_VAR
    
  // this pointer setzen
  this := pthis$^MMConnectionHandler;

//  // Callback installieren
//  INSTALLCALLBACK(#ComlinkCallback());
  
  // alle nicht benötigten mmb files löschen
  StationFileDeleteUnused();
  
  // thread-Schleife
  WHILE(1) DO
  
    IF (OS_MT_GETCOND(MailBox2Handle, #rmtCmd) = TRUE) THEN // get cmd in mailbox
       // kommando abarbeiten
       DoThreadCmd(#rmtCmd);
    ELSE 
      // sleep des threads, wenn kein kommando abzuarbeiten ist
      OS_MT_DELAY(ThreadDelayTime);
    END_IF;
    
    topsStart := ops.tAbsolute;
    DoCheck4WriteCmds();
    topsEnd := ops.tAbsolute;
    tops := topsEnd - topsStart;
    
    // Verbindungsprüfung, ohne Verbindungsaufbau
    bAllConnected := RefreshAllStationState();
    
    IF ((bAllConnected = FALSE) & (m_bConnectionThreadRunning = FALSE)) THEN
      OS_MT_SIGNAL(EventHandler); // Es gibt was zum Verbinden
    END_IF;

  END_WHILE;

END_FUNCTION
(*
  Thread der den Verbindungsaufbau handelt
*)
FUNCTION MMConnectionHandler::ThreadMMConnHandler
	VAR_INPUT
		pthis 	: ^void;
	END_VAR
  
  // this pointer setzen
  this := pthis$^MMConnectionHandler;  
  
 // thread-Schleife
  WHILE(1) DO
  
    m_bConnectionThreadRunning := TRUE;

    // Verbindungsprüfung mit Verbindungsaufbau im Offline-Fall
    IF (ConnectToAllStations() = TRUE) THEN
      m_bConnectionThreadRunning := FALSE;
      OS_MT_WAIT(EventHandler);
      OS_MT_RESETEVENT(EventHandler); // event zurücksetzen damit wait wieder blockiert
    ELSE
       // sleep des threads
      OS_MT_DELAY(ThreadDelayTimeConnetion);
    END_IF;

  END_WHILE;
  
END_FUNCTION
(*
  Thread der die Serverdaten von der anderen PLC liest
*)
FUNCTION MMConnectionHandler::ThreadMMComCB
	VAR_INPUT
		pthis 	: ^void;
	END_VAR
  
    // this pointer setzen
  this := pthis$^MMConnectionHandler;  
  
  // thread-Schleife
  WHILE(1) DO
  
    DoCheck4ReadCmds();
    // sleep des threads
    OS_MT_DELAY(ThreadDelayTimeComCB);
  
  END_WHILE;

END_FUNCTION
(*
  Initialisiert die Reader
*)
FUNCTION MMConnectionHandler::Initialize

  // MMStationReader
  m_pMultiMasterStationReader := LDR_alloc_descr(sizeof(MMStationReader)) $ ^MMStationReader;
	IF (m_pMultiMasterStationReader <> 0) THEN
    _memset(m_pMultiMasterStationReader, 0, sizeof(MMStationReader));
    
    // stations einlesen
    m_pMultiMasterStationReader^.CreateStationsFromFile();
   
    // server einlesen und Objekte erstellen
    m_pMMServer := MMServerReader::ReadConfigMultimaster(m_pMultiMasterStationReader)$^MMServer;
  END_IF;

//********************************************************************
END_FUNCTION
(*
  Prüft ob für einen Server ein SendeRequest vorhanden ist und führt das Write aus
*)
FUNCTION MMConnectionHandler::DoCheck4WriteCmds
 VAR
  	iSvr            : UDINT; // schleifenzähler  	
    cntServer       : UDINT; // Anzahl der Server
    pServer 	      : ^MMServer; // Zeiger auf Server
    iStat           : UDINT; // schleifenzähler
    cntStations     : UDINT; // Anzahl der Stationen
    pStation 	      : ^MMStation; // Zeiger auf Station
    retVal          : DINT;
    pIterSvr        : ^void;
    sendReqCnt      : DINT;
  END_VAR
  
  pStation := NIL;
  
  IF ((m_pMultiMasterStationReader = NIL) | (m_pMMServer = NIL)) THEN
    RETURN;
  END_IF;
  
  // Anzahl der Stationen
  cntStations := m_pMultiMasterStationReader^.GetStationsCount();
  
  // alle Stationen durchlaufen
  IF ((cntStations > 0) & (cntStations < -1$UDINT)) THEN
    cntStations -= 1;
    FOR iStat:=0 TO cntStations BY 1 DO
      pStation := m_pMultiMasterStationReader^.GetStationAt(iStat);
      IF ((pStation <> NIL) & (pStation^.IsReady())) THEN
        cntServer := pStation^.GetSvrCount();
        IF ((cntServer > 0) & (cntServer < -1$UDINT)) THEN
          cntServer -= 1;
          pIterSvr := m_pMMServer + (pStation^.GetSvrStartIdx() * sizeof(UDINT));
          FOR iSvr:=0 TO cntServer BY 1 DO
            pServer := pIterSvr^$^MMServer;
            IF ((pServer <> NIL) 
            & (pServer^.m_sendReqCnt <> pServer^.m_sendReqDone) ) THEN
              IF ((pServer^.IsSpecialPriority() = TRUE) 
              | (pServer^.m_udLastWrite = 0)  
              | ((ops.tAbsolute - pServer^.m_udLastWrite) > pServer^.GetPriority())) THEN
              
                pServer^.m_pStation$^MMStation^.ComDefLock();
              
                // Vor dem Senden (TXCOMMAND Aufruf, der blockieren kann), wird m_sendReqCnt 
                // gemerkt, damit m_sendReqDone anschließend nach erfolgreichem Senden auf 
                // diesen Wert gesetzt werden kann. Eine direkte Zuweisung von m_sendReqCnt 
                // auf m_sendReqDone ist nicht threadsafe, da zwischen dem Senden und dem 
                // Setzen der Variable, m_sendReqCnt von einem anderen Thread geändert werden 
                // kann.
                sendReqCnt := pServer^.m_sendReqCnt;
                
                // Senden nach ServerType unterscheiden
                IF (pServer^.m_flServerType = _MM_CHTY_STRING) THEN
                  retVal := WriteString(pServer$UDINT, pServer^.m_pStation$^MMStation^.GetComDef()); 
                ELSIF (pServer^.m_flServerType = _MM_CHTY_MERKER) THEN
                  retVal := WriteDataMerkerEx(pServer$UDINT, pServer^.m_pStation$^MMStation^.GetComDef()); 
                ELSE
                  retVal := WriteToMultiMasterSymbol(pServer$UDINT, pServer^.m_pStation$^MMStation^.GetComDef()); 
                END_IF;
                
                pServer^.m_pStation$^MMStation^.ComDefUnlock();
                
                IF (retVal <> 0) THEN
                  // neu senden?
                ELSE
                  // erfolgreich gesendet, Zähler fürs erflogreiche Senden übernehmen
                  pServer^.m_sendReqDone := sendReqCnt;
                END_IF;
                // Zeitstempel setzen
                pServer^.m_udLastWrite := ops.tAbsolute;
                
              END_IF;
            END_IF;
            pIterSvr += sizeof(UDINT);
          END_FOR;
        END_IF;
      END_IF;
    END_FOR;
  END_IF;

END_FUNCTION
(*
  Prüft ob für einen Server ein LeseRequest vorhanden ist und führt das Read aus
*)
FUNCTION MMConnectionHandler::DoCheck4ReadCmds
 VAR
  	iSvr            : UDINT; // schleifenzähler  	
    cntServer       : UDINT; // Anzahl der Server
    pServer 	      : ^MMServer; // Zeiger auf Server
    iStat           : UDINT; // schleifenzähler
    cntStations     : UDINT; // Anzahl der Stationen
    pStation 	      : ^MMStation; // Zeiger auf Station
    retVal          : DINT;
    pIterSvr        : ^void;
  END_VAR
  
  pStation := NIL;
  
  IF ((m_pMultiMasterStationReader = NIL) | (m_pMMServer = NIL)) THEN
    RETURN;
  END_IF;
  
  // Anzahl der Stationen
  cntStations := m_pMultiMasterStationReader^.GetStationsCount();
  
  // alle Stationen durchlaufen
  IF ((cntStations > 0) & (cntStations < -1$UDINT)) THEN
    cntStations -= 1;
    FOR iStat:=0 TO cntStations BY 1 DO
      pStation := m_pMultiMasterStationReader^.GetStationAt(iStat);
      IF ((pStation <> NIL) & (pStation^.IsConnected())) THEN
        cntServer := pStation^.GetSvrCount();
        IF ((cntServer > 0) & (cntServer < -1$UDINT)) THEN
          cntServer -= 1;
          pIterSvr := m_pMMServer + (pStation^.GetSvrStartIdx() * sizeof(UDINT));
          FOR iSvr:=0 TO cntServer BY 1 DO
            pServer := pIterSvr^$^MMServer;
            IF ((pServer <> NIL) & (pServer^.m_bReadReq = TRUE)) THEN
              
                pServer^.m_bReadNotify := FALSE;
                
                pServer^.m_pStation$^MMStation^.ComDefLock();
              
                // Senden nach ServerType unterscheiden
                IF (pServer^.m_flServerType = _MM_CHTY_STRING) THEN
                  retVal := ReadString(pServer$UDINT, pServer^.m_pStation$^MMStation^.GetComDef()); 
                ELSIF (pServer^.m_flServerType = _MM_CHTY_MERKER) THEN
                  retVal := ReadDataMerkerEx(pServer$UDINT, pServer^.m_pStation$^MMStation^.GetComDef());
                END_IF;
                IF (retVal <> 0) THEN
                   // Valid flag zurück setzen
                  pServer^.RemoveStatus(MM_VALID_VALUE);
                ELSE
                  // erfolgreich gelesen, flag auf m_bReadNotify setzen, damit ja kein CB verloren geht
                  pServer^.m_bReadReq := pServer^.m_bReadNotify;
                  UpdateSvrInitialiezedFlag(pServer);
                END_IF;
                
                pServer^.m_pStation$^MMStation^.ComDefUnlock();
                
            END_IF;
			      pIterSvr += sizeof(UDINT);
          END_FOR;
        END_IF;
      END_IF;
    END_FOR;
  END_IF;

END_FUNCTION
(*
  Führt die Kommandos aus der Mailbox aus
*)
FUNCTION MMConnectionHandler::DoThreadCmd
	VAR_INPUT
		pCmdLine 	: ^_MMThreadCmdLine;
	END_VAR
  VAR
    pStation  : ^MMStation;
    pSvrObj   : ^MMServer;
    pNewInstParams : ^sNewInst;
  END_VAR

  // Sicherheitsabfragen
  IF ((pCmdLine = NIL) | (m_pMultiMasterStationReader = NIL))THEN
    RETURN;
  END_IF;

  // Stationsspezifische Kommandos
  pStation := m_pMultiMasterStationReader^.GetStationAt(pCmdLine^.udStationId);
  
  IF (pStation <> NIL) THEN
  
    CASE pCmdLine^.cmd OF
    
      MM_CONNECT_STATION:
          pStation^.m_bUserStopConn := FALSE;  // verbindungsaufbau wieder zulassen      
          pStation^.m_opLastConnTry := 0; // ohne timeout
          RETURN;
         
      MM_DISCONNECT_STATION:
         StationDisconnect(pStation, TRUE);
          RETURN;
         
      MM_SETCONNSTR:
          // erstmal aktuelle verbindung trennen
          StationDisconnect(pStation, TRUE);
          // connection string setzen
          pStation^.SetConnStr(#pCmdLine^.caConn[0]); 
          pStation^.m_changingConnStr := FALSE;
          // neu verbinden
          pStation^.m_bUserStopConn := FALSE;  // verbindungsaufbau wieder zulassen      
          pStation^.m_opLastConnTry := 0; // ohne timeout
          RETURN;

    END_CASE;
   
  END_IF;
  
  // SymbolServer spezifische Kommandos
  IF (pCmdLine^.SvrHandle <> 0) THEN
    
     pSvrObj := pCmdLine^.SvrHandle$^MMServer;
     // Station wegen ComDef holen
    IF ((pSvrObj^.m_pStation <> NIL) & (pSvrObj^.m_pStation$^MMStation^.IsReady())) THEN

      CASE pCmdLine^.cmd OF
          
        MM_NEWINST:
          SendNewInst(pCmdLine^.SvrHandle, (pCmdLine^.pVoid)$^sNewInst); 
          RETURN;
          
        MM_DELFROMRFL:
          DoDelFromRfl(pCmdLine^.SvrHandle$^MMServer);
          RETURN;
          
      END_CASE;
     
    END_IF;

    IF pCmdLine^.cmd = MM_NEWINST THEN
      // SendNewInst wurde nicht aufgerufen, daher wird der IprState hier auf ERROR gesezt 
      // und das used Element auf unusedNewInst.
      pNewInstParams := (pCmdLine^.pVoid)$^sNewInst;
      pNewInstParams^.used := unusedNewInst;
      pNewInstParams^.IprState := ERROR;
    END_IF;

    MM_TRACE("DoThreadCmd: Server-cMD not called (!Ready)", pCmdLine^.cmd, 0, 0);

  END_IF;

END_FUNCTION
(*
  Holt loader version 
*) 
FUNCTION MMConnectionHandler::GetLoaderVersion
	VAR_INPUT
		pComDef 	: ^Comdef;
		pLoaderVersion 	: ^Revision;
	END_VAR
  VAR
    para      : _TxCommandParams;
  END_VAR
  
  pLoaderVersion^.Hi := 0;  
  pLoaderVersion^.Lo := 0;
  // Kommando absetzen 
  para.status := TXCOMMANDEX( I_GET_VERSION, 			   // command
                              0,                    // parameters length
                              #para.para[0],			  // parameters
                              pComDef,	            // identifies the channel
                              #para.result, 		    // result buffer
                              SIZEOF(para.result),	// size of result buffer
                              #para.reason			    // reason code in the case of an error
                            );

  // Kommando korekt ausgeführt?
  IF (para.status = READY) THEN
//		uiLoaderVersion : STRUCT		// loader revisions:
//			usLoRev			: USINT;
//			usHiRev			: USINT;
//			END_STRUCT;
    pLoaderVersion^.Lo := para.result.aData[0];    
    pLoaderVersion^.Hi := para.result.aData[1];
  END_IF;

END_FUNCTION
(*
  Prüft alle Verbindungen
*)
FUNCTION MMConnectionHandler::RefreshAllStationState
	VAR_OUTPUT
		bAllConnected 	: BOOL;
	END_VAR
  VAR
  	i             : UDINT; // schleifenzähler
    cntStations   : UDINT; // Anzahl der Stationen
    pStation 	    : ^MMStation; // Zeiger auf Station
  END_VAR
  
  pStation := NIL;
  
  // Anzahl der Stationen
  cntStations := m_pMultiMasterStationReader^.GetStationsCount();
  
  bAllConnected := TRUE;
  // alle Stationen durchlaufen
  IF ((cntStations > 0) & (cntStations < -1$UDINT)) THEN
    cntStations -= 1;
    FOR i:=0 TO cntStations BY 1 DO
      pStation := m_pMultiMasterStationReader^.GetStationAt(i);
      IF ((pStation <> NIL) & (pStation^.CheckAndRefreshState() = FALSE)) THEN
         bAllConnected := FALSE;
         SetServerStationStateFlag(pStation, FALSE);
      END_IF;
    END_FOR;
  END_IF;

END_FUNCTION
(*
  Durchläuft alle Stationen und versucht diese zu Verbinden
  Wurde die Station verbunden, wird der Callback installiert
  und die LasalIds der Server ermittelt (File oder Neu)
*)
FUNCTION MMConnectionHandler::ConnectToAllStations
  VAR_OUTPUT
    bAllConnected : BOOL;
  END_VAR
  VAR
  	i             : UDINT; // schleifenzähler
    cntStations   : UDINT; // Anzahl der Stationen
    pStation 	    : ^MMStation; // Zeiger auf Station
  END_VAR
  
  pStation := NIL;
  bAllConnected := TRUE;

  IF (m_pMultiMasterStationReader = NIL) THEN
    RETURN;
  END_IF;

  // Anzahl der Stationen
  cntStations := m_pMultiMasterStationReader^.GetStationsCount();

  // alle Stationen durchlaufen
  IF ((cntStations > 0) & (cntStations < -1$UDINT)) THEN
    cntStations -= 1;
    FOR i:=0 TO cntStations BY 1 DO
      pStation := m_pMultiMasterStationReader^.GetStationAt(i);
      IF (pStation <> NIL) THEN
         // Verbindung erstellen, Connect soll immer ausgeführt werden
         bAllConnected := ((ConnectToStation(pStation, FALSE) = TRUE) & (bAllConnected = TRUE));
      END_IF;
    END_FOR;
  END_IF;
  
END_FUNCTION
(*
  Verbinden der Station
*)
FUNCTION MMConnectionHandler::ConnectToStation
	VAR_INPUT
		pStation 	: ^MMStation;
		bUser 	: BOOL;
	END_VAR
	VAR_OUTPUT
		bConnected 	: BOOL;
	END_VAR
  VAR
    crc           : UDINT;  // aktueller DescriptorCrc
    _comdata      : ^comData;
    _comdef       : ^Comdef;
    LdrVersion  : Revision;
  END_VAR

  // Variablen initialisieren
  crc := 0;

  bConnected := TRUE;
  
  IF (pStation = NIL) | (m_pMMServer = NIL) THEN
    RETURN;
  END_IF;

  IF (pStation^.IsConnected() = false) THEN
    // Verbindung aufbauen
    IF (StationConnect(pStation, bUser) = true) THEN
      
      pStation^.ComDefLock();

      // Callback hinzufpgen
      _comdef := pStation^.GetComDef();
      _comdata := _comdef^.pt_COM;
      
      INSTALLCALLBACK_DYN(#ComlinkCallback(), this, _comdata);
//      _comdata^.pCallback := #ComlinkCallback();
//      _comdata^.pThis := this$UDINT;
      
      pStation^.m_bLdrVersionOk := TRUE;
      IF (pStation^.m_bCheckLdrVersion = TRUE) THEN
        GetLoaderVersion(_comdef, #LdrVersion);
        IF ((LdrVersion.Hi < 16#22) & (LdrVersion.Lo < 16#AA))THEN
          pStation^.m_bLdrVersionOk := FALSE;
          TRACE0_ERR("Multimaster MerkerEx is not supported on Station '{0}'. Loader version to low, upate to >= 02.02.170", #pStation^.m_szName[0]);
        END_IF;
      END_IF;

      StationCRCChanged(pStation);
      
      SetServerStationStateFlag(pStation, TRUE);
      
      // refreshlisten einträge erstellen
      StationCreateRefreshListEntries(pStation); 
      
      pStation^.ComDefUnlock();

    ELSE
      bConnected := FALSE;
    END_IF;
  ELSE
  
    pStation^.ComDefLock();

    IF (StationCRCChanged(pStation) = TRUE) THEN

      // refresh liste beenden
      StartStopRefresh(pStation^.GetComDef(), 0, 1(*dyn.Refreshliste*));
      // refreshlisten einträge erstellen
      StationCreateRefreshListEntries(pStation); 
    
    END_IF;
      
    pStation^.ComDefUnlock();
    
  END_IF;
  
END_FUNCTION
(*
  Checks if Station Crc has changed
*)
FUNCTION MMConnectionHandler::StationCRCChanged
	VAR_INPUT
		pStation 	: ^MMStation;
	END_VAR
	VAR_OUTPUT
		bChanged 	: BOOL;
	END_VAR
  VAR
    crc           : UDINT;  // aktueller DescriptorCrc
  END_VAR

  bChanged := FALSE;
  // aktuelle DescriptorCrc holen
  crc := StationGetDescCrc(pStation^.GetComDef());
  IF (crc = 0) THEN
    StationDisconnect(pStation, FALSE);
  ELSIF (pStation^.GetCrc() = crc) THEN
    RETURN; // crc nicht verändert
  ELSE
    // rsb-File einlesen
    IF (StationFileRead(pStation, crc) = false) THEN
      bChanged := TRUE;
      // neue DescriptorCrc setzen
      pStation^.SetCrc(crc);
      // alle LasalIds der station auf ungültig setzen
      StationReset(pStation);
    END_IF;
    // LasalIds neu ermittlen 
    IF (StationCheckSvr(pStation) = TRUE) THEN
      bChanged := TRUE;
      StationFileWrite(pStation); //  rsb-File neu schreiben
    END_IF;
  END_IF;

END_FUNCTION
(*
  Von dem mitgelieferten Server die LasalId ermitteln und
  einen Refreshlisten Eintrag erstellen
*)
FUNCTION MMConnectionHandler::SvrGetLasalId
	VAR_INPUT
		pSymbolServer 	: ^MMServer;
		pComDef 	: ^Comdef;
	END_VAR
	VAR_OUTPUT
		bValidLasalId 	: BOOL;
	END_VAR
  VAR
    para      : _TxCommandParams;
    udLasalId : UDINT;
  END_VAR
  
  bValidLasalId := FALSE;
  
  IF ((pSymbolServer = NIL) | (pComDef = NIL)) THEN
    RETURN;
  END_IF;
  
  // Ist lasal id gültig?
  bValidLasalId := pSymbolServer^.m_udLasalId > 0;
  
  // lasal ist gültig, braucht nicht mehr abgefragt werden
  IF (bValidLasalId = TRUE) THEN
    RETURN;
  END_IF;
  
  // Parameter erstellen
  para.paraLen := pSymbolServer^.GetName(#para.para[0]);
  para.para[para.paraLen + 1] := P_EOL;
  para.paraLen += 2;
  
  // Kommando absetzen 
  para.status := TXCOMMANDEX( I_GET_OBJ, 			      // command
                              para.paraLen,         // parameters length
                              #para.para[0],			  // parameters
                              pComDef,	            // identifies the channel
                              #para.result, 		    // result buffer
                              SIZEOF(para.result),	// size of result buffer
                              #para.reason			    // reason code in the case of an error
                            );

  // Kommando korekt ausgeführt?
  IF (para.status = READY) THEN
    // Lasal ID aus Result auslesen
    udLasalId := para.result.aData[0]$UDINT;
    pSymbolServer^.SetLasalId(udLasalId);
    // rückgabe wert setzen
    bValidLasalId := (udLasalId > 0);
  END_IF;
  
END_FUNCTION
(*
  Versucht eine Verbindung zu der mitgelieferten Station auf zu bauen
*)
FUNCTION MMConnectionHandler::StationConnect
	VAR_INPUT
		pStation 	: ^MMStation;
		bUserStart 	: BOOL;
	END_VAR
	VAR_OUTPUT
		bConnected 	: BOOL;
	END_VAR

  bConnected := FALSE;
  
  IF (pStation <> NIL) THEN 
    bConnected := pStation^.Connect(bUserStart);
  END_IF;

END_FUNCTION
(*
  Unterbricht die Verbindung zu der mitgelieferten Station
*)
FUNCTION MMConnectionHandler::StationDisconnect
	VAR_INPUT
		pStation 	: ^MMStation;
		bUserStop 	: BOOL;
	END_VAR

  IF (pStation <> NIL) THEN 
    // refresh liste beenden
    StartStopRefresh(pStation^.GetComDef(), 0, 1(*dyn.Refreshliste*));
    // verbindung beenden
    pStation^.Disconnect(bUserStop);
  END_IF;

END_FUNCTION
(*
  DescriptorCrc der Station ermitteln
*)
FUNCTION MMConnectionHandler::StationGetDescCrc
	VAR_INPUT
		pComDef 	: ^Comdef;
	END_VAR
	VAR_OUTPUT
		udCrC 	: UDINT;
	END_VAR
  VAR
    para      : USINT;	// parameters
    paralen   : UDINT;
    result    : RESULTS; 		// result buffer
    status    : IPRSTATES;
    reason    : comlinkReason;
  END_VAR

  udCrC := 0;
  
  // Parameter setzen
  para := P_EOL;
  paralen := 1;
  
  status := TXCOMMANDEX(I_GET_DESC_CRC,	  // command
                        paralen,          // parameters length
                        #para,			      // parameters
                        pComDef,          // identifies the channel
                        #result, 		      // result buffer
                        SIZEOF(result),	  // size of result buffer
                        #reason			      // reason code in the case of an error
                        );

  IF (status = READY) THEN
    udCrC := result.aData[0]$UDINT;
  END_IF;

END_FUNCTION
(*
  Erstellt für alle Symbols mit gültiger LasalId einen Refreshlisten Eintrag
*)
FUNCTION MMConnectionHandler::StationCreateRefreshListEntries
	VAR_INPUT
		pStation 	: ^MMStation;
	END_VAR
  VAR
    Lslcommregdata   : Lslcommregdata; // struktur zu
    iSvrItr          : UDINT; // schleifenzähler
    cntServer        : UDINT; // Anzahl der Stationen
    pServer 	       : ^MMServer; // Zeiger auf Server
    iRefCnt          : UDINT; // Position in der Refreshliste
    uiflags          : UINT;
    pIterSvr         : ^void;
  END_VAR
  
  IF (pStation = NIL) THEN
    RETURN;
  END_IF;

  pServer := NIL;
  // Anzahl der Server
  cntServer := pStation^.GetSvrCount();
  
  IF ((cntServer <= 0) | (m_pMMServer = NIL)) THEN
    RETURN;
  END_IF;

  pStation^.ComDefLock();

  iRefCnt := DNYLIST_FIRST_IDX;// bei 1000 beginnt die dyn. Refreshliste (die dyn. kann 5000, die stat. 1000 Werte aufnehmen)
  IF ((cntServer > 0) & (cntServer < -1$UDINT)) THEN
    cntServer -= 1;
    pIterSvr := m_pMMServer + (pStation^.GetSvrStartIdx() * sizeof(UDINT));
    FOR iSvrItr:=0 TO cntServer BY 1 DO
      pServer := pIterSvr^$^MMServer;
      IF ((pServer <> NIL) & (pServer^.m_udLasalId > 0)) THEN
                     
         pServer^.ResetInitializedFlag();            
        // rfl Data befüllen
        Lslcommregdata.LASALID := pServer^.m_udLasalId;
        (*
          Im Element LslCommRegData.uiTIME ist neben der Update-Rate in ms auch noch folgende 
          Zusatzinformation hineincodiert:
          Bit 15 (16#8000) .. es handelt sich um ein VBI Objekt (Datenbuffer statt 4 Byte Wert)
          Bit 14 (16#4000) .. es handelt sich um eine globale Variable (4 Byte Datenlänge)
          
          Diese Bits werden hier von pServer^.m_uiPriority nicht übernommen
         *)
        Lslcommregdata.uiTIME := pServer^.m_uiPriority AND 16#3FFF;

        // NUR BEI String soll CRC gesendet werden
        IF (pServer^.m_flServerType = _MM_CHTY_STRING) THEN
          // Set CRC Flag, höchstwertigste Bit (Bit 15) auf 1
            Lslcommregdata.uiTIME := (Lslcommregdata.uiTIME OR 0x8000);
        END_IF;

        // Pos in der Liste  
        Lslcommregdata.VarPos := iRefCnt$UINT;
        // RmData Index als ID 
        LslCommRegData.VarlistID := pServer$UDINT;
        // Server Channel!
        Lslcommregdata.channel := 1;
        
        IF (pServer^.m_uiPriority <> MM_NoRefreshlistEntry) THEN
          uiflags := 0;
          IF ((pServer^.m_flServerType = _MM_CHTY_MERKER) & (pStation^.m_bLdrVersionOk = TRUE)) THEN
			      // Set CRC Flag für Merker Ex setzen wenn von station unterstützt
            uiflags := 16#8000;
          END_IF;

          // Update in die rfl
          IF (TXUPD2(#Lslcommregdata, pStation^.GetComDef(), uiflags) = 0) THEN
            // zähler für rfl pos erhöhen
            iRefCnt += 1; 
          END_IF;
        ELSE
          IF (pServer^.IsInitializedFlagSet() = FALSE) THEN
            pServer^.SetInitialized();
            pServer^.m_pStation$^MMStation^.DecreaseSvrInitCnt();
          END_IF;
        END_IF;
      
      END_IF;
	  pIterSvr += sizeof(UDINT);
    END_FOR;
    
    // Starten der Refreshliste
    IF (iRefCnt > DNYLIST_FIRST_IDX) THEN
      StartStopRefresh(pStation^.GetComDef(), TO_UINT(iRefCnt)-DNYLIST_FIRST_IDX, 1(*dyn.Refreshliste*));
    END_IF;
  END_IF;
  
  pStation^.ComDefUnlock();

END_FUNCTION
(*
  Die LasalId der Server der Station bei Bedarf ermitteln
  und Refreshlisten Eintrag erstellen
  rsb-File wird neu geschrieben
*)
FUNCTION MMConnectionHandler::StationCheckSvr
	VAR_INPUT
		pStation 	: ^MMStation;
	END_VAR
  VAR_OUTPUT
  	bRead     : BOOL;
  END_VAR
  VAR
  	i               : UDINT; // schleifenzähler
    cntServer       : UDINT; // Anzahl der Server
    cntServerFound  : UDINT; // Anzahl der Server, wo Lasalid gefunden wurde
    pServer 	      : ^MMServer; // Zeiger auf Server
    pIterSvr        : ^void;
  END_VAR
  
  bRead := FALSE;
  pServer := NIL;
  cntServerFound := 0;
  
  IF (pStation = NIL) THEN
    RETURN;
  END_IF;

  // Anzahl der Server
  cntServer := pStation^.GetSvrCount();
   
  IF ((cntServer > 0) & (cntServer < -1$UDINT) & (m_pMMServer <> NIL)) THEN
    cntServer -= 1;
    pIterSvr := m_pMMServer + (pStation^.GetSvrStartIdx() * sizeof(UDINT));
    FOR i:=0 TO cntServer BY 1 DO
      pServer := pIterSvr^$^MMServer;
      IF (pServer <> NIL) THEN
        IF (pServer^.m_udLasalId <= 0) THEN
          // Lasal ID holen
          IF(SvrGetLasalId(pServer, pStation^.GetComDef()) = true) THEN
            cntServerFound += 1;
          END_IF;
        ELSE
          cntServerFound += 1;
        END_IF;
        bRead := TRUE;
      END_IF;
      pIterSvr += sizeof(UDINT);
    END_FOR;
  END_IF;
  
  pStation^.SetServerFoundCnt(cntServerFound);
  
END_FUNCTION
(*
  LasalIds der Server auf ungültig setzen
*)
FUNCTION MMConnectionHandler::StationReset
	VAR_INPUT
		pStation 	: ^MMStation;
	END_VAR
  VAR
  	i             : UDINT; // schleifenzähler
    cntServer     : UDINT; // Anzahl der Stationen
    pServer 	    : ^MMServer; // Zeiger auf Server
    pIterSvr      : ^void;
  END_VAR
  
  IF (pStation = NIL) THEN
    RETURN;
  END_IF;

  pServer := NIL;
  // Anzahl der Server
  cntServer := pStation^.GetSvrCount();
  
  IF ((cntServer > 0) & (cntServer < -1$UDINT) & (m_pMMServer <> NIL)) THEN
    cntServer -= 1;
    pIterSvr := m_pMMServer + (pStation^.GetSvrStartIdx() * sizeof(UDINT));
    FOR i:=0 TO cntServer BY 1 DO
      pServer := pIterSvr^$^MMServer;
      IF (pServer <> NIL) THEN
        // lasal id auf ungültig setzen
        pServer^.ResetLasalId();
      END_IF;
      pIterSvr += sizeof(UDINT);
    END_FOR;
  END_IF;

END_FUNCTION
(*
  Statusflag der Server auf aktualisieren setzen
*)
FUNCTION MMConnectionHandler::SetServerStationStateFlag
	VAR_INPUT
		pStation 	: ^MMStation;
    bOnline   : BOOL;
	END_VAR
  VAR
  	i             : UDINT; // schleifenzähler
    cntServer     : UDINT; // Anzahl der Stationen
    pServer 	    : ^MMServer; // Zeiger auf Server
    pIterSvr      : ^void;
  END_VAR
  
  IF (pStation = NIL) THEN
    RETURN;
  END_IF;

  pServer := NIL;
  // Anzahl der Server
  cntServer := pStation^.GetSvrCount();
  
  IF ((cntServer > 0) & (cntServer < -1$UDINT) & (m_pMMServer <> NIL)) THEN
    cntServer -= 1;
    pIterSvr := m_pMMServer + (pStation^.GetSvrStartIdx() * sizeof(UDINT));
    FOR i:=0 TO cntServer BY 1 DO
      pServer := pIterSvr^$^MMServer;
      IF (pServer <> NIL) THEN
        
        IF (bOnline =TRUE) THEN
          pServer^.AddStatus(MM_ONLINE);
        ELSE
          pServer^.RemoveStatus(MM_ONLINE OR MM_VALID_VALUE OR MM_INITIALIZED);
        END_IF;

      END_IF;
      pIterSvr += sizeof(UDINT);
    END_FOR;
  END_IF;

END_FUNCTION
(*
  schreibt das rsb-File
*)
FUNCTION MMConnectionHandler::StationFileWrite
	VAR_INPUT
		pStation 	: ^MMStation;
	END_VAR
  VAR
  	i             : UDINT; // schleifenzähler
    cntServer     : UDINT; // Anzahl der Stationen
    pServer 	    : ^MMServer; // Zeiger auf Server
    handle        : DINT;  // file handle
    filename      : ARRAY [0..255] OF CHAR;	// dateiname
    udDummy       : UDINT;  // hilfsvariable 
    pIterSvr      : ^void;
  END_VAR 
  
  // prüfen ob OS Version überhaupt ein Filesystem unterstützt
  IF _rtosversion <= 16#537 | (!!(LSLFILE_IsInstalled)) THEN
    // Es gibt kein Filesystem, oder das OS ist so alt, dass es nicht weiß ob eines vorhanden ist
    RETURN;
  END_IF;
 
  IF (pStation = NIL) THEN
    RETURN;
  END_IF;

  _memset(#filename, 0, 256);
  pServer := NIL;
  
  // Anzahl der Server
  cntServer := pStation^.GetSvrCount();
  // Dateinamen ermitteln
  pStation^.GetFileName(#filename[0]);
         
 // Datei öffnen
  handle := OS_FILE_OPEN(#filename[0], 1, 0); 	// 1 = create always
  IF (handle < 0) THEN
    RETURN; // File konnte nicht erstellt werden
  END_IF;
  
  // Header schreiben
  udDummy := MMB_HEADER_CHECK;
  OS_FILE_WRITE(handle, #udDummy,  sizeof(UDINT));
  udDummy := MMB_VERSION;
  OS_FILE_WRITE(handle, #udDummy,  sizeof(UDINT));
  udDummy := MMB_HEADER_OFFSET; 
  OS_FILE_WRITE(handle, #udDummy,  sizeof(UDINT));
  
  // daten schreiben
  udDummy := pStation^.GetCrC();
  OS_FILE_WRITE(handle, #udDummy,  sizeof(UDINT));
  OS_FILE_WRITE(handle, #cntServer,  sizeof(UDINT));
  
   IF ((cntServer > 0) & (cntServer < -1$UDINT) & (m_pMMServer <> NIL)) THEN
      cntServer -= 1;
      pIterSvr := m_pMMServer + (pStation^.GetSvrStartIdx() * sizeof(UDINT));
      FOR i:=0 TO cntServer BY 1 DO
       pServer := pIterSvr^$^MMServer;
       udDummy := pServer^.m_udLasalId;
       OS_FILE_WRITE(handle, #udDummy, sizeof(UDINT));
       _memset(#filename, 0, 256);
       udDummy := pServer^.GetName(#filename[0]);
       OS_FILE_WRITE(handle, #udDummy, sizeof(UDINT));
       OS_FILE_WRITE(handle, #filename[0], udDummy);
       pIterSvr += sizeof(UDINT);
      END_FOR;
    END_IF;
  
  // fertig mit datei, wieder schliessen
  OS_FILE_CLOSE(handle);
   
END_FUNCTION
(*
  Liest das rsb-File
*)
FUNCTION MMConnectionHandler::StationFileRead
	VAR_INPUT
		pStation 	: ^MMStation;
		udNewCrc 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bValid 	: BOOL;
	END_VAR
  VAR
    handle        : DINT;  // file handle
    filename      : ARRAY [0..255] OF CHAR;	// dateiname
    udDummy       : UDINT;
    udLasalId     : UDINT;
    symbolName    : ARRAY [0..255] OF CHAR;
    symCnt        : UDINT;
    i             : UDINT;
    pServer 	    : ^MMServer; // Zeiger auf Server
  END_VAR 
  
  bValid:= FALSE;
  
    // prüfen ob OS Version überhaupt ein Filesystem unterstützt
  IF ((_rtosversion <= 16#537) | (!!(LSLFILE_IsInstalled))) THEN
    // Es gibt kein Filesystem, oder das OS ist so alt, dass es nicht weiß ob eines vorhanden ist
    RETURN;
  END_IF;

  IF (pStation = NIL) THEN
    RETURN;
  END_IF;

  _memset(#filename, 0, 256);
  _memset(#symbolName, 0, 256);
  
  pStation^.GetFileName(#filename[0]);
         
 // Datei öffnen
  handle := OS_FILE_OPEN(#filename[0], 0, 0);	 // 0 = read only
  IF handle < 0 THEN
    RETURN; // File existiert nicht
  END_IF;
  
   // Header lesen
  OS_FILE_READ(handle, #udDummy, sizeof(UDINT));
  
  // Prüfen ob datei gelesen werden kann
  IF (udDummy = MMB_HEADER_CHECK) THEN
    OS_FILE_READ(handle, #udDummy, sizeof(UDINT));
    IF (udDummy = MMB_VERSION) THEN
      // header offest
      OS_FILE_READ(handle, #udDummy, sizeof(UDINT));
      // zu dieser position in der datei gehen
      OS_FILE_SEEK(handle, udDummy, FILE_BEGIN);
      // CRC einlesen
      OS_FILE_READ(handle, #udDummy, sizeof(UDINT));
      // anzahl der SymbolServer
      OS_FILE_READ(handle, #symCnt, sizeof(UDINT));

      IF ((udNewCrc = udDummy) & (symCnt = pStation^.GetSvrCount())) THEN
        // Descriptor CRC setzen
        pStation^.SetCrc(udNewCrc);
        bValid := TRUE;
         // nur lesen wenn die CRC übereinstimmt
        IF ((symCnt > 0) & (symCnt < -1$UDINT) & (m_pMMServer <> NIL)) THEN
          symCnt -= 1;          
          FOR i:=0 TO symCnt BY 1 DO
            // lasalID
            OS_FILE_READ(handle, #udLasalId, sizeof(UDINT));
            // länge des Namens
            OS_FILE_READ(handle, #udDummy, sizeof(UDINT));
            // namen einlesen
            OS_FILE_READ(handle, #symbolName, udDummy*sizeof(CHAR));
            // server holen
            pServer := MM_GetServer(pStation^.GetId(), #symbolName[0])$^MMServer;
            IF (pServer <> NIL) THEN
              // lasalID setzen
              pServer^.SetLasalId(udLasalId);
            END_IF;
          END_FOR;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  
  // fertig mit datei, wieder schliessen
  OS_FILE_CLOSE(handle);

END_FUNCTION
(*
  Löscht die nicht verwendeten Stations 
*)
FUNCTION MMConnectionHandler::StationFileDeleteUnused
  VAR
    tmp       : ARRAY[0..49] of CHAR;
    fileName  : ARRAY[0..49] of CHAR;
    ddeInfo   : _DDE_INFO;
    hFirst    : DINT;
    hNext     : DINT;
  END_VAR
  
  // prüfen ob OS Version überhaupt ein Filesystem unterstützt
  IF ((_rtosversion <= 16#537) | (NOT(LSLFILE_IsInstalled))) THEN
    // Es gibt kein Filesystem, oder das OS ist so alt, dass es nicht weiß ob eines vorhanden ist
    RETURN;
  END_IF;
  

  hFirst := OS_FILE_FINDFIRSTEX(MM_FILE_SEARCH, 0, 0, #ddeInfo, #fileName[0], sizeof(fileName));
  hNext := 1;
  
  WHILE((hFirst >= 0) & (hNext >= 0)) DO

    IF(ddeInfo.Attributes <> ATTR_DIR) THEN
      IF (StationFileCheckUsage(#fileName[0]) <> 0) THEN
       _strcpy(#tmp[0], MM_FILE_PATH);
       _strcat(#tmp[0], #fileName[0]);
        OS_FILE_DELETE(#tmp[0]);
      END_IF;
    END_IF;
    
    hNext := OS_FILE_FINDNEXTEX(hFirst, #ddeInfo, #fileName[0], sizeof(fileName));
  END_WHILE;
  
  OS_FILE_FINDCLOSE(hFirst);

END_FUNCTION
(*
  Prüft ob das mmb file verwendet wird.
*)
FUNCTION MMConnectionHandler::StationFileCheckUsage
	VAR_INPUT
		pFilename 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		nRes 	: DINT;
	END_VAR
  VAR
  	itr           : UDINT; // schleifenzähler
    cntStations   : UDINT; // Anzahl der Stationen
    pStation 	    : ^MMStation; // Zeiger auf Station
  END_VAR
  
  nRes := -1;

  IF ((m_pMultiMasterStationReader = NIL) | (pFilename = NIL))THEN
    RETURN;
  END_IF;

  // Anzahl der Stationen
  cntStations := m_pMultiMasterStationReader^.GetStationsCount();
  
  // alle Stationen durchlaufen
  IF ((cntStations > 0) & (cntStations < -1$UDINT)) THEN
    cntStations -= 1;
    FOR itr:=0 TO cntStations BY 1 DO
      pStation := m_pMultiMasterStationReader^.GetStationAt(itr);
      nRes := pStation^.CheckFileName(pFilename);
      IF (nRes = 0) THEN
        RETURN;
      END_IF;
    END_FOR;
  END_IF;
  
END_FUNCTION

(******************************************************************
** globale Funktionen für Loader
******************************************************************)
(*
  Startet den RmThread
  Erstellt die Mailbox und die Mutex Handler
*)
FUNCTION GLOBAL MMConnectionHandler::OnMultiMasterInit
	VAR_OUTPUT
		bHasObjects 	: BOOL;
	END_VAR
  
  bHasObjects := FALSE;
  
   // variablen initialisieren
  Thread2Handle := NIL;
  Thread2HandleConnection := NIL;
  Thread2HandleComCB := NIL;
  MailBox2Handle := NIL;
  mt_api := NIL;
  m_pUserCallback := NIL;
  m_nUserCallbackCount := 0;
  EventHandler := NIL;
  m_bConnectionThreadRunning := FALSE;
  
  m_pMultiMasterStationReader := NIL;
  m_pMMServer := NIL;
  
  m_pBufferIn := NIL;
  m_udBufferInLen := 0;
  m_pBufferOut := NIL;
  m_udBufferOutLen := 0;
  m_pChgBytes := NIL;
  m_udChgBytesLen := 0;
  
  MM_firstInitActive := FALSE;
  
#ifdef MM_DEBUG
  IF OS_CILGet("SYSMSG", #OS_pLslSysMsg$void) THEN
    RETURN;
  END_IF;
  // write to C:\SYSMSG\EVENT17.LOG
  hLog_mm := OS_SYSMSG_LCREATE(7, #LogBuf0[0], sizeof(LogBuf0), 200000, 0);
#endif

  MM_TRACE("=== MM Start ===", 0, 0, 0);

  // prüfen ob multitasking unterstützt wird
  OS_CILGet("LSL_MULTITASK", #mt_api$void);

  IF(mt_api <> NIL) THEN 
  
    //  Stations.txt einlesen und die MMServer Objekte erstellen
    Initialize();
  
    // gibt keine Serverobjekte also brauchen wir keinen Thread
    IF (m_pMMServer = NIL) THEN
      StationFileDeleteUnused();
      RETURN;
    END_IF;

    bHasObjects := TRUE;
  
  END_IF;
  
END_FUNCTION

FUNCTION GLOBAL MMConnectionHandler::OnMultiMasterStartThreads


      // Mailbox erstellen
    MailBox2Handle := OS_MT_CREATEMAILBOX(sizeof(_MMThreadCmdLine), MailBox2Size, "RmMailBox");
    IF(MailBox2Handle <> NIL) THEN

      EventHandler := OS_MT_CREATESEMAPHORE(MTSEMATYPE_EVENT,  
                                           0,    // initvalue
                                           0,    // flags: 0 means create unconitionally
                                           "LDRMM_Event"
                                           );
                                               
                                               
       // MultiMaster Connection Thread Starten                                        
      Thread2HandleConnection := OS_MT_CREATETHREAD(#ThreadMMConnHandler(),
                                                   14, //cyclic
                                                   16#4000,
                                                   0, //MT_Task_SAVETHIS
                                                   this, 
                                                  "LDRMM_ConnectionTask" // Anzeigname 
                                                   ); 
      MM_TRACE_S("Thread %s created, %08X", "LDRMM_ConnectionTask", Thread2HandleConnection, 0);

       // MultiMasterThread Starten                                        
      Thread2Handle := OS_MT_CREATETHREAD(#ThreadMMConn(),
                                          14, //cyclic
                                          16#4000,
                                          0, //MT_Task_SAVETHIS
                                          this, 
                                          "LDRMM_Task" // Anzeigname 
                                          );  
      MM_TRACE_S("Thread %s created, %08X", "LDRMM_Task", Thread2Handle, 0);
      
      // MultiMasterThread zum Abarbeiten des ComlinkCallbacks Starten                                        
      Thread2HandleComCB := OS_MT_CREATETHREAD(#ThreadMMComCB(),
                                              14, //cyclic
                                              16#4000,
                                              0, //MT_Task_SAVETHIS
                                              this, 
                                              "LDRMM_ComCBTask" // Anzeigname 
                                              ); 
      MM_TRACE_S("Thread %s created, %08X", "LDRMM_ComCBTask", Thread2HandleComCB, 0);
  END_IF;

END_FUNCTION

(******************************************************************
** globale Funktionen für User
******************************************************************)
(*
  Usercallback mit Prototyp LDR_MM_UserCallback einrichten
*)
FUNCTION GLOBAL LDR_MM_InstallCallback
  VAR_INPUT
    pCallback  : ^void;
    pThis      : ^void;
  END_VAR
  VAR
  	pUserCB : ^_UserCB;
  END_VAR

  
  IF ((pCallback = NIL) | (pThis = NIL)) THEN
    RETURN;
  END_IF;

 
  m_nUserCallbackCount += 1;
  IF (m_nUserCallbackCount = 1) THEN
    m_pUserCallback := _alloc_resize_LDR(m_nUserCallbackCount * sizeof(_UserCB));
  ELSE 
    m_pUserCallback := _realloc_LDR(m_pUserCallback, m_nUserCallbackCount * sizeof(_UserCB));
  END_IF;
  
  IF (m_pUserCallback = NIL) THEN
    m_nUserCallbackCount := 0;
    RETURN;
  END_IF;

  pUserCB := (m_pUserCallback + ((m_nUserCallbackCount - 1) * sizeof(_UserCB)))$^_UserCB;
  pUserCB^.pUserCallback     := pCallback;
  pUserCB^.pUserCallbackThis := pThis;
  
  InvokeUserCallback(pUserCB);
  
END_FUNCTION
(*
  Ermittelt aus Stationsnamen die StationsNummer (ID)
*)
FUNCTION GLOBAL LDR_MM_StatNameGetNr
  VAR_INPUT
    pszName : ^CHAR;
  END_VAR
  VAR_OUTPUT
    udStationId : UDINT;
  END_VAR
  VAR
  	i             : UDINT; // schleifenzähler
    cntStations   : UDINT; // Anzahl der Stationen
    pStation 	    : ^MMStation; // Zeiger auf Station
    lexem1         : CLocLex;
    lexem2         : CLocLex;
  END_VAR
  
  udStationId := -1$UDINT;
  
  IF (m_pMultiMasterStationReader = NIL) THEN
    RETURN;
  END_IF;

  pStation := NIL;
  
  // Anzahl der Stationen
  cntStations := m_pMultiMasterStationReader^.GetStationsCount();
  
  // alle Stationen durchlaufen
  IF ((cntStations > 0) & (cntStations < -1$UDINT)) THEN
    cntStations -= 1;
    
    lexem1.InitText(pszName);
    
    FOR i:=0 TO cntStations BY 1 DO
      pStation := m_pMultiMasterStationReader^.GetStationAt(i);
      IF (pStation <> NIL) THEN
         lexem2.InitText(#pStation^.m_szName[0]);
          IF (lexem1.udCRC = lexem2.udCRC) THEN
            IF (_strcmp(pszName, #pStation^.m_szName[0]) = 0) THEN
              udStationId := pStation^.GetId();
              RETURN;
            END_IF;
          END_IF;
      END_IF;
    END_FOR;
  END_IF;

END_FUNCTION
(*
  Ermittelt aus StationsNummer  (ID) den Stationsnamen
  status 0 = gefunden, -1 = nicht gefunden
*)
FUNCTION GLOBAL LDR_MM_StatNrGetName
  VAR_INPUT
    udStationId : UDINT;
    pszName : ^CHAR; // buffer auf name (kann max 255 sein)
  END_VAR
  VAR_OUTPUT
    status : DINT;
  END_VAR
  VAR
    pStation 	    : ^MMStation; // Zeiger auf Station
  END_VAR
  
  status := -1;
  
  IF (m_pMultiMasterStationReader = NIL) THEN
    RETURN;
  END_IF;
  
  pStation := m_pMultiMasterStationReader^.GetStationAt(udStationId);
  IF (pStation <> NIL) THEN
  
    _strcpy(pszName, #pStation^.m_szName[0]);
    status := 0;
  
  END_IF;

END_FUNCTION
(*
  Stoppt die Verbindung zu der Station mit der angebenen Id
  Da die Funktion in einem Thread ausgeführt wird, kann die Funktion 
  verzögert ausgeführt werden
*)
FUNCTION GLOBAL LDR_MM_StatNrConnStop
VAR_INPUT
  udStationId : UDINT; // Id der Station
END_VAR
VAR_OUTPUT
  status    : DINT; //  0=Anfrage gesendet
END_VAR
VAR
  cmd : _MMThreadCmdLine;
END_VAR
  
  cmd.cmd := MM_DISCONNECT_STATION;
  cmd.udStationId := udStationId;
  cmd.SvrHandle := 0;
  
  status := MMThread_AddCmd(#cmd);

END_FUNCTION
(*
  Startet den Verbindungsaufbau zu der Station mit der angebenen Id
  Da die Funktion in einem Thread ausgeführt wird, kann die Funktion 
  verzögert ausgeführt werden
*)
FUNCTION GLOBAL LDR_MM_StatNrConnStart
VAR_INPUT
  udStationId : UDINT;// Id der Station
END_VAR
VAR_OUTPUT
  status    : DINT; // 0=Anfrage gesendet
END_VAR
VAR
  cmd : _MMThreadCmdLine;
END_VAR
   
  cmd.cmd := MM_CONNECT_STATION;
  cmd.udStationId := udStationId;
  cmd.SvrHandle := 0;

  status := MMThread_AddCmd(#cmd);

END_FUNCTION
(*
  Setzt einen neuen Verbindungsstring für die Station mit der angebenen Id
  und führt einen Connect aus
  Da die Funktion in einem Thread ausgeführt wird, kann die Funktion 
  verzögert ausgeführt werden
*)
FUNCTION GLOBAL LDR_MM_StatNrConnSetStr
VAR_INPUT
  udStationId : UDINT;// Id der Station
  pszConn     : ^CHAR;// Zeiger auf den neuen Connection 0term. String
END_VAR
VAR_OUTPUT
  status    : DINT; // 0=Anfrage gesendet
END_VAR
VAR
  cmd : _MMThreadCmdLine;
	pStation : ^MMStation;
END_VAR
   
  cmd.cmd := MM_SETCONNSTR;
  cmd.udStationId := udStationId;
  _strcpy(#cmd.caConn[0], pszConn);
  cmd.SvrHandle := 0;
  
  MM_TRACE_S("LDR_MM_StatNrConnSetStr %s", pszConn, 0, 0);
  
  status := -1;
  IF (m_pMultiMasterStationReader <> NIL) THEN
    pStation := m_pMultiMasterStationReader^.GetStationAt(udStationId);
    IF (pStation <> NIL) THEN
      // Das Flag m_changingConnStr wird auf TRUE gesetzt und erst wenn der Befehl MM_SETCONNSTR 
      // asynchron  abgearbeitet wurde, dann wieder auf FALSE. Damit hat die LDR_MM_StatNrIsConnected 
      // Funktion die Möglichkeit, den Wert 'Offline' zurückzugeben, solange die neue Adresse nicht 
      // übernommen wurde.
      pStation^.m_changingConnStr := TRUE;
      status := MMThread_AddCmd(#cmd);
      IF status <> 1 THEN
        pStation^.m_changingConnStr := FALSE;
      END_IF;
    END_IF;
  END_IF;

END_FUNCTION
(*
  Liefert den Verbindungsstring für die Station mit der angebenen Id
  Achtung! Liefert NIL wenn Station nicht gefunden wurde
*)
FUNCTION GLOBAL LDR_MM_StatNrConnGetStr
VAR_INPUT
  udStationId : UDINT;// Id der Station
  pszConn     : ^CHAR;// Zeiger auf den neuen Connection 0term. String
END_VAR
VAR_OUTPUT
  status    : DINT;
END_VAR
VAR
	pStation : ^MMStation;
END_VAR

  status := -1;
  IF (m_pMultiMasterStationReader <> NIL) THEN
    pStation := m_pMultiMasterStationReader^.GetStationAt(udStationId);
    IF (pStation <> NIL) THEN
      pStation^.GetConnStr(pszConn);
      status := 0;
    END_IF;
  END_IF;

END_FUNCTION
(*
  Prüft ob die Station mit der angebenen Id verbunden ist
  status 0=Connected, -1=not connected, -2: not found, -3 nicht alle Server initalisiert
*)
FUNCTION GLOBAL LDR_MM_StatNrIsConnected 
  VAR_INPUT
    udStationId : UDINT;// Id der Station
  END_VAR
  VAR_OUTPUT
    status    : DINT; // wert aus _MMState
  END_VAR
  VAR
    pStation : ^MMStation;
  END_VAR
   
   status := -1;

  IF (m_pMultiMasterStationReader <> NIL) THEN
    pStation := m_pMultiMasterStationReader^.GetStationAt(udStationId);
    IF (pStation <> NIL) THEN
      IF MM_firstInitActive THEN
        // Während dem Aufruf der letzten Init Methoden wird der Wert vor dem Aufruf 
        // der letzten Init-Methoden zurückgegeben. Damit kann z.B. eine Alarm Klasse 
        // in der letzten Init feststellen, ob der Aufruf der übrigen letzten Inits 
        // in einem Zustand erfolgte, bei dem alle Server vorhanden waren.
        status := pStation^.m_udState_preFirstInit$DINT;
      ELSE
        status := pStation^.m_udState$DINT;
      END_IF;
      // Wenn der Verbindungsstring gerade geändert wird (mit LDR_MM_StatNrConnSetStr), 
      // dann wird der Status auf max. 0 (=Offline) begrenzt.
      IF status > 0 & pStation^.m_changingConnStr THEN
        status := 0;
      END_IF;
    END_IF;
  END_IF;

END_FUNCTION
(*
  Prüft bei der Station mit der angebenen Id alle required Server initialisiert sind.
*)
FUNCTION GLOBAL LDR_MM_AreAllReqInitialised 
  VAR_INPUT
    udStationId : UDINT;// Id der Station
  END_VAR
  VAR_OUTPUT
    status    : BOOL;
  END_VAR
  VAR
    pStation : ^MMStation;
  END_VAR
   
  status := FALSE;

  IF (m_pMultiMasterStationReader <> NIL) THEN
    pStation := m_pMultiMasterStationReader^.GetStationAt(udStationId);
    IF (pStation <> NIL) THEN
      IF MM_firstInitActive THEN
        // Während dem Aufruf der letzten Init Methoden wird der Wert vor dem Aufruf 
        // der letzten Init-Methoden zurückgegeben. Damit kann z.B. eine Alarm Klasse 
        // in der letzten Init feststellen, ob der Aufruf der übrigen letzten Inits 
        // in einem Zustand erfolgte, bei dem alle Server vorhanden waren.
        status := pStation^.m_allReqInitialised_preFirstInit;
      ELSE
        status := pStation^.GetAllReqInitialised();
      END_IF;
    END_IF;
  END_IF;

END_FUNCTION
(*
  Prüft ob der Server der Station mit der angebenen Id verbunden ist
  status: 0=Server initialisiert, -1=Online aber nicht initialisiert, -2=Offline
  
  Sucht das MMServer Objekt und gibt den Initialisierungsstatus zurück.
  Falls ein Server mit RequiredClients verbunden ist, 
  muss der Wert des Server einmal eingelesen worden sein um als Verbunden zu gelten.
*)
FUNCTION GLOBAL LDR_MM_SvrIsConnected 
VAR_INPUT
  udStationId : UDINT; // Id der Station
  pszSvrName    : ^CHAR; // Name des Servers
END_VAR
VAR_OUTPUT
  status    : DINT; // 0=Server initialisiert, -1=Online aber nicht initialisiert, -2=Offline
END_VAR
VAR
  pSrv     : ^MMServer;
END_VAR
   
  status := -2; // nicht online
  
  IF (pszSvrName = NIL) THEN
    status := -3;
    RETURN;
  END_IF;

   
  pSrv := FindValidMultiMasterSymbol(udStationId, pszSvrName);
  IF (pSrv <> NIL) THEN
    IF ((pSrv^.m_udLasalId > 0) & (pSrv^.IsInitializedFlagSet() = TRUE)) THEN
      status := 0; //initialisiert
    ELSIF (pSrv^.m_udLasalId > 0) THEN
      status := -1; // server nicht initalisiert
    END_IF;
  END_IF;

END_FUNCTION
(*
  Liefert ServerHandle, gültig wenn ungleich 0
*)
FUNCTION GLOBAL LDR_MM_SvrGetHandle 
  VAR_INPUT
    udStationId : UDINT; 
    pszSvrName    : ^CHAR; 
  END_VAR
  VAR_OUTPUT
    udSvrHandle   : UDINT; 
  END_VAR
  VAR
    pSrv     : ^MMServer;
  END_VAR
  
  udSvrHandle := 0;
  
  IF (pszSvrName = NIL) THEN
    RETURN;
  END_IF;

  // server suchen
  pSrv := FindValidMultiMasterSymbol(udStationId, pszSvrName);
  IF (pSrv <> NIL) THEN
    // handle holen
    udSvrHandle := pSrv$UDINT;
  END_IF;

END_FUNCTION
(*
  Liest die Daten aus MultiMaster-Data-In, bei n-Byte oder String Servern wird der Handle zurückgeliefert
  status <0 = Fehler
         ansonsten Zeitraum seit letzer Änderung des Serverwertes
*)
FUNCTION GLOBAL LDR_MM_ReadSvrByHandle 
  VAR_INPUT
    udSvrHandle      : UDINT; 
    pBuffer     : ^UDINT;
  END_VAR
  VAR_OUTPUT
    status    : DINT; 
  END_VAR
  VAR
    opsCur   : UDINT;
    pSvrObj     : ^MMServer;
  END_VAR

  status := -1;
  
  IF ((pBuffer = NIL) | (udSvrHandle = 0)) THEN
   RETURN;
  END_IF;

  opsCur := ops.tAbsolute;
  
  pSvrObj := udSvrHandle$^MMServer;
  pBuffer^ := pSvrObj^.Data.Read();

  status := TO_DINT((opsCur - pSvrObj^.m_OpsAbs));

END_FUNCTION  
(*
  Liest die Daten aus MultiMaster-Data-In, bei n-Byte oder String Servern wird der Handle zurückgeliefert
  status <0 = Fehler
         ansonsten Zeitraum seit letzer Änderung des Serverwertes
*)
FUNCTION GLOBAL LDR_MM_ReadSvr
  VAR_INPUT
    udStationId : UDINT; 
    pszSvrName    : ^CHAR;
    pBuffer     : ^UDINT; 
  END_VAR
  VAR_OUTPUT
    status    : DINT;
  END_VAR
  VAR
    pSrv     : ^MMServer;
  END_VAR
  
  status := -1;
  
  IF ((pBuffer = NIL) | (pszSvrName = NIL)) THEN
   RETURN;
  END_IF;

  pSrv := FindValidMultiMasterSymbol(udStationId, pszSvrName);

  IF (pSrv <> NIL) THEN
    status := LDR_MM_ReadSvrByHandle(pSrv$UDINT, pBuffer);
  END_IF;

END_FUNCTION
(*
  Liefert ServerHandle, gültig wenn ungleich 0
*)
FUNCTION GLOBAL LDR_MM_SvrGetHandleFromCmpName 
  VAR_INPUT
    pszCmpName  : ^CHAR; 
  END_VAR
  VAR_OUTPUT
    udSvrHandle : UDINT; 
  END_VAR
  VAR
    eChMode			: ChMode;	
    pObj        : VirtualBase;
    pObjR       : VirtualBase;
    ppObj       : pVirtualBase;
  END_VAR
  
  ppObj := #pObjR;

  udSvrHandle := 0;

  IF (pszCmpName = NIL) THEN
    RETURN;
  END_IF;

  eChMode := _LookUpMMServer(#pObj, pszCmpName, NIL, #ppObj);

  IF (eChMode <> _CH_NONE) THEN
    udSvrHandle := ppObj$UDINT;
  END_IF;

END_FUNCTION
(*
  Ermittelt aus dem Serverhandle die Stations ID (falls gewünscht)
  und den Servernamen
*)
FUNCTION GLOBAL LDR_MM_SvrGetNameFromHandle
  VAR_INPUT
    udSvrHandle      : UDINT;
    udStationId : ^UDINT; 
    pszSvrName    : ^CHAR; 
  END_VAR
  VAR_OUTPUT 
    bFound      : BOOL;
  END_VAR
  VAR
    pSvrObj   : ^MMServer;
  END_VAR
  
  // rückgabe wert initialisieren
  bFound := FALSE;
  
  // Prüfungen ob alle werte gültig sind und aktion ausgeführt werden darf
  IF ((pszSvrName = NIL) | (udSvrHandle = 0) | (m_pMMServer = NIL)) THEN
    RETURN;
  END_IF;

  pSvrObj := udSvrHandle$^MMServer;
  bFound := TRUE;

  pSvrObj^.GetName(pszSvrName);

  IF ((udStationId <> NIL) & (pSvrObj^.m_pStation <> NIL)) THEN
    // falls gewünscht, station id ermitteln
    udStationId^ := pSvrObj^.m_pStation$^MMStation^.GetId();
  END_IF;

END_FUNCTION
(*
  Sends NewInst Cmd to MMServer
*)
FUNCTION GLOBAL LDR_MM_SvrNewInst 
  VAR_INPUT
    udSvrHandle : UDINT;
    pPara 	: ^CmdStruct;
    pResult : ^Results;
  END_VAR
  VAR_OUTPUT
    ret_code 	: IprStates; 
  END_VAR
  VAR
    pSvrObj         : ^MMServer;
    pNewInstParams  : ^sNewInst;
  END_VAR

  ret_code := ERROR;
  
  IF (udSvrHandle = 0) THEN
    RETURN;
  END_IF;
  
  pSvrObj := udSvrHandle$^MMServer;

  IF ((pSvrObj^.m_pStation = NIL) | ((pSvrObj^.m_flFlags AND _MM_PROP_NEWINST) <> _MM_PROP_NEWINST)) THEN
    RETURN;
  END_IF;
  
  pNewInstParams := pSvrObj^.GetNewInstParams(pPara, pResult, TRUE);
  IF (pNewInstParams <> NIL) THEN
    ret_code := pSvrObj^.SendNewInst(pNewInstParams); // new Inst senden
    pNewInstParams^.IprState := ret_code;
  END_IF;
  
END_FUNCTION
(*
  GetState of NewInst Cmd from MMServer
*)
FUNCTION GLOBAL LDR_MM_SvrGetState 
  VAR_INPUT
    udSvrHandle : UDINT;
    pPara 	: ^CmdStruct;
    pResult : ^Results;
  END_VAR
  VAR_OUTPUT
    ret_code 	: IprStates; 
  END_VAR
  VAR
    pSvrObj         : ^MMServer;
  END_VAR

  ret_code := ERROR;
  
  IF (udSvrHandle = 0) THEN
    RETURN;
  END_IF;
  
  pSvrObj := udSvrHandle$^MMServer;

  IF ((pSvrObj^.m_pStation = NIL) | ((pSvrObj^.m_flFlags AND _MM_PROP_NEWINST) <> _MM_PROP_NEWINST)) THEN
    RETURN;
  END_IF;
  
  ret_code := pSvrObj^.GetNewInstState(pPara, pResult);
  
END_FUNCTION
(*
  Prüft ob alle required Server bei Stations, bei denen auf die required Server 
  gewartet sind, initialisiert sind.
  Wird in der Initphase dafür verwendet um zu warten, bis alle required Server 
  initialisiert sind oder ein Timeoutfehler auftritt.
*)
FUNCTION GLOBAL MM_AreAllReqInitialised 
  VAR_INPUT
    udStartTime_ms : UDINT; // Startzeitpunkg für die Timeoutprüfung
  END_VAR
	VAR_OUTPUT
    allReqInitialised : BOOL;
	END_VAR
  VAR
  	i             : UDINT; // schleifenzähler
    cntStations   : UDINT; // Anzahl der Stationen
    pStation : ^MMStation;
  END_VAR

  // Anzahl der Stationen
  cntStations := m_pMultiMasterStationReader^.GetStationsCount();
  
  allReqInitialised := TRUE;
  // alle Stationen durchlaufen
  IF ((cntStations > 0) & (cntStations < -1$UDINT)) THEN
    cntStations -= 1;
    FOR i:=0 TO cntStations BY 1 DO
      pStation := m_pMultiMasterStationReader^.GetStationAt(i);
      IF (ops.tabsolute - udStartTime_ms) >= pStation^.m_waitForReqTimeout_ms THEN
        // Der Timeoutwert fürs Warten ist erreicht -> keine weitere Prüfung
        EXIT;
      END_IF;
      IF pStation^.GetAllReqInitialised() = FALSE THEN
        allReqInitialised := FALSE;
        RETURN;
      END_IF;
    END_FOR;
  END_IF;

END_FUNCTION
(*
  Setzt bei einer Station den Timeoutwert fürs Warten auf die Required Clients. 
	Der Default-Wert ist 0, d.h. es wird nicht gewartet.
*)
FUNCTION GLOBAL LDR_MM_SetWaitForReqTimeout 
  VAR_INPUT
    udStationId : UDINT;// Id der Station
    waitForReqTimeout_ms : UDINT;
  END_VAR
  VAR_OUTPUT
    status    : DINT; // wert aus _MMState
  END_VAR
  VAR
    pStation : ^MMStation;
  END_VAR
   
  status := -1;

  IF (m_pMultiMasterStationReader <> NIL) THEN
    pStation := m_pMultiMasterStationReader^.GetStationAt(udStationId);
    IF (pStation <> NIL) THEN
      status := 0;
      pStation^.m_waitForReqTimeout_ms := waitForReqTimeout_ms;
    END_IF;
  END_IF;

END_FUNCTION

(*
  Funktion, die vor dem Aufruf der letzten Init-Methoden aufgerufen wird. 
  Hier wird der Station-Zustand gemerkt. Dieser gemerkte Zustand wird dann 
  während dem Aufruf der letzten Init-Methoden zurückgegeben.
  Damit kann z.B. eine Alarm Klasse in der letzten Init feststellen, ob der 
  Aufruf der übrigen letzten Inits in einem Zustand erfolgte, bei dem alle 
  Server vorhanden waren.
*)
FUNCTION GLOBAL MM_PrepareForFirstInit
  VAR
  	i             : UDINT; // schleifenzähler
    cntStations   : UDINT; // Anzahl der Stationen
    pStation : ^MMStation;
  END_VAR

  // Anzahl der Stationen
  cntStations := m_pMultiMasterStationReader^.GetStationsCount();
  
  // alle Stationen durchlaufen
  IF ((cntStations > 0) & (cntStations < -1$UDINT)) THEN
    cntStations -= 1;
    FOR i:=0 TO cntStations BY 1 DO
      pStation := m_pMultiMasterStationReader^.GetStationAt(i);
      pStation^.m_udState_preFirstInit := pStation^.m_udState;
      pStation^.m_allReqInitialised_preFirstInit := pStation^.GetAllReqInitialised();
    END_FOR;
  END_IF;

  MM_firstInitActive := TRUE;
  
END_FUNCTION

(*
  Funktion, die nach dem Aufruf der letzten Init-Methoden aufgerufen wird. 
*)
FUNCTION GLOBAL MM_FirstInitFinished

  MM_firstInitActive := FALSE;

END_FUNCTION
