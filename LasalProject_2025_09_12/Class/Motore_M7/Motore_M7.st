//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Motore_M7"
	Revision           = "0.0"
	GUID               = "{D96A6811-DD7C-4B2E-AE04-965D1B021B08}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "100 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(630,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{4F907B50-7FED-44C3-81E5-8472349EA5D5}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ErrorState" GUID="{CF820C21-8E40-4E2D-AA74-13914E345FDC}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="MotoreM7Step" GUID="{8C8C522F-0461-40FA-9BB1-20FDF040C929}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="s_M7_Coupled" GUID="{3619655E-5D9B-4F4A-A937-815BFE91709F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="s_M7_Homed" GUID="{457E2EEA-5A2E-4C23-94E2-6ED2AE7DC257}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="Comando_M7" Required="true" Internal="false"/>
		<Client Name="M7_LS_1" Required="false" Internal="false"/>
		<Client Name="M7_LS_2" Required="false" Internal="false"/>
		<Client Name="SetPositionController" Required="true" Internal="false"/>
		<Client Name="Stato_to_M4" Required="true" Internal="false"/>
	</Channels>
</Class>
*)
Motore_M7 : CLASS
	TYPE
	  t_sequence_Cmd_motore_M7 :  //! <Type Public="true" Name="t_sequence_Cmd_motore_M7"/>
	  (
	    Cmd_motore_M7_idle,
	    Cmd_motore_M7_homing,
	    Cmd_motore_M7_phasing,
	    Cmd_motore_M7_movement,
	    Cmd_motore_M7_reset,
	    Cmd_motore_M7_Error,
	    Cmd_motore_M7_stop,
	    Cmd_motore_M7_stopped
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	MotoreM7Step 	: SvrCh_t_sequence_Cmd_motore_M7_PTofCls_Motore_M7;
	ErrorState 	: SvrCh__LMCAXIS_ERROR;
	s_M7_Homed 	: SvrCh_DINT;
	s_M7_Coupled 	: SvrCh_DINT;
  //Clients:
	Comando_M7 	: CltChCmd__LMCAxis;
	Stato_to_M4 	: CltChCmd_Motore_M4;
	M7_LS_1 	: CltCh_DINT;
	M7_LS_2 	: CltCh_DINT;
	SetPositionController 	: CltCh_DINT;
  //Variables:
		M7_homed 	: BOOL;
		M7_InBlockPosition 	: BOOL;
		MotoreM8_Motion_Type 	: BOOL;
		HomingStep 	: DINT;
		v_ErrorState 	: DINT;
		v_M7_LS_1 	: DINT;
		v_M7_LS_2 	: DINT;
		M7_coupled 	: DINT;
		Movement_Step 	: DINT;
		v_StartHomingCase 	: DINT;
		v_StartMovementCase 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetSequenceState
		VAR_INPUT
			Cmd_motore 	: t_sequence_Cmd_motore_M7;
			Motion_type 	: BOOL;
			StartCase 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetHomedState
		VAR_OUTPUT
			Homed 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetCoupledState
		VAR_OUTPUT
			Coupled 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetErrorState
		VAR_OUTPUT
			ErrorState 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL s_M7_Homed::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _LMCAxis
#pragma usingLtd Motore_M4


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Motore_M7::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_MOTORE_M7
0$UINT, 0$UINT, (SIZEOF(::Motore_M7))$UINT, 
5$UINT, 5$UINT, 0$UINT, 
TO_UDINT(1684970700), "Motore_M7", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Motore_M7.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::Motore_M7.MotoreM7Step.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3571607657), "MotoreM7Step", 
(::Motore_M7.ErrorState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2975757027), "ErrorState", 
(::Motore_M7.s_M7_Homed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(298800865), "s_M7_Homed", 
(::Motore_M7.s_M7_Coupled.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1128822073), "s_M7_Coupled", 
//Clients:
(::Motore_M7.Comando_M7.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(102011334), "Comando_M7", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 114$UINT, 
(::Motore_M7.Stato_to_M4.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1616770081), "Stato_to_M4", TO_UDINT(4251438454), "Motore_M4", 0$UINT, 0$UINT, 
(::Motore_M7.M7_LS_1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3360264709), "M7_LS_1", 
(::Motore_M7.M7_LS_2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1363198911), "M7_LS_2", 
(::Motore_M7.SetPositionController.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(405540383), "SetPositionController", 
END_FUNCTION


#define USER_CNT_Motore_M7 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Motore_M7] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Motore_M7::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Motore_M7, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_M7_Homed.pMeth			:= StoreMethod( #s_M7_Homed::Read(), #M_WR_DIRECT() );
	IF s_M7_Homed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL Motore_M7::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  v_M7_LS_1:=M7_LS_1.Read();
  v_M7_LS_2:=M7_LS_2.Read();

  s_M7_Homed.Write(input:=M7_homed);
  s_M7_Coupled.Write(input:=M7_coupled);
  
  case MotoreM7Step of
  
    Cmd_motore_M7_idle:
    

  
    Cmd_motore_M7_homing:

    
    case HomingStep of
    0://idle
    
    10:
    
      if Comando_M7.AxisStatus.PowerOn=0 & Comando_M7.AxisStatus.ReadyToPowerOn then
        Comando_M7.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_POS_DIR);
        HomingStep:=20;
      end_if;
      
    20:
    //se LS_retratto=true allora
    //  muoviti in avanti con una data velocità/accelerazione 
    //HomingStep:=30;
    
    //se LS_estratto=true allora - sono già in posizione
    //  fine movimento
    //HomingStep:=40;
    
    //se LS_retratto e LS_estratto allora -sono in una posizione di mezzo
    //HomingStep:=30;
    
    30:
    //devo leggere client associato all'input del modulo ST-151
    //se LS=1 allora
    //Comando_M7.StopMove(Decel:=500000, Jerk:=500000);
    //SPENGO
    //HomingStep:=50;
    
    40://E' già in posizione allora vado a HomingStep:=50;
    //POWER OFF
    //oppure si può pensare di bypassare questo step e andare direttamente a step 50 senza passare per il 40
      
    50:
        M7_homed:=TRUE;
        M7_InBlockPosition:=TRUE;
        MotoreM7Step:=Cmd_motore_M7_idle;
        Stato_to_M4.GetM8Status(Status:=M7_InBlockPosition);
    end_case;
    
//============================================================================
    
    Cmd_motore_M7_movement:

    //I MOVIMENTI CHE PUO' FARE SONO CHE LO PORTA IN ACCOPPIATO/DISACCOPPIATO | 0: DISACCOPPIATO->ACCOPPIATO | 1: ACCOPPIATO->DISACCOPPIATO

    if Comando_M7.AxisError.HwError then
      v_ErrorState:=1;   
      MotoreM7Step:=Cmd_motore_M7_Error;
    end_if;
  
    if MotoreM8_Motion_Type=0 then//MOVIMENTO PER ACCOPPIARE

      if v_M7_LS_2 & M7_coupled then // condizione di M1_Coupled perchè altrimenti quando viene attivato il LS questa condizione viene attivata e il case interno non viene terminato
        //Motore si trova già in posizione di accoppiamento
        M7_coupled:=true;  
      
      elsif M7_coupled=0 then
      
        
        case Movement_Step of
      
          0: //IDLE
          Movement_Step:=v_StartMovementCase;
        
          10:
        
          if (Comando_M7.AxisStatus.PowerOn=0) & (Comando_M7.AxisStatus.ReadyToPowerOn) then
              Comando_M7.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
          elsif Comando_M7.AxisStatus.PowerOn then
            Movement_Step:=20;
          end_if;
        
          20:
            
          Comando_M7.MoveEndless(Speed:=-V_M8, Accel:=-A_M8, Jerk:=-J_M8);
          Movement_Step:=30;

          30:
          if v_M7_LS_2 then
            Comando_M7.StopMove(Decel:=A_M8, Jerk:=J_M8);
            Movement_Step:=40;
      
          end_if;
          
            
          40:
          if Comando_M7.AxisStatus.Standstill then
          SetPositionController.Write(input:=0);
            M7_InBlockPosition:=TRUE;
            M7_coupled:=TRUE;
            MotoreM7Step:=Cmd_motore_M7_idle;
            Stato_to_M4.GetM8Status(Status:=M7_InBlockPosition);
            Movement_Step:=0;
            v_StartMovementCase:=0;
            Comando_M7.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
          end_if;
          
        end_case;
      
      end_if;
    
    elsif MotoreM8_Motion_Type=1 then //MOVIMENTO PER DISACCOPPIARE
    
      if v_M7_LS_1 & M7_coupled=0 then
        //Motore si trova già in posizione di accoppiamento
        M7_coupled:=false;  
      
      elsif M7_coupled then
        
        case Movement_Step of
      
        0: //IDLE
        Movement_Step:=v_StartMovementCase;
        
        10: //case per accendere il motore nel caso in cui sia spento
        
          if (Comando_M7.AxisStatus.PowerOn=0) & (Comando_M7.AxisStatus.ReadyToPowerOn) then
              Comando_M7.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
          elsif Comando_M7.AxisStatus.PowerOn then
            Movement_Step:=20;
          end_if;
        
        20:
            Comando_M7.MoveAbsolute(Position:=15000000, Speed:=V_M8, Accel:=A_M8, Decel:=A_M8, Jerk:=J_M8);
            Movement_Step:=30; 
        30:
        
          if v_M7_LS_1 | Comando_M7.AxisStatus.InPosition then
            Comando_M7.StopMove(Decel:=1000000, Jerk:=10000000);
            Movement_Step:=40;
          end_if;
          
        40:
          if Comando_M7.AxisStatus.Standstill then
            M7_InBlockPosition:=FALSE;
            M7_coupled:=FALSE;
            MotoreM7Step:=Cmd_motore_M7_idle;
            Stato_to_M4.GetM8Status(Status:=M7_InBlockPosition);
            Movement_Step:=0;
            v_StartMovementCase:=0;
            Comando_M7.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
          end_if;
          
          
        end_case;
      
      end_if;
    
    else
      //errore
      MotoreM7Step:=Cmd_motore_M7_reset;
    
    end_if;
//===============================================================================
    Cmd_motore_M7_Error:
    
      ErrorState:=Comando_M7.AxisError; //AGGIORNAMENTO SERVER
      MotoreM7Step:=Cmd_motore_M7_stop;
//========================================================================      
    Cmd_motore_M7_stop:
      
      if Comando_M7.AxisStatus.Standstill & Comando_M7.AxisStatus.PowerOn=0 then
        MotoreM7Step:=Cmd_motore_M7_stopped;
      else
        Comando_M7.QuickStop(Decel:=1000000);//se asse in errore non esegue neppure l'operazione perchè spento (e in errore)
        Comando_M7.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
      end_if;
//========================================================================      
    Cmd_motore_M7_stopped:
    //ATTESA RESET
    
//========================================================================    
    Cmd_motore_M7_reset:
      Comando_M7.QuitError();
      M7_homed:=FALSE;
      v_ErrorState:=0; 
      if Comando_M7.AxisStatus.FiltRdy then
        MotoreM7Step:=Cmd_motore_M7_idle;
      end_if;

      M7_InBlockPosition:=FALSE;
      MotoreM8_Motion_Type:=FALSE;
      v_StartHomingCase:=0;
      v_StartMovementCase:=0;
      M7_coupled:=0;
      v_ErrorState:=0;
      HomingStep:=0;
//======================================================================== 
  end_case;

	state := READY;
END_FUNCTION


FUNCTION GLOBAL Motore_M7::SetSequenceState
	VAR_INPUT
		Cmd_motore 	: t_sequence_Cmd_motore_M7;
		Motion_type 	: BOOL;
		StartCase 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  
  MotoreM7Step:=Cmd_motore;
  MotoreM8_Motion_Type:=Motion_type;
  
  if MotoreM7Step=Cmd_motore_M7_homing then
    v_StartHomingCase:=StartCase;
  elsif MotoreM7Step=Cmd_motore_M7_movement then
    v_StartMovementCase:=StartCase;
  end_if;
  
  retcode:=true;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M7::Init
M7_homed:=FALSE;
M7_InBlockPosition:=FALSE;
MotoreM8_Motion_Type:=FALSE;

v_StartHomingCase:=0;
v_StartMovementCase:=0;


M7_coupled:=0;

v_ErrorState:=0;

END_FUNCTION


FUNCTION GLOBAL Motore_M7::GetHomedState
	VAR_OUTPUT
		Homed 	: BOOL;
	END_VAR
  
  Homed:=M7_homed;
END_FUNCTION


FUNCTION GLOBAL Motore_M7::GetCoupledState
	VAR_OUTPUT
		Coupled 	: DINT;
	END_VAR
  Coupled:=M7_InBlockPosition;
END_FUNCTION


FUNCTION GLOBAL Motore_M7::GetErrorState
	VAR_OUTPUT
		ErrorState 	: DINT;
	END_VAR
ErrorState:=v_ErrorState;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M7::s_M7_Homed::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	output := s_M7_Homed;

END_FUNCTION
