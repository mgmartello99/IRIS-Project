//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "IprReader"
	Revision           = "0.0"
	GUID               = "{7D1C4B2E-E438-425D-82CE-ED4CC0263055}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{922E67A0-5030-4979-A679-D03201D3FC28}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
</Class>
*)
IprReader : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		pTable 	: ^void;
		pIpr 	: ^CHAR;
		nMaxProgs 	: UDINT;
  //Functions:
	
	FUNCTION GLOBAL IprInit
		VAR_INPUT
			pIprTab 	: ^void;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL LoadProgs
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION InitVariables
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION LoadRamEx
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL CheckIprProgs
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION LoadProgsFromTable
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB IprReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_IPRREADER
0$UINT, 0$UINT, (SIZEOF(::IprReader))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(4166075827), "IprReader", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::IprReader.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
END_FUNCTION


#define USER_CNT_IprReader 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_IprReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION IprReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include ".\RTOS_MemIntern.h"
//#include ".\RTOS_PrivDefs.h"
#include ".\include\L2_Ipr.h"
#include ".\RTOS_PrivHeader.h"

#pragma using ProgIp
#pragma using ClassReader
#pragma using ProjectReader
#pragma using ObjectReader

#pragma using ProgMgr
#pragma using IprMgr


// Initialize the interpreter programs, called from LoadProgs;
FUNCTION GLOBAL IprReader::IprInit
	VAR_INPUT
		pIprTab 	: ^void;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    i			  : UINT;
    pp			: pProgIp;
    pDir		: ^pProgIp;
    ppBp		: ^RamEx;
    szName	: ARRAY [0..80] OF CHAR;
  END_VAR

  ok  := FALSE;

  pTable  := pIprTab;
  pIpr    := pTable $ ^char;
  
  F_RD_UDINT(#pIpr);    // Tabellenlänge
  F_RD_UINT (#pIpr);    // _K_IPR
  
  nMaxProgs  := F_RD_UINT(#pIpr);
  IF nMaxProgs > MAX_IP_PROGS THEN
    RETURN;
  END_IF;
  
	OPS.pSequDir := _alloc_align(IprDir.pFirstIpr + MAX_IP_PROGS*SIZEOF(pVoid)) $ ^IprDir;
	IF OPS.pSequDir = NIL THEN
		RETURN;
	END_IF;

	Ops.pSequDir^.uiIprCnt	:= nMaxProgs $ UINT;
	IF nMaxProgs = 0 THEN
    ok  := TRUE;
		RETURN;
	END_IF;
	pDir	:= #Ops.pSequDir^.pFirstIpr;

  IF LoadRamEx() = FALSE THEN
    ok  := FALSE;
    RETURN;
  END_IF;

	_strcpy(#szName[0], "ProgIp");
	i		:= 0;
  
	WHILE i < nMaxProgs DO

		_itoa(i, #szName[6]);
		pp:= ObjectReader::NewObj("ProgIp", #szName[0]) $ ^ProgIp;//create a new interpreter
		IF pp = NIL THEN
			RETURN;
		END_IF;
    
    // Embedded Client anlegen. Das muß im Gegensatz zu Lasal1 manuell gemacht 
    // werden, weil kein ON existiert.
    _strcat(#szName[0], "\m_Breakpoints");
    ppBp := ObjectReader::NewObj("RamEx", #szName[0]) $ ^RamEx;
    IF ppBp = NIL THEN
      RETURN;
    END_IF;
    pp^.m_Breakpoints.pCh := ppBp $ ^SvrChCmd_UDINT;
    pp^.m_Breakpoints.pCmd := ppBp;

		//add it to the "ops" struct
		pDir^	:= pp;
		pDir	+= sizeof(pProgIp);

		i		+= 1;

	END_WHILE;
  
  ok  := TRUE;

END_FUNCTION

FUNCTION GLOBAL IprReader::LoadProgs
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    nProg       ,
    udLen       : UDINT;
    szLexem     : ARRAY[0..NLNG] OF char;
    pProg1 : ^void;
  END_VAR
  
  ok  := FALSE;

  // Liste mit Zeigern auf die Interpreter-Programm-Pointer erstellen
  udLen := MAX_IP_PROGS * (2*sizeof(pNewSubPrgHead));
	Ops.pProg	:= _alloc_align(PrgHead.pProg1 + udLen)$^PrgHead;
	IF ops.pProg = NIL THEN
		RETURN;
	END_IF;

	Ops.pProg^.uiProgs		:= nMaxProgs $ UINT;

	Ops.pProg^.pTable		  := pTable;
	Ops.pProg^.udOffInit	:= pIpr $ UDINT - pTable $ UDINT;
  pProg1                := ProgMgr::GetProgramPtr(0);
	_memset(pProg1, 0, udLen);

	// create regulary programs
	nProg	:= 0;
	WHILE nProg < nMaxProgs DO

		// only the regulary programs have got some init data
    F_RD_UINT(#pIpr);   // Lade-Art und ?? überlesen
    IF ScanLexem(#pIpr, #szLexem[0]) <> SN_ID THEN
      RETURN;
    END_IF;
    F_RD_USINT(#pIpr);  // Abschluss - Nuller überlesen

		IF ProgMgr::AllocProg(MIN_PROG_SIZE, nProg, #szLexem[0]) = FALSE THEN
			RETURN;
		END_IF;
		nProg	+= 1;
	END_WHILE;

  
  // create temporary programs
	nProg	:= MAX_IP_PROGS;
	WHILE nProg < (MAX_IP_PROGS + nMaxProgs) DO

		_strcpy(#szLexem[0], "LSL_IPR_Prog00 ");  // Name für gespiegelte IPR - Programme
		_itoa(nProg, #szLexem[12]);            // Nummer eintragen

		IF ProgMgr::AllocProg(MIN_PROG_SIZE, nProg, #szLexem[0]) = FALSE THEN
			RETURN;
		END_IF;
		nProg	+= 1;
	END_WHILE;

	// RamEx-Objects will be feed with data during startup,
  // data meaning ipr - program - code

  ok  := InitVariables();

END_FUNCTION


FUNCTION IprReader::InitVariables
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    nProg     : UDINT;
    pIpr      : ^ProgIp;
  END_VAR

	// Init Variables of all Interpreters			
	nProg := Ops.pProg^.uiProgs;
	WHILE nProg DO
		nProg -= 1;
		pIpr := IprMgr::GetInterpreter(nProg);
		IF pIpr <> NIL THEN
			pIpr^.InitVariables();
		END_IF;
	END_WHILE;

  ok  := TRUE;
  
END_FUNCTION

// Prüft, ob die benötigten Klassen RamEx und ProgIp im Projekt vorhanden sind
FUNCTION IprReader::LoadRamEx
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
   		pReqCls : ^ClsHdr;
	END_VAR
  
  	ok  := FALSE;
  
	pReqCls := _LookupCls("MerkerEx");
	IF ((pReqCls <> NIL) & (pReqCls^.pDsc^.udRev.Hi < 1) & (pReqCls^.pDsc^.udRev.Lo < 20)) THEN
		TRACE_ERR("Incompatible version of class MerkerEx. Update to revision >= 1.20");
		LSLCLI_LoaderTracePrint("Incompatible version of class MerkerEx. Update to revision >= 1.20", 12);
		RETURN;
	END_IF;
  
	IF _LookupCls("RAMEX") = NIL THEN
    // wenn keine Objekte der Klasse RamEx angelegt sind, dann wird die Klasse
    // erst hier geladen
    IF ClassReader::NewCls("RamEx") = NIL THEN
      //----------------------------------------------------------
      // Interpreter programs and breakpoint lists are stored in
      // RamEx - objects. Please copy or link the RamEx - class from 
      // the Memory - library into Your project.
      //----------------------------------------------------------
      TRACE_WARN("Make sure the <RamEx>-class is part of Your project!");
      LSLCLI_LoaderTracePrint("Make sure the <RamEx>-class is part of Your project!", 12);
      RETURN;
    END_IF;
	END_IF;

	IF _LookupCls("ProgIp") = NIL THEN
    IF ClassReader::NewCls("ProgIp") = NIL THEN
      TRACE_ERR("Internal Loader error: class 'ProgIp' could not be loaded");
      LSLCLI_LoaderTracePrint("Internal Loader error: class 'ProgIp' could not be loaded", 12);
      RETURN;
    END_IF;
	END_IF;
  
  ok  := TRUE;

END_FUNCTION


FUNCTION GLOBAL IprReader::CheckIprProgs
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR

	ok	:= TRUE;
  
	IF ops.pProg^.uiProgs THEN
		pTable  := Ops.pProg^.pTable $ ^UDINT;
		pIpr    := pTable + Ops.pProg^.udOffInit;
		// read the maximum number of IPR_Progs
		IF LoadProgsFromTable() = FALSE THEN
      TRACE_ERR("Could not load interpreter programs");
      LSLCLI_LoaderTracePrint("Could not load interpreter programs", 12);
      ops.pProg^.uiProgs  := 0;   // ToDo: Speicher wird nicht freigegeben!
    END_IF;
	END_IF;

END_FUNCTION

// The configuration table for IPR-program has the following
// syntax:
// _K_IPR, Cnt$UINT,
// 	LOAD_ALWAYS|LOAD_DEFAULT, ProgNo, "Name",
// _K_END_VAR,
//
FUNCTION IprReader::LoadProgsFromTable
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    uiMaxPrgs	: UINT;
    usMode		: USINT;
    uiProg		: UINT;
    nActProg	: UDINT;
    pProgIp   : ^ProgIp;
    pSubPrg   : pSubPrgHead;
    bInit		  : BOOL;
    pSubPrgFile : pSubPrgHead;
    pSubPrgHeadNew : ^NewSubPrgHead;
    bProgChanged: BOOL;
#define LOADPROG_FLAG_PROG_CHANGED      1    
#define LOADPROG_FLAG_PROGLOAD_CALLED   2
    flags: ARRAY[0..MAX_IP_PROGS-1] OF USINT;
    lexem     : ARRAY[0..NLNG+1] OF char;
    pFct      : ^void;
    pIpr_save : ^CHAR;
  END_VAR

	uiMaxPrgs := OPS.pProg^.uiProgs;

	nActProg := 0;
	bInit     := FALSE;
  
  ok        := FALSE;

	// check if the old programs are still valid
	WHILE nActProg < uiMaxPrgs DO

    flags[nActProg] := 0;
		pProgIp := IprMgr::GetInterpreter(nActProg);// get address of interpreter
    IF !!pProgIp^.m_bNotFromTable THEN 

      // try to get old pointer with old block size
      pSubPrg	:= ProgMgr::GetProgram(nActProg);
  
      IF	  pSubPrg = NIL | // program not found
        pSubPrg^.udOffLbl <> sizeof(SubPrgHead) THEN //Interpreter hat einen alten Kopf
        bInit	:= TRUE;
      ELSIF pSubPrg^.udLng < MIN_PROG_SIZE |	// or invalid data
          pSubPrg^.udCRC <> ProgMgr::GetProgramChkSum(pSubPrg) THEN
        ProgMgr::FreeProgram(nActProg $ USINT);
        bInit	:= TRUE;
      END_IF;
      
    END_IF;
	
		nActProg	+= 1;
	END_WHILE;
  
	// reload programs if invalid
  
  // DEVOS-888:
  //  Der Fehler zu diesem Datensatz war, dass die Interpreterprogramme nicht geladen werden 
  //  konnten, wenn das zugehörige RamEx erst mit Daten befüllt werden musste, das ist der 
  //  Fall wenn z.B. das Sram gelöscht wurde. Zusätzlich musste in einem Interpreterprogramm 
  //  eine Referenz auf eines mit einer höheren Nummer existieren. 
  //  In so einer Konstellation funktionierte das Linken nicht (LinkAllProgs, Aufruf aus ProgMgr::ProgLoad).
  //  Die Fehlerbehebung erfolgte so dass ich die Hauptschleife auseinandergenommen habe 
  //  und daraus 2 Schleifen gemacht habe. 
  //  Das Laden der Programme erfolgt jetzt in 2 Schritten: 
  //  - im ersten Durchlauf werden die Programme so vorbereitet, dass gelinkt werden kann
  //  - im zweiten Durchlauf wird dann gelinkt und der Rest gemacht

  // Erster Durchlauf: Laden wenn erforderlich
  pIpr_save := pIpr;
	nActProg 	:= 0;
	WHILE nActProg < uiMaxPrgs DO

		pProgIp := IprMgr::GetInterpreter(nActProg);// get address of interpreter
    
    // Das Flag m_bNotFromTable ist gesetzt, wenn das Ipr Programm in der Init-Methode 
    // mit der Funktion ProgMgr_CreateIprProg angelegt wurde. In diesem Fall darf 
    // natürlich nicht versucht werden irgendetwas aus Tabellen nachzuladen.
    IF !!pProgIp^.m_bNotFromTable THEN 
  
      usMode	:= F_RD_USINT	(#pIpr);    // Art, wie die Tabelle geladen wird (immer/default)
      uiProg	:= F_RD_USINT	(#pIpr);    // Programmnummer
      IF ScanLexem(#pIpr, #lexem[0]) <> SN_ID THEN
        RETURN;
      END_IF;
      F_RD_USINT(#pIpr);                // Abschluß - 0er überlesen
  
  
      // Open IPR-program table
      pFct		:= _FindFctName(#lexem[0]);
      IF pFct = NIL THEN
        RETURN;
      END_IF;
      
      pSubPrgHeadNew := ProgMgr::GetProgramHead(nActProg);//alter Programmkopf mit FileChecksumme
      IF pSubPrgHeadNew <> NIL THEN
        pSubPrg	:= #pSubPrgHeadNew^.subProgHead;//alter Programmkopf
      ELSE
        pSubPrg := NIL;
      END_IF;
  
      pSubPrgFile := pFct $ ^SubPrgHead;  //File in dem der Interpreter gespeichert ist
      
      IF bInit | usMode = LOAD_ALWAYS |
        //wenn ein anderes File runtergespielt wurde
        (pSubPrgHeadNew <> NIL & pSubPrgFile <> NIL &
        pSubPrgHeadNew^.udFileCheck <> pSubPrgFile^.udCRCHead) THEN
  
        IF pSubPrg <> NIL & pSubPrg^.udOffLbl <> sizeof(SubPrgHead) |
           pProgIp <> NIL & pSubPrgFile <> NIL &
           pProgIp^.GetFileCheck() <> pSubPrgFile^.udCRCHead THEN
          flags[nActProg] := flags[nActProg] OR LOADPROG_FLAG_PROG_CHANGED;
        END_IF;

        flags[nActProg] := flags[nActProg] OR LOADPROG_FLAG_PROGLOAD_CALLED;
  
        // Grösse des Programms zurücksetzen, da es sonst nicht geladen wird
        IF ProgMgr::AllocProg(MIN_PROG_SIZE, uiProg) = FALSE THEN
          RETURN;
        END_IF;
      
        IF ProgMgr::ProgLoad(pSubPrgFile, FROM_TABLE, uiProg, bDoNotLink:=TRUE) = FALSE THEN
          RETURN;
        END_IF;
  
      END_IF;
    END_IF;        

		nActProg	+= 1;
	END_WHILE;

  // Zweiter Durchlauf  
  pIpr := pIpr_save; // Tabellenzeiger muss wieder an den Anfang gesetzt werden
	nActProg 	:= 0;
	WHILE nActProg < uiMaxPrgs DO

		pProgIp := IprMgr::GetInterpreter(nActProg);// get address of interpreter
    
    // Das Flag m_bNotFromTable ist gesetzt, wenn das Ipr Programm in der Init-Methode 
    // mit der Funktion ProgMgr_CreateIprProg angelegt wurde. In diesem Fall darf 
    // natürlich nicht versucht werden irgendetwas aus Tabellen nachzuladen.
    IF !!pProgIp^.m_bNotFromTable THEN 
      IF flags[nActProg] AND LOADPROG_FLAG_PROG_CHANGED THEN
        bProgChanged := TRUE;
      ELSE
        bProgChanged := FALSE;
      END_IF;
  
      usMode	:= F_RD_USINT	(#pIpr);    // Art, wie die Tabelle geladen wird (immer/default)
      uiProg	:= F_RD_USINT	(#pIpr);    // Programmnummer
      IF ScanLexem(#pIpr, #lexem[0]) <> SN_ID THEN
        RETURN;
      END_IF;
      F_RD_USINT(#pIpr);                // Abschluß - 0er überlesen
  
  
      // Open IPR-program table
      pFct		:= _FindFctName(#lexem[0]);
      IF pFct = NIL THEN
        RETURN;
      END_IF;
      
      pSubPrgHeadNew := ProgMgr::GetProgramHead(nActProg);//alter Programmkopf mit FileChecksumme
      IF pSubPrgHeadNew <> NIL THEN
        pSubPrg	:= #pSubPrgHeadNew^.subProgHead;//alter Programmkopf
      ELSE
        pSubPrg := NIL;
      END_IF;
  
      pSubPrgFile := pFct $ ^SubPrgHead;  //File in dem der Interpreter gespeichert ist
      
      IF flags[nActProg] AND LOADPROG_FLAG_PROGLOAD_CALLED THEN
  
        // Hier wird das Linken nachgeholt, das in der ersten Schleife beim 
        // ProgMgr::ProgLoad Aufruf mit bDoNotLink:=TRUE unterdrück wurde.
        IF ProgMgr::LinkVarias(nActProg) = FALSE THEN
          RETURN;
        END_IF;
  
        IF ProgMgr::LinkAllProgs(nActProg) = FALSE THEN
          RETURN;
        END_IF;
  
        pProgIp := IprMgr::GetInterpreter(nActProg);// get address of interpreter
        pProgIp^.SetFileCheck(pSubPrgFile^.udCRCHead);
  
      ELSE
        pProgIp^.SetPrgHead( pSubPrgHeadNew );	// cross reference ipr&prg
        // set code pointer to 1st instruction
        pProgIp^.SetCodePointer((pSubPrg + pSubPrg^.udOffCode)$UDINT);
  
        // objects can have been moved in memory since last start
        IF ProgMgr::LinkVarias(nActProg) = FALSE THEN
          RETURN;
        END_IF;
  
        // programs can have been moved since last start
        IF ProgMgr::LinkAllProgs(nActProg) = FALSE THEN
          RETURN;
        END_IF;
  
      END_IF;
  
      IprMgr::StartInterpreter(nActProg, bProgChanged, usMode);
    END_IF;        

		nActProg	+= 1;
	END_WHILE;
  
  ok  := TRUE;

END_FUNCTION
