//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_LMCAxis"
	Revision           = "1.114"
	GUID               = "{BBF26E8B-9881-449D-9540-93990A63ECAD}"
	RealtimeTask       = "true"
	DefRealtime        = "1 ms"
	CyclicTask         = "false"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_LMCAxis\LMCAxis.ico"
	SharedCommandTable = "true"
	Objectsize         = "(650,120)"
	Comment            = "The _LMCAxis class represents a profile generator for 1 axis. It calculates the actual &#13;&#10;set position and provides with the set and actual values to the controller class.&#13;&#10;&#13;&#10;The _LMCAxis class also contains all the functions/interfaces needed to drive an axis.&#13;&#10;&#13;&#10;The _LMCAxis class also provides the standard referencing functions for the axis. The&#13;&#10;most common referencing variations can be preformed.&#13;&#10;&#13;&#10;The _LMCAxis class also monitors the hardware limit switches.&#13;&#10;&#13;&#10;The _LMCAxis class can manage absolute value encoders.">
	<Channels>
		<Server Name="AbsEncoder" GUID="{67A9C60B-7109-4A29-B034-0B874C9F507E}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="With this server absolute&#13;&#10;encoder-values can be read in"/>
		<Client Name="_LMCABSEncoder1" Required="true" Internal="true"/>
		<Client Name="_LMCAxisRef1" Required="true" Internal="true"/>
		<Client Name="_LMCAxisVis1" Required="true" Internal="true"/>
		<Client Name="_LMCMathFunctions1" Required="true" Internal="true"/>
		<Client Name="_LMCPublisher1" Required="true" Internal="true"/>
		<Client Name="_LMCSafety1" Required="true" Internal="true"/>
		<Client Name="Config" Required="false" Internal="false" Comment="define with this client the&#13;&#10;configuration for the Publisher"/>
		<Client Name="Emergency" Required="false" Internal="false" Comment="With this client a general error condition can be checked and it is possible to configure what in the case of an error should happen."/>
		<Client Name="HWError" Required="false" Internal="false" Comment="Digital-Input to read in wheter a hardware error has occured"/>
		<Client Name="HWMax" Required="false" Internal="false" Comment="Digital-Input for the hardware switch maximum-position&#13;&#10;0 .. hardwareswitch is inactive&#13;&#10;1 .. hardwareswitch is active"/>
		<Client Name="HWMin" Required="false" Internal="false" Comment="Digital-Input for the hardware switch of minimum-position.&#13;&#10;0 .. hardwareswitch is inactive&#13;&#10;1 .. hardwareswitch is active"/>
		<Client Name="HWReady" Required="false" Internal="false" Comment="With this Digital-Input, it can read in whether the hardware is initialized completely"/>
		<Client Name="ID" Required="false" Internal="false" Comment="set a unique ID for the Publisher"/>
		<Client Name="LatchPos" Required="false" Internal="false" Comment="External position [incr] used in mode &quot;RefLatchPos&quot;"/>
		<Client Name="Provider" Required="false" Internal="false" Comment="connect this client to a provider&#13;&#10;who handles the given data"/>
		<Client Name="RefSwitch" Required="false" Internal="false" Comment="Reference switch input"/>
		<Client Name="ZImpulse" Required="false" Internal="false" Comment="This input is used to determine the switching status of the Z pulse"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_LMCAxis\_LMCAxis.vov"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.114" Date="2024-04-16" Author="StePhi" Company="Sigmatek" Description="1. Bugfix: A coupled axis does not stop at a dynamic sw limit, when MoveType = _RAMP_PROFILE or MoveType = _SCURVE_PROFILE is used.&#13;&#10;2. Improvement: Added support for using LREAL positions and speed in case the connected controller supports this. The controller class and class revision defines if the controller can operate with LREAL values. LREAL speed and position is only available with _JERK_PROFILE."/>
		<Dokumentation Revision="1.113" Date="2024-01-25" Author="StePhi" Company="Sigmatek" Description="1. Bugfix: The ReadyToPowerOn flag in the AxisStatus is set if the simulation mode has been activated by initializing the &quot;SimulateMode&quot; server."/>
		<Dokumentation Revision="1.112" Date="2023-12-11" Author="StePhi" Company="Sigmatek" Description="1. Bugfix: Acceleration must be limited to the maximum allowed acceleration for CoupleCAM mode with internal LREAL calculation to avoid exceeding the axis acceleration limit.&#13;&#10;2. Bugfix: Error information of 64-bit multiplication to calculate the actual position was not used. DINT overflow or underflow not detected.&#13;&#10;3. Improvement: Error information of 64-bit multiplication is evaluated on user commands for coupling and parameter set.&#13;&#10;4. Improvement: The PowerOn() command of the _LMCAxis class is rejected if the axis is not approved to be enabled by the safety of the drive."/>
		<Dokumentation Revision="1.111" Date="2023-10-28" Author="StePhi" Company="Sigmatek" Description="1. Improvement: Added support for safety axis features. Safe verification, safe reference, automatic SBT at PowerOn() and automatic SS2 handling is now supported."/>
		<Dokumentation Revision="1.110" Date="2023-06-01" Author="StePhi" Company="Sigmatek" Description="1. Bugfix: The slave does not move when negative direction limit is used, when the axis is coupled via CoupleGearVelocity or CoupleDeltaPos.&#13;&#10;2. Bugfix: When a slave is coupled with CoupleGearPolynom() and the movement direction is limited by LMCAXIS_MOVE_POS_DIR, the slave velocity jumps between 0 and an higher speed while polynom trajectory is performed.&#13;&#10;3. Improvement: The setting of velocity jump can now be read using ReadParameter() with parameter LMCAXIS_PAR_RD_VJUMP.&#13;&#10;4. Improvement: The resolution of the master and slave axis can be considered for coupling commands now. The parameter LMCAXIS_PAR_SET_COUPLE_USERESOLUTION was added to activate the new mode. The new mode is available for CoupleGearAbsolute(), CoupleGearRelative(), CoupleGearPolynom(), CoupleGearVelocity(), CoupleCAM() and CoupleCurveTab().&#13;&#10;5. Improvement: New parameter LMCAXIS_PAR_RD_AXISBRAKINGJERK added to method ReadParameter(). This parameter returns if a coupled axis is currently braking to its master&apos;s trajectory or is braking in case of a normal movement."/>
		<Dokumentation Revision="1.109" Date="2023-03-28" Author="StePhi" Company="Sigmatek" Description="1. Bugfix: Condition to check if a jerk error occurs was triggered wrongly, when the temporary speed exceeded the maximum speed by a margin smaller a mathematical epsilon.&#13;&#10;2. Improvement: The actual destination can be read from the axis which is limited by the active sw limits (static and dynamic sw limits). The new parameter LMCAXIS_DESTPOS_INTUNIT_SWLIMITED was added for the method ReadPosition()."/>
		<Dokumentation Revision="1.108" Date="2022-09-22" Author="SakEmi&#13;&#10;StePhi" Company="Sigmatek" Description="1. Info: SW limit comments improved (SWMinPos and SWMaxPos). Detailed description is in the class documentation.&#13;&#10;2. Bugfix: Renamed the enum entries of private ENUM _MoveDirectionIntern to avoid naming collisions with defines in CncConstant.h, when CNC class and _LMCAxis class is used in one project.&#13;&#10;3. Bugfix: In some cases the pointers of backlash measurement and backlash compensation were not checked to valid before using them.&#13;&#10;4. Improvement: The move hand buttons of LMCAxis VOV must now actively be pressed to be active. When no new command for a time of 1 second is sent the axis receives a stop command automatically, e.g. in case of connection break or a huge connection delay.&#13;&#10;5. Improvement: Improved method comment that parameter NextTick of method CalcSpeedChangePath() is only in effect when _JERK_PROFILE is used.&#13;&#10;6. Bugfix: It can be specified if the brake distance of Ramp/Scurve profile will be calculated using the deceleration factor of 100% or 125%.&#13;&#10;7. Improvement: When the master and slave axis is jerk-limited (MoveType = _JERK_PROFILE) it is now supported to directly calculate the coupling internally by using the LREAL variables. This allows a tighter coupling to follow more precisely the CAM table and avoids rounding errors at low master speed. This feature must be activated by using the new parameter LMCAXIS_PAR_SET_CAMCOUPLE_USELREAL.&#13;&#10;8. Bugfix: The internal speed vOverride is not updated, when an override greater than 100% is used and the resulting speed exceeds the maximum axis speed when _RAMP_PROFILE is used. Now the maximum axis speed is used as it is done with _JERK_PROFILE."/>
		<Dokumentation Revision="1.107" Date="2022-09-07" Author="VelGer&#13;&#10;StePhi&#13;&#10;" Company="Sigmatek" Description="1. BugFix: If the Axis is moved with a relatively low Jerk value and ChangeMoveSettings() is executed whilst braking, it can occur that the velocity jumps to 0.&#13;&#10;2. Bugfix: Internal checks of maximum speeds in case of _JERK_PROFILE axis fail, which would be inside of the defined limits of the axis."/>
		<Dokumentation Revision="1.106" Date="2022-07-28" Author="VelGer" Company="Sigmatek" Description="1. Bugfix: In the NCControl Mode, if the axis is moved to position 0 using MoveEndless(), powered off, powered on, and the movement to position 0 is continued, the axis position jumps to the target position. This has been corrected."/>
		<Dokumentation Revision="1.105" Date="2022-04-22" Author="StePhi" Company="Sigmatek" Description="1. Bugfix: If CoupleCurveTab() was started at a modulo axis and executed until the MaxModulo overflow of the slave axis occured and then uncoupled and recoupled with CoupleCurveTab, an unwanted movement could occur within a slave modulo. This was fixed by resetting MaxModuloCAMOffset in the course of CoupleCurveTab().&#13;&#10;2. Bugfix: The master GearMul and GearDiv factor was not applied, when master and slave is a modulo axis for CoupleCAM() and CoupleCurveTab().&#13;&#10;3. Improvement: It should be possible to read all hardlock states by using the ReadParameter parameter LMCAXIS_PAR_RD_HARDLOCK. The return values for NO_HARDLOCK and VEL_JUMP are unchanged."/>
		<Dokumentation Revision="1.104" Date="2022-04-11" Author="MarTho" Company="Sigmatek" Description="1. Bugfix: If CoupleCAM was started at a modulo axis and executed until the MaxModulo overflow of the slave axis occured and then uncoupled and recoupled with CoupleCAM, an unwanted movement could occur within a slave modulo. This was fixed by resetting MaxModuloCAMOffset in the course of CoupleCAM()."/>
		<Dokumentation Revision="1.103" Date="2022-02-07" Author="SakEmi" Company="Sigmatek" Description="1. BugFix: SW limit in MoveRelative() shall only be checked if specified in Server ErrorConfig.&#13;&#10;2. BugFix: Slave axis can&apos;t move in negative direction if it is limited to positive direction only (MOVE_POS_DIR), even if master is moving with very low speed.&#13;&#10;3. Improvement: New ReadParameter LMCAXIS_PAR_RD_REFPOSOFF. It gives the position change created by referencing.&#13;&#10;4. BugFix: Offset position in AbsEncoder is updated also if position is set after the RAM has been cleared"/>
		<Dokumentation Revision="1.102" Date="2022-01-24" Author="StePhi&#13;&#10;SakEmi" Company="Sigmatek" Description="Bugfix: A CAM coupling to a lead axis in _JERK_PROFILE was not working properly when the speed of the lead axis is very small."/>
		<Dokumentation Revision="1.101" Date="2022-01-20" Author="StePhi" Company="Sigmatek" Description="1. Bugfix: When a modulo axis was already moving and a MoveAbsolute() was used it could happen, that the brake action started to late unter following conditions. The axis was powered in LMCAXIS_MOVE_POS_DIR mode or in LMCAXIS_MOVE_NEG_DIR mode and the braking distance was greater or equal than a full modulo of the axis."/>
		<Dokumentation Revision="1.100" Date="2021-11-11" Author="MarTho&#13;&#10;RauAnd" Company="Sigmatek" Description="1. Bugfix: _LMCAxis::QuitError() does not reset the error flags immediately any more but sets a flag that indicates that an error quit is requested. The error quit procedure where the error flags are reset is now performed in the realtime task. This mus be done because otherwise there is an undefined error state between QuitError() and the next realtime task execution."/>
		<Dokumentation Revision="1.99" Date="2021-08-17" Author="StePhi&#13;&#10;MarTho" Company="Sigmatek" Description="1. Improvement: A set parameter LMCAXIS_PAR_SET_CHANGECONTROLLERTYPE was added to read the controller type of the connected controller after init and reinitialize the controller. This parameter can only be used when the axis is not powered.&#13;&#10;2. Improvement: A set parameter LMCAXIS_PAR_SET_COUPLE_SLAVEOFFSET was added to change the offset of a CAM coupled slave while staying coupled to the master.&#13;&#10;3. Bugfix: The LockDelta in the case of CoupleGearAbsolute is now considered in the calculations for the move shortest way functionality."/>
		<Dokumentation Revision="1.98" Date="2021-02-01" Author="BauEli&#13;&#10;MarTho&#13;&#10;StePhi" Company="Sigmatek" Description="1. Improvement: In the general settings of the VOV the internal units are now displayed once originally and once divided by the unit multiplier.&#13;&#10;2. Improvement: The movement parameters of MoveEndless() can now be changed during active MoveEndless() in the VOV of _LMCAxis and the movement can be continued with the new parameters without stopping.&#13;&#10;3. Improvement: Added handling of Backlash measurement and compensation with BacklashMeasurement and BacklashCompensation class to the class.&#13;&#10;4. Bugfix: An AxisError is now set when a slave axis is coupled to a master axis and SwLimitMonitoring coupling option is active and a sw limit would have been violated without stopping the axis.&#13;&#10;5. Bugfix: The slave axis does not start spinning backwards after multiple recouplings when the recouple mode for a slave modulo and master modulo axis is used."/>
		<Dokumentation Revision="1.97" Date="2020-11-16" Author="StePhi" Company="Sigmatek" Description="1. Improvement: A new mode for coupling of a master modulo axis and a slave modulo axis was added. The new mode implements a recoupling (first coupling must be performed as before) to a new CAM Table or to the same CAM Table after decoupling."/>
		<Dokumentation Revision="1.96" Date="2020-09-03" Author="SakEmi" Company="Sigmatek" Description="1. BugFix: CoupleDeltaPos-coupling does not cause JerkProfile-axis to go to the 0 position at first."/>
		<Dokumentation Revision="1.95" Date="2020-08-14" Author="MarTho&#13;&#10;StePhi" Company="Sigmatek" Description="1. Bugfix: If _LMCAxis is in error mode &quot;ActPosError&quot;, the error bit &quot;ActPosError&quot; is now set to TRUE and returned by SetPosition() for all modes in which &quot;ActPos&quot; is set.&#13;&#10;2. Bugfix: Added mode=1 to LMCAXIS_PAR_RD_ABS_ENCODER of ReadParameter(). With this mode _LMCGantry can check if an axis with absolute encoder is already referenced during init().&#13;&#10;3. Bugfix: The activation of the PDO-communication between DriveAxis andDrivePosControl (see _LMCAxis v1.94) has been deactivated because a downwards compatibility issue regarding older DrivePosControl versions arose.&#13;&#10;4. Improvement: Changes in _LMCAxisVis and _LMCAxisVisInt have been made for the integration of the classes StepperControl and VFDControl into the VOV of _LMCAxis. "/>
		<Dokumentation Revision="1.94" Date="2020-04-02" Author="KllDio&#13;&#10;MarTho" Company="Sigmatek" Description="1. Improvement: The ReadParameter(LMCAXIS_PAR_RD_MODULO) method delivered the current Modulo without considering the Resolution Factor, a new mode (mode=1) has been added to allow the reading of the current Modulo value whilst considering the Resolution Factor.&#13;&#10;2. Improvement: Class now supports PDO usage to access drive parameters.&#13;&#10;3. Bugfix: The overflow error in the case of a MaxModulo overflow during _StartPolynomPositioning of CoupleGearPolynom_v0 was fixed."/>
		<Dokumentation Revision="1.93" Date="2020-03-24" Author="MarTho&#13;&#10;VelGer" Company="Sigmatek" Description="1. Bugfix: CoupleCAM() - When an axis was coupled to another using CAM Coupling, the Slave/Master Axis internal position reached the MaxModulo value of the slave axis and the overflow did not happen on a Modulo interval of the slave axis, a jump in the slave position used to occur. This has now been corrected."/>
		<Dokumentation Revision="1.92" Date="2020-03-05" Author="VelGer&#13;&#10;MarTho" Company="Sigmatek" Description="1. Bugfix: CoupleCAM() - MoveShortestWay Functionality is now implemented for the case where the slave axis is a moduloaxis and the master axis is not a modulo axis.&#13;&#10;2. BugFix: If a QuickStopMove is interrupted by PowerOff() or another error, the Axis was not able to power on again. The axis can now be turned on afterwards.&#13;&#10;3. BugFix: After a PowerOffError occurred, it was not possible to repower the axis, this has now been corrected.&#13;&#10;4. Bugfix: CoupleCAM() - If the slave axis is a modulo axis, the master axis is not a modulo axis and the slave axis had a negative position value, the slave axis used to rotate one modulo turn in the positive direction when coupling to the master. This has now been corrected."/>
		<Dokumentation Revision="1.91" Date="2019-08-23" Author="HasHan&#13;&#10;VelGer" Company="Sigmatek" Description="1. Improvement: the Power-Button is now blinking when the state is WAITIDLE_LMCAXIS or WAITPASSIVE_LMCAXIS&#13;&#10;2. Improvement: ChangeMoveSettings() has been updated so that the change in settings is only accepted if the imput parameters differ from the actual limits.&#13;&#10;3. Bugfix: When using JERK_PROFILE the axis can now switch from PHASE_IDLE to PHASE_V_BRAKE_TO_MASTER without having to pass through PHASE_I_INC_ACC. In applications where ChangeMoveSettings() is called every tick, this could cause an unwanted overrun of the target.&#13;&#10;4. BugFix: When using JERK_PROFILE, if the target and current position was very close to each other (a few internal units) and a comparatively large Jerk and Acceleration was set, it could occur that the axis overshoots the target and then slowly approaches the target again, this has been fixed.&#13;&#10;5. Improvement: ReadParameter(LMCAXIS_PAR_RD_MASTERLOCK_12) with mode = 1 now delivers 1 if the polynom of CoupleGearPolynom() is finished&#13;&#10;6. Bugfix: AxisStatus.PowerOn is now 1 during WAITPASSIV_LMCAXIS"/>
		<Dokumentation Revision="1.90" Date="2019-05-24" Author="VelGer" Company="Sigmatek" Description="1. Improvement: If the move direction is changed using SetParameter() with mode=1, the move direction is locked and will not change on following PowerOn() calls, until SetParameter() is used to change the value with mode=0.&#13;&#10;2. Bugfix: In Open Loop Control Mode (with NCController) the LMCAxis now recovers correctly after an unexpected PowerOff() or HWError."/>
		<Dokumentation Revision="1.89" Date="2019-05-23" Author="VelGer" Company="Sigmatek" Description="Improvement: New Compiler warning (W0172) fixed."/>
		<Dokumentation Revision="1.88" Date="2019-02-11" Author="HasHan" Company="Sigmatek" Description="1. Bugfix: if a QuickStop() was active, commands can now be inserted in the first IDLE_LMCAXIS&#13;&#10;2. Bugfix: possible DINT overflow with CoupleGearPolynom() is now fixed"/>
		<Dokumentation Revision="1.87" Date="2019-01-29" Author="SatChr" Company="Sigmatek" Description="1. Improvement: Method CalcSpeedChangePath provides a new input parameter NextTick.&#13;&#10;2. Bugfix: Method ReadSwEndPos works in Init now."/>
		<Dokumentation Revision="1.86" Date="2018-10-09" Author="PalHar" Company="Sigmatek" Description="Bugfix: CalcMovingTime() with MoveType=_JERK_PROFILE works with realtime cycle times &lt;&gt; 1 ms."/>
		<Dokumentation Revision="1.85" Date="2018-09-04" Author="SatChr" Company="Sigmatek" Description="1. Improvement: Additional parameters in SetAdjustement and Read/SetParameter added.&#13;&#10;2. Bugfix: CalcMovingTime has returned wrong values, if MoveType=_JERK_PROFILE and if the programmed, maximum velocity may have not been reached.&#13;&#10;3. Bugfix: Method ReadUserData returns an initialized value 0 in case of an invalid input parameter index."/>
		<Dokumentation Revision="1.84" Date="2018-08-13" Author="SatChr" Company="Sigmatek" Description="1. Bugfix: Avoid access exception, if coupling to a master axis immediately after an error occured at the master. (Bug occured, only if ErroConfig.CoupleMonitoring=1)&#13;&#10;2. Bugfix: Avoid division error in StopMove, if the neccessary deceleration value to stop before a software limit does not fit into a DINT variable. (MoveType=_RAMP_PROFILE or _SCURVE_PROFILE)"/>
		<Dokumentation Revision="1.83&#13;&#10;" Date="2018-06-14" Author="RodMar&#13;&#10;SatChr" Company="Sigmatek" Description="1. Bugfix: Correction of stopping point computation for coupled axis with software limits.&#13;&#10;2. Bugfix: Faster coupling movement to a stillstanding master (MoveType RAMP &amp; SCURVE)&#13;&#10;3. Bugfix: cam coupling with a non-modulo slave: Correction of the maxmodulo overflow handling in negative direction.&#13;&#10;4. Improvement: New method QuickStop added.&#13;&#10;5. PowerOff() Function will not enter WAITPASSIVE_AXIS if the controller is already powered off"/>
		<Dokumentation Revision="1.82" Date="2018-03-23" Author="HasHan&#13;&#10;SatChr" Company="Sigmatek" Description="1. Bugfix: CoupleGearPolynom: Cleaner, smoother movement, if the master axis is accelerating or braking."/>
		<Dokumentation Revision="1.81" Date="2017-10-12" Author="HasHan" Company="Sigmatek" Description="1. Bugfix: the varialbe ObjInfo is renamed back to Obj&#13;&#10;2. Improvement: CoupleGearPolynom() works better with a non constant jerk-master"/>
		<Dokumentation Revision="1.80" Date="2017-09-28" Author="Roskri" Company="Sigmatek" Description="Bugfix: Axis will now not, for one cycle, uncouple during certain movements when coupled to a _LMCProfile."/>
		<Dokumentation Revision="1.79" Date="2017-09-14" Author="HasHan&#13;&#10;PalHar&#13;&#10;SatChr" Company="Sigmatek" Description="1. Bugfix: the position-drift is now corrected, if the master is not constant during PosMode = _StartPolynomPositioning&#13;&#10;2. Bugfix: MoveType=_JERK_PROFILE: Improvement of couple algorithm, such that the axis may not loose synchronisity (MasterLock), if not really necessary.&#13;&#10;3. Bugfix: Calculating an exact ramp for StopMove makes correct end position."/>
		<Dokumentation Revision="1.78" Date="2017-07-06" Author="HasHan" Company="Sigmatek" Description="Bugfix: set the acceration to 0 in FollowMode to avoid wrong brakedistance-calculations"/>
		<Dokumentation Revision="1.77" Date="2017-06-21" Author="Roskri" Company="Sigmatek" Description="Improvement: CreateMutex() is now virtual"/>
		<Dokumentation Revision="1.76" Date="2017-04-03" Author="HasHan&#13;&#10;PalHar" Company="Sigmatek" Description="1. Improvement: add the server InitDone that the VoV works without error in offline-mode&#13;&#10;2. Improvement: an axis coupled by CoupleGearVelocity() will now reach the SWLimits like expected&#13;&#10;3. Bugfix: correct last move-step if an unlocked axis is stopped&#13;&#10;4. Bugfix: CalcSpeedChangePath() delivers also in coupled-mode the correct distance&#13;&#10;5. Improvement: the PowerOn-Timeout can be changed with SetParameter(LMCAXIS_PAR_SET_POWERON_TIMEOUT) default (90sec)"/>
		<Dokumentation Revision="1.75" Date="2017-03-17" Author="FucHer&#13;&#10;SatChr" Company="Sigmatek" Description="1. Bugfix: CalcBrakePosition(), _JERK_PROFILE: limit the master speed and acceleration before calculating the brake distance.&#13;&#10;   _RAMP_PROFILE, _SCURVE_PROFILE: limit the master speed before calculating the brake distance.&#13;&#10;2. Bugfix: Improvement of the coupling process, if the slave axis has been waiting for the master axis at its software limit position and the master axis is approaching the valid range."/>
		<Dokumentation Revision="1.74" Date="2017-02-14" Author="Roskri" Company="Sigmatek" Description="Improvement: SetParameter(): new mode for parameter LMCAXIS_PAR_SET_MASTERVEL_OLD for setting old master velocity."/>
		<Dokumentation Revision="1.73" Date="2017-01-27" Author="Roskri&#13;&#10;SatChr" Company="Sigmatek" Description="1. Bugfix: When SetParameter(LMCAXIS_PAR_SET_SHAPE_SPLINE) with mode = 6 is set, the slave is decoupled when it reaches its synchronized state with Master by coupling with CoupleGearPolynom.&#13;&#10;2. Bugfix: Move_Type = _JERK_PROFILE: the set position makes a jump when a brake correction is made but axis is already braking with maximum deceleration.&#13;&#10;3. Improvement: New mode for bit AxisStatus.DelayedMasterLock (SetParameter(LMCAXIS_PAR_SET_DELAYEDMASTERLOCK_WINDOW). DelayedMasterLock bit is set, if the position and velocity is in a window.&#13;&#10;4. Improvement: new mode WAITPASIVE_LMCAXIS if DrivePosControl is connected&#13;&#10;5. Improvement: AxisStatus.ReadyForPowerOn is 1 if HWReady and _DriveAxis.StateWord.SwitchedOn = 1"/>
		<Dokumentation Revision="1.72" Date="2016-11-18" Author="SatChr" Company="Sigmatek" Description="Bugfix: Prevent setting the bit AxisStatus.StandStill, if inverse of direction"/>
		<Dokumentation Revision="1.71" Date="2016-10-27" Author="SatChr" Company="Sigmatek" Description="Bugfix: If MoveType=_JERK_PROFILE and ChangeMoveSettings is called during braking to the destination, the new values will be used now."/>
		<Dokumentation Revision="1.70" Date="2016-10-14" Author="SatChr" Company="Sigmatek" Description="1. Bugfix: Method QuitError does not reset AxisError flags, which will be set in the next realtime cycle again.&#13;&#10;2. Bugfix: A small discrepancy between the internal, ramped position and the s-curve-filtered position can occur for an endless axis with MoveType=_SCURVE_PROFILE, if a lot of MaxModulo overflows happens.&#13;&#10;3. Bugfix: AxisError.PowerOnError is not set any longer, if the axis was shut of by a contouring error.&#13;&#10;4. Bugfix: GetPosInfoBeforeRampDown returns 1, if the movement is already finished. Minus 1, if the axis is in wrong state (PASSIVE, ERROR. LOCKED).&#13;&#10;5. Improvement: New ReadPosition mode LMCAXIS_XW_TO_DESTPOS_INTUNIT.&#13;&#10;6. Improvement: New ReadVelocity mode LMCAXIS_CMDVEL_APPUNIT.&#13;&#10;7. Bugfix: Very small velocities work with EDGE2 technology and MoveType=_RAMP_PROFILE or _SCURVE_PROFILE.&#13;&#10;8. Bugfix: With MoveType=_RAMP_PROFILE or _SCURVE_PROFILE and EDGE2-CPUs: Move commands with a programmed velocity less than 1 internal unit per tick did not work."/>
		<Dokumentation Revision="1.69" Date="2016-08-26" Author="SatChr" Company="Sigmatek" Description="Bugfix: MoveType=_JERK_PROFILE: In very rare cases, it may have happend, that a slave axis did not get synchron with its stillstanding master axis, but just swing very small around the target."/>
		<Dokumentation Revision="1.68" Date="2016-06-08" Author="SatChr" Company="Sigmatek" Description="changes in base class"/>
		<Dokumentation Revision="1.67" Date="2016-05-18" Author="SatChr" Company="Sigmatek" Description="changes in base class"/>
		<Dokumentation Revision="1.66" Date="2016-05-03" Author="SatChr" Company="Sigmatek" Description="changes in base class"/>
		<Dokumentation Revision="1.65" Date="2016-04-06" Author="SatChr&#13;&#10;PalHar&#13;&#10;HasHan&#13;&#10;Roskri" Company="Sigmatek" Description="1. changes in base class&#13;&#10;2. Improvement: New input parameter Jerk for all move commands added.&#13;&#10;3. Improvement: new method ReadParameterLREAL added."/>
		<Dokumentation Revision="1.63" Date="2016-03-14" Author="SatChr&#13;&#10;HasHan" Company="Sigmatek" Description="1. Improvement: New method ReadSlavePosCam added.&#13;&#10;2. changes in base class and _LMCSafety"/>
		<Dokumentation Revision="1.62" Date="2016-03-01" Author="HasHan" Company="Sigmatek" Description="change in base class"/>
		<Dokumentation Revision="1.61" Date="2016-02-12" Author="SatChr" Company="Sigmatek" Description="Bugfix: Couple commands work with EDGE2 processors again. (bug in version 2.51)"/>
		<Dokumentation Revision="1.60" Date="2016-01-26" Author="SatChr" Company="Sigmatek" Description="changes in base class"/>
		<Dokumentation Revision="1.59" Date="2015-10-01" Author="SatChr" Company="Sigmatek" Description="1. changes in base class&#13;&#10;2. Improvement: New method CalcSpeedChangePath added."/>
		<Dokumentation Revision="1.58" Date="2015-09-30" Author="SatChr" Company="Sigmatek" Description="Improvement: update of the VOV"/>
		<Dokumentation Revision="1.57" Date="2015-09-25" Author="FucHer&#13;&#10;SatChr" Company="Sigmatek" Description="1. changes in base class"/>
		<Dokumentation Revision="1.56" Date="2015-06-24" Author="FucHer&#13;&#10;PalHar&#13;&#10;SatChr" Company="Sigmatek" Description="changes in base class"/>
		<Dokumentation Revision="1.55" Date="2015-04-17" Author="FucHer&#13;&#10;SatChr" Company="Sigmatek" Description="changes in BaseClass"/>
		<Dokumentation Revision="1.54" Date="2015-01-19" Author="SatChr" Company="Sigmatek" Description="changes in BaseClass"/>
		<Dokumentation Revision="1.53" Date="2014-12-15" Author="HasHan&#13;&#10;FucHer&#13;&#10;SatChr" Company="Sigmatek" Description="1. Improvement: methods  ChangeMoveSettings(), GetPosInfoBeforeRampDown(), CoupleUserPosExtended(), CoupleProfilePosExtended(), and CoupleDeltaPosExtended() added.&#13;&#10;2. new jerk limitation (server MoveType:=_JERK_PROFILE) and other changes in base class."/>
		<Dokumentation Revision="1.51" Date="2014-07-10" Author="HasHan" Company="Sigmatek" Description="changes in BaseClass"/>
		<Dokumentation Revision="1.50" Date="2014-07-07" Author="HasHan&#13;&#10;SatChr" Company="Sigmatek" Description="1. Improvement: methode CoupleAdditivePosDiff() added for easier belt-coupling&#13;&#10;2. Improvement: methode CoupleCAM() for easier usage of the CAM coupling added."/>
		<Dokumentation Revision="1.40" Date="2014-04-11" Author="SatChr" Company="Sigmatek" Description="Improvement: New methode MoveShortestWay() added."/>
		<Dokumentation Revision="1.30" Date="2014-01-27" Author="FucHer&#13;&#10;SatChr&#13;&#10;SliMic" Company="Sigmatek" Description="1. Improvement: Update _LMCAxis-VOV with new SetParameter options&#13;&#10;2. Improvement: PowerOn(): init value for mode changed to LMCAXIS_MOVE_ANY_WAY.&#13;&#10;3. Improvement: implementation of the dynamic software limit"/>
		<Dokumentation Revision="1.20" Date="2013-07-18" Author="HasHan&#13;&#10;SliMic" Company="Sigmatek" Description="1. the MasterPtr can now be delayed with the ReadMaster function&#13;&#10;2. Add some comments to the methodes and variables"/>
		<Dokumentation Revision="1.10" Date="2013-02-08" Author="HasHan&#13;&#10;ObeChr" Company="Sigmatek" Description="1. Improvement: new Client =&gt; Emergency&#13;&#10;2. Bugfix: add ReadUserData() for fetching UserData via NewInst Command (for LMCProfile VOV)&#13;&#10;3. Extended NewInst for reading PowerOff Mode&#13;&#10;4. Removed Visualized Flag of Object _LMCAxisVis1&#13;&#10;5. Changed NewInst to get VOV Informations"/>
		<Dokumentation Revision="1.0" Date="2012-09-27" Company="Sigmatek" Description="creation"/>
	</RevDoku>
	<Network Name="_LMCAxis">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{C43A02B1-A319-4132-B2FA-36A920C832E8}"
				Class      = "_LMCAxisBase"
				Position   = "(1298,120)"
				Visualized = "true"
				RealTime   = "1 ms"
				CyclicTime = "100 ms">
				<Channels>
					<Server Name="ActPos"/>
					<Server Name="ActVelocity"/>
					<Server Name="AEmergency"/>
					<Server Name="AMax"/>
					<Server Name="AxisError"/>
					<Server Name="AxisStatus"/>
					<Server Name="Control"/>
					<Server Name="Destination"/>
					<Server Name="ErrorConfig"/>
					<Server Name="ExUnits"/>
					<Server Name="IntUnits"/>
					<Server Name="JMax"/>
					<Server Name="Modulo"/>
					<Server Name="MoveType"/>
					<Server Name="Override"/>
					<Server Name="PosMode"/>
					<Server Name="Resolution"/>
					<Server Name="SafeAxisState"/>
					<Server Name="SetPos"/>
					<Server Name="SetVelocity"/>
					<Server Name="SimulateMode" Value="0"/>
					<Server Name="SWMaxPos"/>
					<Server Name="SWMinPos"/>
					<Server Name="Tjerk"/>
					<Server Name="VMax"/>
					<Client Name="ActPosition"/>
					<Client Name="LMCAbsEncoder"/>
					<Client Name="LMCController"/>
					<Client Name="LMCMath"/>
					<Client Name="LMCPostRtWorkTrigger"/>
					<Client Name="LMCPreRtWorkTrigger"/>
					<Client Name="LMCPublisher"/>
					<Client Name="LMCReference"/>
					<Client Name="LMCSafety"/>
					<Client Name="TaskObjectControl"/>
				</Channels>
			</Object>
			<Object
				Name       = "_LMCABSEncoder1"
				GUID       = "{4997BF67-81DA-49B7-8B08-D58CDF069D7E}"
				Class      = "_LMCABSEncoder"
				Position   = "(1440,1890)"
				Visualized = "true">
				<Channels>
					<Server Name="AbsEncoder"/>
					<Server Name="ClassSvr"/>
					<Server Name="PosCRC32"/>
					<Server Name="PosOffset"/>
					<Server Name="PosOffsetOk"/>
					<Client Name="_Linker"/>
				</Channels>
			</Object>
			<Object
				Name       = "_LMCAxisRef1"
				GUID       = "{8527575C-8C8D-4427-B640-713377E99444}"
				Class      = "_LMCAxisRef"
				Position   = "(690,1740)"
				Visualized = "true">
				<Channels>
					<Server Name="RefInput"/>
					<Server Name="ZPulseDist"/>
					<Client Name="HWMax"/>
					<Client Name="HWMin"/>
					<Client Name="LatchPos"/>
					<Client Name="RefSwitch"/>
					<Client Name="ZImpulse"/>
				</Channels>
			</Object>
			<Object
				Name       = "_LMCAxisVis1"
				GUID       = "{3701FC36-2E16-4B1A-8232-F571CF23D782}"
				Class      = "_LMCAxisVis"
				Position   = "(2190,90)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="LMCAxisBase"/>
				</Channels>
			</Object>
			<Object
				Name       = "_LMCMathFunctions1"
				GUID       = "{0B90E254-A9E3-4704-B5A1-614F7986265F}"
				Class      = "_LMCMathFunctions"
				Position   = "(240,420)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "_LMCPublisher1"
				GUID       = "{B0919C80-CE58-4E90-990E-AB221AFF5CEA}"
				Class      = "_LMCPublisher"
				Position   = "(510,2160)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="Config" Value="0"/>
					<Client Name="ID" Value="0"/>
					<Client Name="Provider"/>
				</Channels>
			</Object>
			<Object
				Name       = "_LMCSafety1"
				GUID       = "{7AEC0395-7659-45AE-A8A2-B6A282D5095D}"
				Class      = "_LMCSafety"
				Position   = "(240,1380)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="Emergency"/>
					<Client Name="HWError"/>
					<Client Name="HWMax"/>
					<Client Name="HWMin"/>
					<Client Name="HWReady"/>
					<Client Name="LMCController"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Control" Destination="_base.Control" Vertices="(2794,210),(2094,210),"/>
			<Connection Source="this._LMCSafety1" Destination="_LMCSafety1.ClassSvr"/>
			<Connection Source="_base.LMCSafety" Destination="_LMCSafety1.ClassSvr" Vertices="(1298,510),(840,510),(840,1470),(640,1470),"/>
			<Connection Source="_LMCAxisRef1.HWMin" Destination="this.HWMin" Vertices="(690,1830),(38,1830),"/>
			<Connection Source="this.ErrorConfig" Destination="_base.ErrorConfig" Vertices="(2794,1470),(2094,1470),"/>
			<Connection Source="_LMCAxisRef1.HWMax" Destination="this.HWMax" Vertices="(690,1890),(38,1890),"/>
			<Connection Source="_LMCSafety1.HWReady" Destination="this.HWReady" Vertices="(240,1470),(38,1710),"/>
			<Connection Source="_LMCSafety1.HWError" Destination="this.HWError" Vertices="(240,1530),(38,1770),"/>
			<Connection Source="_base.LMCPreRtWorkTrigger" Destination="this.LMCPreRtWorkTrigger" Vertices="(1298,330),(38,330),"/>
			<Connection Source="this.PosMode" Destination="_base.PosMode" Vertices="(2794,330),(2094,330),"/>
			<Connection Source="_LMCAxisVis1.LMCAxisBase" Destination="_base.Control" Vertices="(2190,180),(2094,210),"/>
			<Connection Source="this.AxisError" Destination="_base.AxisError" Vertices="(2794,390),(2094,390),"/>
			<Connection Source="this.ActPos" Destination="_base.ActPos" Vertices="(2794,450),(2094,450),"/>
			<Connection Source="_base.LMCPostRtWorkTrigger" Destination="this.LMCPostRtWorkTrigger" Vertices="(1298,390),(38,390),"/>
			<Connection Source="this.SetPos" Destination="_base.SetPos" Vertices="(2794,510),(2094,510),"/>
			<Connection Source="_base.ActPosition" Destination="this.ActPosition" Vertices="(1298,210),(38,210),"/>
			<Connection Source="this.ExUnits" Destination="_base.ExUnits" Vertices="(2794,870),(2094,870),"/>
			<Connection Source="this.IntUnits" Destination="_base.IntUnits" Vertices="(2794,930),(2094,930),"/>
			<Connection Source="this.VMax" Destination="_base.VMax" Vertices="(2794,990),(2094,990),"/>
			<Connection Source="this.AMax" Destination="_base.AMax" Vertices="(2794,1050),(2094,1050),"/>
			<Connection Source="this.Tjerk" Destination="_base.Tjerk" Vertices="(2794,1110),(2094,1110),"/>
			<Connection Source="_LMCSafety1.HWMin" Destination="this.HWMin" Vertices="(240,1590),(38,1830),"/>
			<Connection Source="_LMCSafety1.HWMax" Destination="this.HWMax" Vertices="(240,1650),(38,1890),"/>
			<Connection Source="this._LMCMathFunctions1" Destination="_LMCMathFunctions1.ClassSvr"/>
			<Connection Source="this.MoveType" Destination="_base.MoveType" Vertices="(2794,1170),(2094,1170),"/>
			<Connection Source="this.Resolution" Destination="_base.Resolution" Vertices="(2794,1230),(2094,1230),"/>
			<Connection Source="_base.LMCMath" Destination="_LMCMathFunctions1.ClassSvr" Vertices="(1298,450),(810,450),(810,510),(706,510),"/>
			<Connection Source="this.AxisStatus" Destination="_base.AxisStatus" Vertices="(2794,270),(2094,270),"/>
			<Connection Source="this.Destination" Destination="_base.Destination" Vertices="(2794,570),(2094,570),"/>
			<Connection Source="this.Override" Destination="_base.Override" Vertices="(2794,630),(2094,630),"/>
			<Connection Source="this.ActVelocity" Destination="_base.ActVelocity" Vertices="(2794,690),(2094,690),"/>
			<Connection Source="this.SetVelocity" Destination="_base.SetVelocity" Vertices="(2794,750),(2094,750),"/>
			<Connection Source="this.SimulateMode" Destination="_base.SimulateMode" Vertices="(2794,810),(2094,810),"/>
			<Connection Source="_base.LMCController" Destination="this.LMCController" Vertices="(1298,270),(38,270),"/>
			<Connection Source="this._LMCAxisRef1" Destination="_LMCAxisRef1.RefInput"/>
			<Connection Source="this._LMCAxisVis1" Destination="_LMCAxisVis1.ClassSvr"/>
			<Connection Source="this._LMCABSEncoder1" Destination="_LMCABSEncoder1.ClassSvr"/>
			<Connection Source="_base.LMCAbsEncoder" Destination="_LMCABSEncoder1.ClassSvr" Vertices="(1298,630),(1140,630),(1140,1830),(1920,1830),(1920,1980),(1842,1980),"/>
			<Connection Source="this.Modulo" Destination="_base.Modulo" Vertices="(2794,1290),(2094,1290),"/>
			<Connection Source="_base.LMCReference" Destination="_LMCAxisRef1.RefInput" Vertices="(1298,570),(1020,570),(1020,1530),(1110,1530),(1110,1830),(1064,1830),"/>
			<Connection Source="_LMCAxisRef1.RefSwitch" Destination="this.RefSwitch" Vertices="(690,2010),(38,2010),"/>
			<Connection Source="_LMCAxisRef1.ZImpulse" Destination="this.ZImpulse" Vertices="(690,1950),(38,1950),"/>
			<Connection Source="_LMCAxisRef1.LatchPos" Destination="this.LatchPos" Vertices="(690,2070),(38,2070),"/>
			<Connection Source="this.AbsEncoder" Destination="_LMCABSEncoder1.AbsEncoder" Vertices="(2794,1710),(2370,1710),(2340,1740),(2340,2190),(2310,2220),(1842,2220),"/>
			<Connection Source="this.SWMinPos" Destination="_base.SWMinPos" Vertices="(2794,1350),(2094,1350),"/>
			<Connection Source="this.SWMaxPos" Destination="_base.SWMaxPos" Vertices="(2794,1410),(2094,1410),"/>
			<Connection Source="_LMCSafety1.Emergency" Destination="this.Emergency" Vertices="(240,1710),(38,2130),"/>
			<Connection Source="this.AEmergency" Destination="_base.AEmergency" Vertices="(2794,1530),(2094,1530),"/>
			<Connection Source="this._LMCPublisher1" Destination="_LMCPublisher1.ClassSvr"/>
			<Connection Source="_LMCPublisher1.Provider" Destination="this.Provider" Vertices="(510,2250),(480,2250),(420,2190),(38,2190),"/>
			<Connection Source="_LMCPublisher1.Config" Destination="this.Config" Vertices="(510,2310),(420,2310),(360,2250),(38,2250),"/>
			<Connection Source="_LMCPublisher1.ID" Destination="this.ID" Vertices="(510,2370),(360,2370),(300,2310),(38,2310),"/>
			<Connection Source="_base.LMCPublisher" Destination="_LMCPublisher1.ClassSvr" Vertices="(1298,750),(1200,750),(1200,2250),(1066,2250),"/>
			<Connection Source="_LMCSafety1.LMCController" Destination="this.LMCController" Vertices="(240,1770),(180,1770),(180,270),(38,270),"/>
			<Connection Source="this.JMax" Destination="_base.JMax" Vertices="(2794,1590),(2094,1590),"/>
			<Connection Source="this.SafeAxisState" Destination="_base.SafeAxisState" Vertices="(2794,1650),(2094,1650),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _LMCAxisBase

_LMCAxis : CLASS
: _LMCAxisBase
  //Servers:
	AbsEncoder 	: SvrCh_DINT;
  //Clients:
	HWReady 	: CltCh_DINT;
	HWError 	: CltCh_DINT;
	HWMin 	: CltCh_DINT;
	HWMax 	: CltCh_DINT;
	_LMCMathFunctions1 	: CltChCmd__LMCMathFunctions;
	_LMCABSEncoder1 	: CltChCmd__LMCABSEncoder;
	ZImpulse 	: CltCh_DINT;
	RefSwitch 	: CltCh_DINT;
	LatchPos 	: CltCh_DINT;
	_LMCAxisVis1 	: CltChCmd__LMCAxisVis;
	_LMCAxisRef1 	: CltChCmd__LMCAxisRef;
	_LMCSafety1 	: CltChCmd__LMCSafety;
	Emergency 	: CltCh_DINT;
	_LMCPublisher1 	: CltChCmd__LMCPublisher;
	Provider 	: CltChCmd_ProfileCommandStatus;
	Config 	: CltCh__Config__PTofCls__LMCPublisher;
	ID 	: CltCh_DINT;
  //Variables:
  //Functions:
				//! <Function Comment="This method activates the position controller.&#13;&#10;If a SetParameter() call has locked the possibility to change the Move Direction, the move direction (mode) is ignored.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="PowerOn"/>
	FUNCTION VIRTUAL GLOBAL PowerOn
		VAR_INPUT
			Mode 	: _LMCAXIS_MOVEDIRECTION := LMCAXIS_MOVE_ANY_WAY;			//! <Variable Comment="Set direction of movement for the axis&#13;&#10;" Name="PowerOn.Mode"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="PowerOn.CommandState"/>
		END_VAR;
				//! <Function Comment="This method deactivates the position controller.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="PowerOff"/>
	FUNCTION VIRTUAL GLOBAL PowerOff
		VAR_INPUT
			Mode 	: _LMCAXIS_POWER_OFF_MODE;			//! <Variable Comment="Shutdown mode&#13;&#10; --&gt; immediate shutdown of the controller&#13;&#10; --&gt; Ramp down after an emergency stop and subsequent shut-down of the controller" Name="PowerOff.Mode"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="PowerOff.CommandState"/>
		END_VAR;
				//! <Function Comment="This method is used for endless movement if no axis reference is done.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="MoveHand"/>
	FUNCTION VIRTUAL GLOBAL MoveHand
		VAR_INPUT
			Speed 	: DINT;			//! <Variable Comment="Axis speed of the movement [Application units / s]" Name="MoveHand.Speed"/>
			Accel 	: DINT;			//! <Variable Comment="Axis acceleration of the movement [Application units / s²]" Name="MoveHand.Accel"/>
			Jerk 	: DINT := 0;			//! <Variable Comment="Axis jerk of the movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="MoveHand.Jerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="MoveHand.CommandState"/>
		END_VAR;
				//! <Function Comment="Endless axis movement.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="MoveEndless"/>
	FUNCTION VIRTUAL GLOBAL MoveEndless
		VAR_INPUT
			Speed 	: DINT;			//! <Variable Comment="Axis speed of the movement [Application units / s]" Name="MoveEndless.Speed"/>
			Accel 	: DINT;			//! <Variable Comment="Axis acceleration of the movement [Application units / s²]" Name="MoveEndless.Accel"/>
			Jerk 	: DINT := 0;			//! <Variable Comment="Axis jerk of the movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="MoveEndless.Jerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="MoveEndless.CommandState"/>
		END_VAR;
				//! <Function Comment="Axis movement to an absolute position.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="MoveAbsolute"/>
	FUNCTION VIRTUAL GLOBAL MoveAbsolute
		VAR_INPUT
			Position 	: DINT;			//! <Variable Comment="Targetposition for the axis [Application units]" Name="MoveAbsolute.Position"/>
			Speed 	: DINT;			//! <Variable Comment="Axis speed of the movement [Application units / s]" Name="MoveAbsolute.Speed"/>
			Accel 	: DINT;			//! <Variable Comment="Axis acceleration of the movement [Application units / s²]" Name="MoveAbsolute.Accel"/>
			Decel 	: DINT := 0;			//! <Variable Comment="Axis deceleration of the movement [Application units / s²]" Name="MoveAbsolute.Decel"/>
			Jerk 	: DINT := 0;			//! <Variable Comment="Axis jerk of the movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="MoveAbsolute.Jerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="MoveAbsolute.CommandState"/>
		END_VAR;
				//! <Function Comment="Axis movement to an absolute position. Chooses the shortest way for a modulo axis.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="MoveShortestWay"/>
	FUNCTION VIRTUAL GLOBAL MoveShortestWay
		VAR_INPUT
			Position 	: DINT;			//! <Variable Comment="Target position for the axis [application units]" Name="MoveShortestWay.Position"/>
			Speed 	: DINT;			//! <Variable Comment="Speed of the axis [application units / sec]" Name="MoveShortestWay.Speed"/>
			Accel 	: DINT;			//! <Variable Comment="acceleration of the axis [application units / s²]" Name="MoveShortestWay.Accel"/>
			Decel 	: DINT := 0;			//! <Variable Comment="deceleration of the axis [application units / s²]" Name="MoveShortestWay.Decel"/>
			Jerk 	: DINT := 0;			//! <Variable Comment="Axis jerk of the movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="MoveShortestWay.Jerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis." Name="MoveShortestWay.CommandState"/>
		END_VAR;
				//! <Function Comment="Axis reference movement.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="MoveReference"/>
	FUNCTION VIRTUAL GLOBAL MoveReference
		VAR_INPUT
			Mode 	: _LMCAXIS_REFMODE;			//! <Variable Comment="Defines the reference mode" Name="MoveReference.Mode"/>
			Position 	: DINT;			//! <Variable Comment="Reference position [Application units]" Name="MoveReference.Position"/>
			VRef1 	: DINT;			//! <Variable Comment="Speed used when searching for the reference switch [Application units/s]" Name="MoveReference.VRef1"/>
			VRef2 	: DINT;			//! <Variable Comment="Speed used when backing off from the reference switch [Application units/s]" Name="MoveReference.VRef2"/>
			Accel 	: DINT;			//! <Variable Comment="Acceleration / deceleration used when searching for the reference switch and when backing off from it [Application units/s²]" Name="MoveReference.Accel"/>
			PositionWindow 	: DINT;			//! <Variable Comment="Distance within which the Z pulse must occur after leaving the reference switch [Application units]" Name="MoveReference.PositionWindow"/>
			RefJerk 	: DINT := 0;			//! <Variable Comment="Axis jerk of the movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="MoveReference.RefJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="MoveReference.CommandState"/>
		END_VAR;
				//! <Function Comment="Axis relative position movement.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="MoveRelative"/>
	FUNCTION VIRTUAL GLOBAL MoveRelative
		VAR_INPUT
			Position 	: DINT;			//! <Variable Comment="distance of the movement [Application units]" Name="MoveRelative.Position"/>
			Mode 	: _LMCAXIS_MOVE_RELATIVE_MODE;			//! <Variable Comment="MOVE_RELATIVE_TO_DESTINATION --&gt; Position is relative to the last target position&#13;&#10;MOVE_RELATIVE_TO_POSIITON    --&gt; Position is relative to the actual position" Name="MoveRelative.Mode"/>
			Speed 	: DINT;			//! <Variable Comment="Axis speed of the movement [Application units / s]" Name="MoveRelative.Speed"/>
			Accel 	: DINT;			//! <Variable Comment="Axis acceleration of the movement [Application units / s²]" Name="MoveRelative.Accel"/>
			Decel 	: DINT := 0;			//! <Variable Comment="Axis deceleration of the movement [Application units / s²]" Name="MoveRelative.Decel"/>
			Jerk 	: DINT := 0;			//! <Variable Comment="Axis jerk of the movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="MoveRelative.Jerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="MoveRelative.CommandState"/>
		END_VAR;
				//! <Function Comment="Stops axis movement.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="StopMove"/>
	FUNCTION VIRTUAL GLOBAL StopMove
		VAR_INPUT
			Decel 	: DINT;			//! <Variable Comment="Axis deceleration of the movement [Application units / s²]" Name="StopMove.Decel"/>
			Jerk 	: DINT := 0;			//! <Variable Comment="Axis jerk of the movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="StopMove.Jerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="StopMove.CommandState"/>
		END_VAR;
				//! <Function Comment="Stop Axis Movement intended for the MoveType _SCURVE_PROFILE. Other profiles behaive ident to StopMove. When calling  QuickStop the &#13;&#10;stop in MoveType _SCURVE_PROFILE corresponds to a _RAMP_PROFILE.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="QuickStop"/>
	FUNCTION VIRTUAL GLOBAL QuickStop
		VAR_INPUT
			Decel 	: DINT;			//! <Variable Comment="Axis deceleration of the movement [Application units / s²]" Name="QuickStop.Decel"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis&#13;&#10;" Name="QuickStop.CommandState"/>
		END_VAR;
				//! <Function Comment="Start tune function&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread.&#13;&#10;&#13;&#10;" Name="TuneAxis"/>
	FUNCTION VIRTUAL GLOBAL TuneAxis
		VAR_INPUT
			Position 	: DINT;			//! <Variable Comment="Target or distance for the axis [Application units]" Name="TuneAxis.Position"/>
			Speed 	: DINT;			//! <Variable Comment="Maximum speed [Application units / s]" Name="TuneAxis.Speed"/>
			Accel 	: DINT;			//! <Variable Comment="Axis acceleration [Application units / s² ]" Name="TuneAxis.Accel"/>
			Mode 	: _LMCAXIS_TUNE_MODE;			//! <Variable Comment=" INTERVALL__ACTPOSITION_POSITION          --&gt; Movement between the actual position and the position added to it.&#13;&#10; INTERVALL__ZERO_TO_POSITIVE_POSITION     --&gt; Movement between the specified position and 0&#13;&#10; INTERVALL__POSITON_IN_POSITIVE_DIRECTION --&gt; Relative movement in the positive direction&#13;&#10; INTERVALL__ZERO_TO_NEGATIVE_POSITION     --&gt; Movement between the specified negative position and 0&#13;&#10; INTERVALL__POSITON_IN_NEGATIVE_DIRECTION --&gt; Relative movement in the negative direction&#13;&#10;" Name="TuneAxis.Mode"/>
			WaitTime 	: UDINT;			//! <Variable Comment="A TuneTime is set [ms]. This Tunetime is simply a delay after each movement. " Name="TuneAxis.WaitTime"/>
			Jerk 	: DINT := 0;			//! <Variable Comment="Axis jerk of the movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="TuneAxis.Jerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="TuneAxis.CommandState"/>
		END_VAR;
				//! <Function Comment="Checks whether the axis is in the position window." Name="InPosition"/>
	FUNCTION VIRTUAL GLOBAL InPosition
		VAR_INPUT
			Mode 	: _LMCAXIS_QUERY_POSITION_MODE;			//! <Variable Comment="Position window unit&#13;&#10;0 --&gt; Position window in application units&#13;&#10;1 --&gt; Position window in internal units&#13;&#10;-1 --&gt; no Position window is used (Result = 1 if Flag InPosition and Flag FiltRdy is TRUE)" Name="InPosition.Mode"/>
			PositionWindow 	: DINT;			//! <Variable Comment="value of the position window" Name="InPosition.PositionWindow"/>
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;			//! <Variable Comment="0 --&gt; Axis not in position&#13;&#10;1 --&gt; Axis in position" Name="InPosition.Result"/>
		END_VAR;
				//! <Function Comment="Absolute gear coupling&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="CoupleGearAbsolute"/>
	FUNCTION VIRTUAL GLOBAL CoupleGearAbsolute
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed of the axis for this movement [Application units / s]" Name="CoupleGearAbsolute.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum axis acceleration / deceleration [Application units / s² ]" Name="CoupleGearAbsolute.MaxAcc"/>
			DeltaPos 	: DINT;			//! <Variable Comment="Position difference between the master axis and the slave axis [internal units]" Name="CoupleGearAbsolute.DeltaPos"/>
			pMaster 	: ^MasterStruct;			//! <Variable Comment="pointer to the master axis information. use method ReadMasterInfo()" Name="CoupleGearAbsolute.pMaster"/>
			GearMul 	: DINT;			//! <Variable Comment="Multiplier for the gear ratio" Name="CoupleGearAbsolute.GearMul"/>
			GearDiv 	: DINT;			//! <Variable Comment="Divisor for the gear ratio" Name="CoupleGearAbsolute.GearDiv"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximum jerk of the axis for this movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CoupleGearAbsolute.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="CoupleGearAbsolute.CommandState"/>
		END_VAR;
				//! <Function Comment="Relative gear coupling&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="CoupleGearRelative"/>
	FUNCTION VIRTUAL GLOBAL CoupleGearRelative
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed of the axis for this movement [Application units / s]" Name="CoupleGearRelative.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum axis acceleration / deceleration [Application units / s² ]" Name="CoupleGearRelative.MaxAcc"/>
			pMaster 	: ^MasterStruct;			//! <Variable Comment="pointer to the master axis information. use method ReadMasterInfo()" Name="CoupleGearRelative.pMaster"/>
			GearMul 	: DINT;			//! <Variable Comment="Multiplier for the gear ratio" Name="CoupleGearRelative.GearMul"/>
			GearDiv 	: DINT;			//! <Variable Comment="Divisor for the gear ratio" Name="CoupleGearRelative.GearDiv"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximum jerk of the axis for this movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CoupleGearRelative.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="CoupleGearRelative.CommandState"/>
		END_VAR;
				//! <Function Comment="Speed coupling&#13;&#10;The difference between CoupleSpeed and CoupleSpeed2 is that in CoupleSpeed&#13;&#10;the couple is made over the difference of the positions, and in the CoupleSpeed2,&#13;&#10;it couple with the speed&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="CoupleGearVelocity"/>
	FUNCTION VIRTUAL GLOBAL CoupleGearVelocity
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed of the axis for this movement [Application units / s]" Name="CoupleGearVelocity.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum axis acceleration / deceleration [Application units / s² ]" Name="CoupleGearVelocity.MaxAcc"/>
			pMaster 	: ^MasterStruct;			//! <Variable Comment="pointer to the master axis information. use method ReadMasterInfo()" Name="CoupleGearVelocity.pMaster"/>
			GearMul 	: DINT;			//! <Variable Comment="Multiplier for the gear ratio" Name="CoupleGearVelocity.GearMul"/>
			GearDiv 	: DINT;			//! <Variable Comment="Divisor for the gear ratio" Name="CoupleGearVelocity.GearDiv"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximum jerk of the axis for this movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CoupleGearVelocity.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="CoupleGearVelocity.CommandState"/>
		END_VAR;
				//! <Function Comment="Electronic CAM coupling&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="CoupleCAM"/>
	FUNCTION VIRTUAL GLOBAL CoupleCAM
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed of the axis for this movement [Application units / s]" Name="CoupleCAM.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum axis acceleration / deceleration [Application units / s² ]" Name="CoupleCAM.MaxAcc"/>
			DeltaPosMaster 	: DINT;			//! <Variable Comment="Position offset in the master axis of the cam definition [CAM Master units].&#13;&#10;Added to the master axis position before searching the table." Name="CoupleCAM.DeltaPosMaster"/>
			pMaster 	: ^MasterStruct;			//! <Variable Comment="Pointer to the master axis information (MasterStruct). Use method ReadMasterInfo()." Name="CoupleCAM.pMaster"/>
			GearMulMaster 	: DINT;			//! <Variable Comment="Numerator of the master axis scale factor.&#13;&#10;The scale factor is used on the master axis before searching the table." Name="CoupleCAM.GearMulMaster"/>
			GearDivMaster 	: DINT;			//! <Variable Comment="Denominator of the master axis scale factor.&#13;&#10;The scale factor is used on the master axis before searching the table." Name="CoupleCAM.GearDivMaster"/>
			Modulo 	: DINT;			//! <Variable Comment="Modulo value of the master.&#13;&#10;If the master is no modulo axis, then set Modulo=0." Name="CoupleCAM.Modulo"/>
			GearMulSlave 	: DINT;			//! <Variable Comment="Numerator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="CoupleCAM.GearMulSlave"/>
			GearDivSlave 	: DINT;			//! <Variable Comment="Denominator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="CoupleCAM.GearDivSlave"/>
			OffsetSlave 	: DINT;			//! <Variable Comment="Position offset in the slave axis of the cam definition [Internal units].&#13;&#10;Added to the slave value of the cam table." Name="CoupleCAM.OffsetSlave"/>
			Mode 	: _LMCAXIS_CURVETABMODE;			//! <Variable Comment="Slave axis operating mode" Name="CoupleCAM.Mode"/>
			pCurveTable 	: DINT;			//! <Variable Comment="Pointer to the cam table casted to DINT.&#13;&#10;Use the ClassSvr.Read()-method of the class, which has been generated by the Lasal CAM Designer or cast the result of _LMCCAM.calcCAMData().&#13;&#10;It is important that the memory range of the given CAM Table is not changed since the class uses the given table and does not create a local copy." Name="CoupleCAM.pCurveTable"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximum jerk of the axis for this movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CoupleCAM.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="CoupleCAM.CommandState"/>
		END_VAR;
				//! <Function Comment="Electronic CAM coupling [old version]&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="CoupleCurveTab"/>
	FUNCTION VIRTUAL GLOBAL CoupleCurveTab
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed of the axis for this movement [Application units / s]" Name="CoupleCurveTab.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum axis acceleration / deceleration [Application units / s² ]" Name="CoupleCurveTab.MaxAcc"/>
			DeltaPos 	: DINT;			//! <Variable Comment="Position offset in the master axis of the cam definition [CAM Master units].&#13;&#10;Added to the master axis position before searching the table." Name="CoupleCurveTab.DeltaPos"/>
			pMaster 	: ^MasterStruct;			//! <Variable Comment="Pointer to the master axis information (MasterStruct). Use method ReadMasterInfo()." Name="CoupleCurveTab.pMaster"/>
			GearMul 	: DINT;			//! <Variable Comment="Numerator of the master axis scale factor.&#13;&#10;The scale factor is used on the master axis before searching the table." Name="CoupleCurveTab.GearMul"/>
			GearDiv 	: DINT;			//! <Variable Comment="Denominator of the master axis scale factor.&#13;&#10;The scale factor is used on the master axis before searching the table." Name="CoupleCurveTab.GearDiv"/>
			Mode 	: _LMCAXIS_CURVETABMODE;			//! <Variable Comment="Slave axis operating mode" Name="CoupleCurveTab.Mode"/>
			pCurveData 	: ^_LMCAXIS_CURVE;			//! <Variable Comment="Pointer to the curve data" Name="CoupleCurveTab.pCurveData"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximum jerk of the axis for this movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CoupleCurveTab.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="CoupleCurveTab.CommandState"/>
		END_VAR;
				//! <Function Comment="Method CoupleGearPosCatch couples a slave axis to a master axis using a polynomial of higher order without jerks.&#13;&#10;  The slave starts with zero velocity and should achieve a target velocity Multiplier*Divisor*vM travelling sSlave units&#13;&#10;  while the master travels sMaster units with velocity vM. (Posmode=PolyCatch).&#13;&#10;  After the slave is catched it is locked (not permitted to go backwards) (PosMode=PolySync)&#13;&#10;  Method CoupleGearPosCatch does the calculations which mus be claculated only once, the main calculation is done in method PolyLock.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="CoupleGearPolynom"/>
	FUNCTION VIRTUAL GLOBAL CoupleGearPolynom
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed of the axis for this movement [Application units / s]" Name="CoupleGearPolynom.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum axis acceleration / deceleration [Application units / s² ]" Name="CoupleGearPolynom.MaxAcc"/>
			pMaster 	: ^MasterStruct;			//! <Variable Comment="Pointer to the master axis information (MasterStruct). Use method ReadMasterInfo()." Name="CoupleGearPolynom.pMaster"/>
			GearMul 	: DINT;			//! <Variable Comment="Multiplier for the gear ratio" Name="CoupleGearPolynom.GearMul"/>
			GearDiv 	: DINT;			//! <Variable Comment="Divisor for the gear ratio" Name="CoupleGearPolynom.GearDiv"/>
			sMaster 	: DINT;			//! <Variable Comment="Distance travelled by the master axis during coupling [Application units]" Name="CoupleGearPolynom.sMaster"/>
			sSlave 	: DINT;			//! <Variable Comment="Distance travelled by the slave axis during coupling [Application units]" Name="CoupleGearPolynom.sSlave"/>
			TargetMaster 	: BOOL := TRUE;			//! <Variable Comment="Select whether the slave axis is coupled or decoupled.&#13;&#10;TRUE  ... (default) vOut = velocity of the master * GearMul / GearDiv&#13;&#10;FALSE ... vOut = 0" Name="CoupleGearPolynom.TargetMaster"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximum jerk of the axis for this movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CoupleGearPolynom.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="CoupleGearPolynom.CommandState"/>
		END_VAR;
				//! <Function Comment="add an additional positiondifference&#13;&#10;every cycle, when&#13;&#10;PosMode = _ProfileSyncPositioning&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="CoupleAdditivePosDiff"/>
	FUNCTION VIRTUAL GLOBAL CoupleAdditivePosDiff
		VAR_INPUT
			pPosDiff 	: ^DINT;			//! <Variable Comment="pointer to the positiondifference [internal units]" Name="CoupleAdditivePosDiff.pPosDiff"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="CoupleAdditivePosDiff.CommandState"/>
		END_VAR;
				//! <Function Comment="Coupling to an user position.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="CoupleUserPos"/>
	FUNCTION VIRTUAL GLOBAL CoupleUserPos
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed of the axis for this movement [Application units / s]" Name="CoupleUserPos.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum axis acceleration / deceleration [Application units / s² ]" Name="CoupleUserPos.MaxAcc"/>
			pMasterPos 	: ^DINT;			//! <Variable Comment="pointer to the setvalue of the master [internal units]" Name="CoupleUserPos.pMasterPos"/>
			DeltaPos 	: DINT;			//! <Variable Comment="Position difference between the master position and the slave axis [internal units]" Name="CoupleUserPos.DeltaPos"/>
			GearMul 	: DINT;			//! <Variable Comment="Multiplier for the gear ratio" Name="CoupleUserPos.GearMul"/>
			GearDiv 	: DINT;			//! <Variable Comment="Divisor for the gear ratio" Name="CoupleUserPos.GearDiv"/>
			Mode 	: _LMCAXIS_COUPLE_GEAR_MODE;			//! <Variable Comment="Mode = COUPLE_PROFILE_GEAR    --&gt; with gear&#13;&#10;Mode = COUPLE_PROFILE_NO_GEAR --&gt; without gear" Name="CoupleUserPos.Mode"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximum jerk of the axis for this movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CoupleUserPos.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="CoupleUserPos.CommandState"/>
		END_VAR;
				//! <Function Comment="Coupling to a LREAL user position (for MoveType=_JERK_PROFILE only)&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="CoupleUserPosExtended"/>
	FUNCTION VIRTUAL GLOBAL CoupleUserPosExtended
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed of the axis for this movement [Application units / s]" Name="CoupleUserPosExtended.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum axis acceleration / deceleration [Application units / s² ]" Name="CoupleUserPosExtended.MaxAcc"/>
			pMasterPos 	: ^LREAL;			//! <Variable Comment="pointer to the set value (LREAL) of the master [internal units]" Name="CoupleUserPosExtended.pMasterPos"/>
			DeltaPos 	: DINT;			//! <Variable Comment="Position difference between the master position and the slave axis [internal units]" Name="CoupleUserPosExtended.DeltaPos"/>
			GearMul 	: DINT;			//! <Variable Comment="Multiplier for the gear ratio" Name="CoupleUserPosExtended.GearMul"/>
			GearDiv 	: DINT;			//! <Variable Comment="divisor for the gear ratio" Name="CoupleUserPosExtended.GearDiv"/>
			Mode 	: _LMCAXIS_COUPLE_GEAR_MODE;			//! <Variable Comment="Mode = COUPLE_PROFILE_GEAR    --&gt; with gear&#13;&#10;Mode = COUPLE_PROFILE_NO_GEAR --&gt; without gear" Name="CoupleUserPosExtended.Mode"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximum jerk of the axis for this movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CoupleUserPosExtended.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="CoupleUserPosExtended.CommandState"/>
		END_VAR;
				//! <Function Comment="Offset position coupling&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="CoupleDeltaPos"/>
	FUNCTION VIRTUAL GLOBAL CoupleDeltaPos
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed of the axis for this movement [Application units / s]" Name="CoupleDeltaPos.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum axis acceleration / deceleration [Application units / s² ]" Name="CoupleDeltaPos.MaxAcc"/>
			DeltaPos 	: ^DINT;			//! <Variable Comment="Pointer to the position difference value of the master axis [internal units]" Name="CoupleDeltaPos.DeltaPos"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximum jerk of the axis for this movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CoupleDeltaPos.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="CoupleDeltaPos.CommandState"/>
		END_VAR;
				//! <Function Comment="Offset position coupling with a LREAL value (for MoveType=_JERK_PROFILE only)&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread.&#13;&#10;&#13;&#10;&#13;&#10;" Name="CoupleDeltaPosExtended"/>
	FUNCTION VIRTUAL GLOBAL CoupleDeltaPosExtended
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed of the axis for this movement [Application units / s]" Name="CoupleDeltaPosExtended.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum axis acceleration / deceleration [Application units / s² ]" Name="CoupleDeltaPosExtended.MaxAcc"/>
			DeltaPos 	: ^LREAL;			//! <Variable Comment="Pointer to the position difference value of the master axis (LREAL) [internal units]" Name="CoupleDeltaPosExtended.DeltaPos"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximum jerk of the axis for this movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CoupleDeltaPosExtended.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="CoupleDeltaPosExtended.CommandState"/>
		END_VAR;
				//! <Function Comment="Change coupling parameters&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="ChangeCoupleSettings"/>
	FUNCTION VIRTUAL GLOBAL ChangeCoupleSettings
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed of the axis for this movement [Application units / s]" Name="ChangeCoupleSettings.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum axis acceleration / deceleration [Application units / s² ]" Name="ChangeCoupleSettings.MaxAcc"/>
			DeltaPos 	: DINT;			//! <Variable Comment="Position difference between the master axis and the slave axis [internal units]" Name="ChangeCoupleSettings.DeltaPos"/>
			GearMul 	: DINT;			//! <Variable Comment="Multiplier for the gear ratio" Name="ChangeCoupleSettings.GearMul"/>
			GearDiv 	: DINT;			//! <Variable Comment="Divisor for the gear ratio" Name="ChangeCoupleSettings.GearDiv"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximum jerk of the axis for this movement [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="ChangeCoupleSettings.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="ChangeCoupleSettings.CommandState"/>
		END_VAR;
				//! <Function Comment="This method is used to set internal or external position&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="SetPosition"/>
	FUNCTION VIRTUAL GLOBAL SetPosition
		VAR_INPUT
			Mode 	: _LMCAXIS_SETPOSITION;			//! <Variable Comment="Type of the position value" Name="SetPosition.Mode"/>
			Position 	: DINT;			//! <Variable Comment="Position value, depending on the parameter mode the units are either application units or internal units." Name="SetPosition.Position"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="SetPosition.CommandState"/>
		END_VAR;
				//! <Function Comment="Sets the software parameter.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="SetParameter"/>
	FUNCTION VIRTUAL GLOBAL SetParameter
		VAR_INPUT
			ParNr 	: _LMCAXIS_SETPARAMETER;			//! <Variable Comment="Parameter number" Name="SetParameter.ParNr"/>
			Value 	: DINT;			//! <Variable Comment="New value" Name="SetParameter.Value"/>
			mode 	: DINT;			//! <Variable Comment="For further information about the mode see the documentation of the class _LMCAxis" Name="SetParameter.mode"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="SetParameter.CommandState"/>
		END_VAR;
				//! <Function Comment="Set software end position.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="SetSWEndPos"/>
	FUNCTION VIRTUAL GLOBAL SetSWEndPos
		VAR_INPUT
			Mode 	: _LMCAXIS_SETSWENDPOS;			//! <Variable Comment="Type of the end position value" Name="SetSWEndPos.Mode"/>
			Position 	: DINT;			//! <Variable Comment="Value for the corresponding SW end position. Depending on the parameter mode the units are either application units or internal units." Name="SetSWEndPos.Position"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="SetSWEndPos.CommandState"/>
		END_VAR;
				//! <Function Comment="Sets client values&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="SetAdjustment"/>
	FUNCTION VIRTUAL GLOBAL SetAdjustment
		VAR_INPUT
			No 	: _LMCAXIS_SETSERVER;			//! <Variable Comment="Server-ID" Name="SetAdjustment.No"/>
			Value 	: DINT;			//! <Variable Comment="desired server value" Name="SetAdjustment.Value"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="0 --&gt; Value was not accepted&#13;&#10;Possible Causes: - Value does not exist&#13;&#10;                 - Controller is enabled&#13;&#10;1 --&gt; Value has been accepted" Name="SetAdjustment.CommandState"/>
		END_VAR;
				//! <Function Comment="Internal profile position " Name="ReadPosition"/>
	FUNCTION VIRTUAL GLOBAL ReadPosition
		VAR_INPUT
			Mode 	: _LMCAXIS_READPOS;			//! <Variable Comment="Type of the position that should be read" Name="ReadPosition.Mode"/>
		END_VAR
		VAR_OUTPUT
			Position 	: DINT;			//! <Variable Comment="Internal position of the axis depending on the selected mode" Name="ReadPosition.Position"/>
		END_VAR;
				//! <Function Comment="Reads the axis speed" Name="ReadVelocity"/>
	FUNCTION VIRTUAL GLOBAL ReadVelocity
		VAR_INPUT
			Mode 	: _LMCAXIS_READVELOCITY;			//! <Variable Comment="Type of the axis velocity that should be read" Name="ReadVelocity.Mode"/>
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;			//! <Variable Comment="Axis velocity depending on the selected mode" Name="ReadVelocity.Result"/>
		END_VAR;
				//! <Function Comment="Reads the software parameters." Name="ReadParameter"/>
	FUNCTION VIRTUAL GLOBAL ReadParameter
		VAR_INPUT
			ParNr 	: _LMCAXIS_READPARAMETER;			//! <Variable Comment="Parameter number" Name="ReadParameter.ParNr"/>
			mode 	: DINT;			//! <Variable Comment="Valid for paramters LMCAXIS_PAR_RD_V_MAX, LMCAXIS_PAR_RD_A_MAX, LMCAXIS_PAR_RD_REFPOS&#13;&#10;0 --&gt; Value is returned in [Application units]&#13;&#10;1 --&gt; Value is returned in [Internal units]" Name="ReadParameter.mode"/>
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;			//! <Variable Comment="Software parameter" Name="ReadParameter.Result"/>
		END_VAR;
				//! <Function Comment="Reads software parameters with floating point result." Name="ReadParameterLREAL"/>
	FUNCTION VIRTUAL GLOBAL ReadParameterLREAL
		VAR_INPUT
			ParNo 	: _LMCAXIS_READPARAMETER_LREAL;			//! <Variable Comment="parameter number" Name="ReadParameterLREAL.ParNo"/>
			mode 	: DINT;			//! <Variable Comment="sub parameter number" Name="ReadParameterLREAL.mode"/>
		END_VAR
		VAR_OUTPUT
			Result 	: LREAL;			//! <Variable Comment="software parameter" Name="ReadParameterLREAL.Result"/>
		END_VAR;
				//! <Function Comment="This method reads the software end position" Name="ReadSWEndPos"/>
	FUNCTION VIRTUAL GLOBAL ReadSWEndPos
		VAR_INPUT
			Mode 	: _LMCAXIS_READSWENDPOS;			//! <Variable Comment="0 --&gt; Maximum SW end position with cResolution_Fact [Application units]&#13;&#10;1 --&gt; Minimum SW end position with cResolution_Fact [Application units]&#13;&#10;2 --&gt; Maximum SW software end position without cResolution_Fact [Internal units]&#13;&#10;3 --&gt; Minimum SW software end position without cResolution_Fact [Internal units]" Name="ReadSWEndPos.Mode"/>
		END_VAR
		VAR_OUTPUT
			Position 	: DINT;			//! <Variable Comment="Software end position Depending on the mode, either application units or internal units" Name="ReadSWEndPos.Position"/>
		END_VAR;
				//! <Function Comment="Provides the actual profile status." Name="ReadAxisError"/>
	FUNCTION VIRTUAL GLOBAL ReadAxisError
		VAR_OUTPUT
			AxisErrorInfo 	: _LMCAXIS_ERROR;			//! <Variable Comment="Profile status of the axis" Name="ReadAxisError.AxisErrorInfo"/>
		END_VAR;
				//! <Function Comment="Provides the actual axis status." Name="ReadAxisStatus"/>
	FUNCTION VIRTUAL GLOBAL ReadAxisStatus
		VAR_OUTPUT
			Status 	: _LMCAXIS_STATUS;			//! <Variable Comment="Status flags of the axis" Name="ReadAxisStatus.Status"/>
		END_VAR;
				//! <Function Comment="Pointer to the master structure" Name="ReadMasterInfo"/>
	FUNCTION VIRTUAL GLOBAL ReadMasterInfo
		VAR_INPUT
			usDelay 	: USINT := 0;			//! <Variable Comment="delay of the Master" Name="ReadMasterInfo.usDelay"/>
		END_VAR
		VAR_OUTPUT
			MasterPtr 	: ^MasterStruct;			//! <Variable Comment="Pointer to the master structure" Name="ReadMasterInfo.MasterPtr"/>
		END_VAR;
				//! <Function Comment="For internal use only." Name="ReadUserData"/>
	FUNCTION VIRTUAL GLOBAL ReadUserData
		VAR_INPUT
			index 	: DINT;
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
				//! <Function Comment="Calculate the duration of a movement" Name="CalcMovingTime"/>
	FUNCTION VIRTUAL GLOBAL CalcMovingTime
		VAR_INPUT
			StartPos 	: DINT;			//! <Variable Comment="Start-position [Application units]" Name="CalcMovingTime.StartPos"/>
			EndPos 	: DINT;			//! <Variable Comment="End-position [Application units]" Name="CalcMovingTime.EndPos"/>
			Vstart 	: DINT;			//! <Variable Comment="Start-velocity [Application units / s]" Name="CalcMovingTime.Vstart"/>
			Vende 	: DINT;			//! <Variable Comment="End-velocity [Application units / s]" Name="CalcMovingTime.Vende"/>
			Accel 	: DINT;			//! <Variable Comment="Maximal allowed acceleration [Application units / s²]" Name="CalcMovingTime.Accel"/>
			Decel 	: DINT;			//! <Variable Comment="Maximal allowed deceleration [Application units / s²]" Name="CalcMovingTime.Decel"/>
			Vmax 	: DINT;			//! <Variable Comment="Maximal allowed velocity [Application units / s]" Name="CalcMovingTime.Vmax"/>
			pMovingTime 	: ^UDINT;			//! <Variable Comment="Pointer to the calculated result [Milliseconds]." Name="CalcMovingTime.pMovingTime"/>
			Jerk 	: DINT := 0;			//! <Variable Comment="Maximal allowed jerk [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CalcMovingTime.Jerk"/>
		END_VAR
		VAR_OUTPUT
			CalcState 	: _LMCAXIS_MOVINGTIMEERROR;			//! <Variable Comment="State of the calculation.&#13;&#10;0 -&gt; no error occured&#13;&#10;1 ... 19 -&gt; errorcodes" Name="CalcMovingTime.CalcState"/>
		END_VAR;
				//! <Function Comment="SetFollowMode(LMCAXIS_DEACTIVATE_FOLLOW_MODE) deacitvates the _LMCAXIS_OPMODE: FOLLOW_LMCAXIS&#13;&#10;SetFollowMode(LMCAXIS_ACTIVATE_FOLLOW_MODE) acitvates the _LMCAXIS_OPMODE: FOLLOW_LMCAXIS -&gt;&#13;&#10;-&gt; Axis follows the actual position (defaulted by a controller) passively&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="SetFollowMode"/>
	FUNCTION VIRTUAL GLOBAL SetFollowMode
		VAR_INPUT
			Mode 	: _LMCAXIS_FOLLOW_MODE;			//! <Variable Comment="Mode = DEACTIVATE_FOLLOW_MODE -&gt; deactive the status &quot;FOLLOW_LMCAXIS&quot;&#13;&#10;Mode = ACTIVATE_FOLLOW_MODE   -&gt;   active the status &quot;FOLLOW_LMCAXIS&quot;" Name="SetFollowMode.Mode"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis" Name="SetFollowMode.CommandState"/>
		END_VAR;
				//! <Function Comment="Reset all axis errors and, if the client &quot;LMCController&quot; is connected&#13;&#10;the function: QuitHWError is called to reset all harware-errors too&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="QuitError"/>
	FUNCTION VIRTUAL GLOBAL QuitError;
				//! <Function Comment="Maximal possible slave path for successful coupling by the function &quot;CoupleGearPolynom&quot;" Name="CalcMaxSlavePath"/>
	FUNCTION VIRTUAL GLOBAL CalcMaxSlavePath
		VAR_INPUT
			MaxVel 	: DINT;			//! <Variable Comment="Maximum speed [Application units / s]" Name="CalcMaxSlavePath.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="Maximum acceleration [application units / s²]" Name="CalcMaxSlavePath.MaxAcc"/>
			pMaster 	: ^MasterStruct;			//! <Variable Comment="pointer to the master axis information. use method ReadMasterInfo()" Name="CalcMaxSlavePath.pMaster"/>
			GearMul 	: DINT;			//! <Variable Comment="Multiplier for the gear ratio" Name="CalcMaxSlavePath.GearMul"/>
			GearDiv 	: DINT;			//! <Variable Comment="Divisor for the gear ratio" Name="CalcMaxSlavePath.GearDiv"/>
			sMaster 	: DINT;			//! <Variable Comment="Distance coupled by the master" Name="CalcMaxSlavePath.sMaster"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximal allowed jerk [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CalcMaxSlavePath.MaxJerk"/>
		END_VAR
		VAR_OUTPUT
			MaxSlavePath 	: DINT;			//! <Variable Comment="Maximal possible slave path for successful coupling by the function &quot;CoupleGearPolynom&quot;" Name="CalcMaxSlavePath.MaxSlavePath"/>
		END_VAR;
				//! <Function Comment="Calculates the internal position in application units&#13;&#10;of the input parameter" Name="CalcExtToAppliPos"/>
	FUNCTION VIRTUAL GLOBAL CalcExtToAppliPos
		VAR_INPUT
			Param 	: DINT;			//! <Variable Comment="position to be converted" Name="CalcExtToAppliPos.Param"/>
		END_VAR
		VAR_OUTPUT
			OutParam 	: DINT;			//! <Variable Comment="internal position in application units" Name="CalcExtToAppliPos.OutParam"/>
		END_VAR;
				//! <Function Comment="Computes the distance, which will be covered until a new target velocity is reached." Name="CalcSpeedChangePath"/>
	FUNCTION VIRTUAL GLOBAL CalcSpeedChangePath
		VAR_INPUT
			NewVel 	: DINT;			//! <Variable Comment="new target velocity [application units / sec]" Name="CalcSpeedChangePath.NewVel"/>
			MaxAccel 	: DINT;			//! <Variable Comment="maximal acceleration [application units / sec^2]" Name="CalcSpeedChangePath.MaxAccel"/>
			MaxDecel 	: DINT;			//! <Variable Comment="maximal deceleration [application units / sec^2]&#13;&#10;In the case of _RAMP_Profile, 1,25 times the deceleration is used for calculation. " Name="CalcSpeedChangePath.MaxDecel"/>
			MaxJerk 	: DINT := 0;			//! <Variable Comment="Maximal jerk [Application units / sec^3 / 1000] (for MoveType=_JERK_PROFILE only)" Name="CalcSpeedChangePath.MaxJerk"/>
			NextTick 	: USINT := 0;			//! <Variable Comment="If this parameter is 0, the speed change path is calculation from the actual tick.&#13;&#10;If this parameter is not 0, the speed change path is calculated from the subsequent tick (1 tick in the future).&#13;&#10;This parameter is only available for MoveType = _JERK_PROFILE." Name="CalcSpeedChangePath.NextTick"/>
		END_VAR
		VAR_OUTPUT
			DeltaPos 	: DINT;			//! <Variable Comment="distance, which is covered until we reach the new velocity. [application units]" Name="CalcSpeedChangePath.DeltaPos"/>
		END_VAR;
				//! <Function Comment="This method allows the user to change the move settings (limits) of an active move command.&#13;&#10;The change in settings can also be activated for a specified distance, after the distance has been travelled, the previous settings are restored.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="ChangeMoveSettings"/>
	FUNCTION VIRTUAL GLOBAL ChangeMoveSettings
		VAR_INPUT
			MaxVel 	: UDINT;			//! <Variable Comment="This input variable is used to set the Velocity Limit of the active Move Command:&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;Mode = 0&#13;&#10;Percentage reduction of the actual speed limit.&#13;&#10;(1000 = 100.0%)&#13;&#10;&#13;&#10;Mode = 1&#13;&#10;Velocity Limit in Application Units / Sec." Name="ChangeMoveSettings.MaxVel"/>
			MaxAcc 	: DINT;			//! <Variable Comment="This input variable is used to set the Acceleration Limit of the active Move Command in Application Units / s².&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;MaxAcc &gt; 0 - The new limit is activated.&#13;&#10;MaxAcc = 0 - The actual value is taken as the new Limit.&#13;&#10;MaxAcc &lt; 0 - The acceleration limit is not changed." Name="ChangeMoveSettings.MaxAcc"/>
			MaxDec 	: DINT;			//! <Variable Comment="This input variable is used to set the Deceleration Limit of the active Move Command in Application Units / s².&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;MaxDec &gt; 0 - The new limit is activated.&#13;&#10;MaxDec = 0 - The actual value is taken as the new Limit.&#13;&#10;MaxDec &lt; 0 - The Deceleration limit is not changed." Name="ChangeMoveSettings.MaxDec"/>
			Dist 	: DINT;			//! <Variable Comment="This input variable can be used to supply a distance over which the new limits must be effective, after the axis has travelled this distance, the old limits are effective.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;Dist &gt; 0 - The distance is limit is observed.&#13;&#10;Dist = 0 - The distance is limit is ignored." Name="ChangeMoveSettings.Dist"/>
			Modus 	: DINT := 0;			//! <Variable Comment="This input variable allows the user to specify the velocity limit in either Per Mill or Application Units / s.&#13;&#10;See the description of MaxVel for further information.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;Modus=0 - MaxVel is specified as per mill of the active maximal velocity (1000 = 100.0%)&#13;&#10;Modus=1 - MaxVel is specified as velocity [application units / sec]" Name="ChangeMoveSettings.Modus"/>
			Jerk 	: DINT := 0;			//! <Variable Comment="This input variable is used to set the Jerk of the active Move Command in Application Units / s^3.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;Jerk &gt; 0 - The new Jerk setting is activated.&#13;&#10;Jerk &lt;= 0 - The Jerk setting is not changed." Name="ChangeMoveSettings.Jerk"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="The retcode specifies the status of the command.&#13;&#10;&#13;&#10;Possible values are:&#13;&#10;&lt;&gt; 0 - An Error Occurred. (See flags for further details)&#13;&#10;= 0 - No Error Occurred." Name="ChangeMoveSettings.CommandState"/>
		END_VAR;
				//! <Function Comment="this methode delivers 0 until a special&#13;&#10;point is reached" Name="GetPosInfoBeforeRampDown"/>
	FUNCTION VIRTUAL GLOBAL GetPosInfoBeforeRampDown
		VAR_INPUT
			Mode 	: _LMCAXIS_POSINFOMODE;			//! <Variable Comment=" 0 ... time&#13;&#10; 1 ... distance" Name="GetPosInfoBeforeRampDown.Mode"/>
			Value 	: DINT;			//! <Variable Comment="Value of time [Milliseconds], or distance [Application units]" Name="GetPosInfoBeforeRampDown.Value"/>
		END_VAR
		VAR_OUTPUT
			RetValue 	: DINT;			//! <Variable Comment=" 0 ... point not reached&#13;&#10; 1 ... point reached" Name="GetPosInfoBeforeRampDown.RetValue"/>
		END_VAR;
				//! <Function Comment="Method to get safety data information from the hardware axis. The method allows to read safety specific values from the hardware.&#13;&#10;Using the parameter Mode to define if the value is read from the hardware classes or a new request is sent to the hw. Reading the safety error code and safety function error word is always done by reading it from the hw." Name="GetSafetyState"/>
	FUNCTION VIRTUAL GLOBAL GetSafetyState
		VAR_INPUT
			Parameter 	: t_e_LMCAXIS_GETSAFETYPARAMETER;			//! <Variable Comment="The parameter defines which safety data should be read from the hardware. See the description of the ENUM values of the connected type." Name="GetSafetyState.Parameter"/>
			pPara1 	: ^DINT;			//! <Variable Comment="First return value of the read safety data from the drive. See the comment or description of the used ENUM entry to see the details which value is returned." Name="GetSafetyState.pPara1"/>
			pPara2 	: ^DINT;			//! <Variable Comment="Second return value of the read safety data from the drive. See the comment or description of the used ENUM entry to see the details which value is returned." Name="GetSafetyState.pPara2"/>
			pPara3 	: ^DINT;			//! <Variable Comment="Third return value of the read safety data from the drive. See the comment or description of the used ENUM entry to see the details which value is returned." Name="GetSafetyState.pPara3"/>
			pPara4 	: ^DINT;			//! <Variable Comment="Fourth return value of the read safety data from the drive. See the comment or description of the used ENUM entry to see the details which value is returned." Name="GetSafetyState.pPara4"/>
			Mode 	: DINT;			//! <Variable Comment="Additional input parameter to define the specific request for the given input parameter. See the description of the ENUM entry which modes are available for the choosen parameter." Name="GetSafetyState.Mode"/>
		END_VAR
		VAR_OUTPUT
			QueryState 	: iprStates;			//! <Variable Comment="Return value of the command. The query state marks if the returned values are already valid or reading of the value is still ongoing or failed.&#13;&#10;READY ... the returned values are valid and the read request is finished. It is possible to trigger a new read command afterwards.&#13;&#10;ERROR ... reading the requested data failed. The values on the return parameters are not valid.&#13;&#10;BUSY ... reading the requested data is still ongoing. Keep calling the method to read the desired data." Name="GetSafetyState.QueryState"/>
		END_VAR;
				//! <Function Comment="Calculates the correct start position of a slave axis for cam coupling from the master position and the cam. [application units]" Name="ReadSlavePosCam"/>
	FUNCTION VIRTUAL GLOBAL ReadSlavePosCam
		VAR_INPUT
			MasterPos 	: DINT;			//! <Variable Comment="Position of the master axis in internal units of the master axis." Name="ReadSlavePosCam.MasterPos"/>
			DeltaPosMaster 	: DINT;			//! <Variable Comment="Position offset in the master axis of the cam definition [CAM Master units].&#13;&#10;Added to the master axis position before searching the table." Name="ReadSlavePosCam.DeltaPosMaster"/>
			GearMulMaster 	: DINT;			//! <Variable Comment="Numerator of the master axis scale factor." Name="ReadSlavePosCam.GearMulMaster"/>
			GearDivMaster 	: DINT;			//! <Variable Comment="Denominator of the master axis scale factor." Name="ReadSlavePosCam.GearDivMaster"/>
			Modulo 	: DINT;			//! <Variable Comment="Modulo value of the master.&#13;&#10;If the master is no modulo axis, then set Modulo=0." Name="ReadSlavePosCam.Modulo"/>
			GearMulSlave 	: DINT;			//! <Variable Comment="Numerator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="ReadSlavePosCam.GearMulSlave"/>
			GearDivSlave 	: DINT;			//! <Variable Comment="Denominator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="ReadSlavePosCam.GearDivSlave"/>
			OffsetSlave 	: DINT;			//! <Variable Comment="Position offset in the slave axis of the cam definition [Internal units].&#13;&#10;Added to the slave value of the cam table." Name="ReadSlavePosCam.OffsetSlave"/>
			pCurveTable 	: DINT;			//! <Variable Comment="Pointer to the cam table casted to DINT.&#13;&#10;Use the ClassSvr.Read()-method of the class, which has been generated by the Lasal CAM Designer." Name="ReadSlavePosCam.pCurveTable"/>
		END_VAR
		VAR_OUTPUT
			SlavePos 	: DINT;			//! <Variable Comment="Position of the slave axis from the cam table [application units]" Name="ReadSlavePosCam.SlavePos"/>
		END_VAR;
				//! <Function Comment="Set or delete a dynamic software end position for this axis.&#13;&#10;&#13;&#10;This method is only allowed to be called from a thread running on the same core as the realtime thread for the _LMCAxis instance which has an equal or lower priority than the realtime thread." Name="SetDynSwEndPos"/>
	FUNCTION VIRTUAL GLOBAL SetDynSwEndPos
		VAR_INPUT
			pSWEndPos 	: ^DINT;			//! <Variable Comment="Pointer to the dynamic SW end position.&#13;&#10;To delete a dynamic SW end position set this pointer to NIL." Name="SetDynSwEndPos.pSWEndPos"/>
			Mode 	: _LMC_DYN_SWLIMITS;			//! <Variable Comment="Choose maximum or minimum dynamic position" Name="SetDynSwEndPos.Mode"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Status flags of the axis." Name="SetDynSwEndPos.CommandState"/>
		END_VAR;
				//! <Function Comment="Method to send safety settings to the hardware axis. The method allows to directly send commands, which are safety specific to the hardware." Name="SetSafetyState"/>
	FUNCTION VIRTUAL GLOBAL SetSafetyState
		VAR_INPUT
			Parameter 	: t_e_LMCAXIS_SETSAFETYPARAMETER;			//! <Variable Comment="The parameter defines which safety command should be sent to the hardware. See the description of the ENUM values of the connected type." Name="SetSafetyState.Parameter"/>
			Mode 	: DINT;			//! <Variable Comment="Additional parameter to alter the command defined by the parameter. See the documentation and type description of the parameter to see options offered by &quot;Mode&quot;." Name="SetSafetyState.Mode"/>
		END_VAR
		VAR_OUTPUT
			CommandState 	: _LMCAXIS_CMDERROR;			//! <Variable Comment="Returns if the request was successul:&#13;&#10;CommandState = 0 ... No error, command successful&#13;&#10;CommandState.GlobalError = 1 ... Command failed (CommandState &lt;&gt; 0)." Name="SetSafetyState.CommandState"/>
		END_VAR;
				//! <Function Comment="to get the LogFile from the axis" Name="GetLogFile"/>
	FUNCTION VIRTUAL GLOBAL GetLogFile
		VAR_OUTPUT
			ptrLogFile 	: ^_LogFile;			//! <Variable Comment="pointer to the Logfile variable" Name="GetLogFile.ptrLogFile"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AbsEncoder::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AbsEncoder::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _LMCABSEncoder
#pragma using _LMCAxisRef
#pragma using _LMCAxisVis
#pragma using _LMCMathFunctions
#pragma using _LMCPublisher
#pragma using _LMCSafety


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _LMCAxis::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__LMCAXIS
1$UINT, 114$UINT, (SIZEOF(::_LMCAxis))$UINT, 
1$UINT, 17$UINT, 0$UINT, 
TO_UDINT(1422175863), "_LMCAxis", //Class
TO_UDINT(280984637), "_LMCAxisBase", 2$UINT, 105$UINT, //Baseclass
//Servers:
(::_LMCAxis.AbsEncoder.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(964833016), "AbsEncoder", 
//Clients:
(::_LMCAxis.HWReady.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(3806358573), "HWReady", 
(::_LMCAxis.HWError.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(2544391667), "HWError", 
(::_LMCAxis.HWMin.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(820401606), "HWMin", 
(::_LMCAxis.HWMax.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(216754847), "HWMax", 
(::_LMCAxis._LMCMathFunctions1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2908414770), "_LMCMathFunctions1", TO_UDINT(838927485), "_LMCMathFunctions", 1$UINT, 75$UINT, 
(::_LMCAxis._LMCABSEncoder1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2161537050), "_LMCABSEncoder1", TO_UDINT(3162349954), "_LMCABSEncoder", 1$UINT, 0$UINT, 
(::_LMCAxis.ZImpulse.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(3924944392), "ZImpulse", 
(::_LMCAxis.RefSwitch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(3537427625), "RefSwitch", 
(::_LMCAxis.LatchPos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(3334411160), "LatchPos", 
(::_LMCAxis._LMCAxisVis1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2529122408), "_LMCAxisVis1", TO_UDINT(3113915997), "_LMCAxisVis", 1$UINT, 40$UINT, 
(::_LMCAxis._LMCAxisRef1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(661835855), "_LMCAxisRef1", TO_UDINT(2147194214), "_LMCAxisRef", 1$UINT, 32$UINT, 
(::_LMCAxis._LMCSafety1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1893339440), "_LMCSafety1", TO_UDINT(3213872914), "_LMCSafety", 1$UINT, 21$UINT, 
(::_LMCAxis.Emergency.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(1646202866), "Emergency", 
(::_LMCAxis._LMCPublisher1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2851164490), "_LMCPublisher1", TO_UDINT(1117088251), "_LMCPublisher", 1$UINT, 0$UINT, 
(::_LMCAxis.Provider.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000100$UINT, TO_UDINT(1425534928), "Provider", 
(::_LMCAxis.Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(611510522), "Config", 
(::_LMCAxis.ID.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(299066170), "ID", 
END_FUNCTION


#define USER_CNT__LMCAxis 63

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__LMCAxis] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _LMCAxis::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _LMCAxisBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _AxisBase::Control.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _AxisBase::Control.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__LMCAxis;
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #PowerOn();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #PowerOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #MoveHand();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #MoveEndless();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #MoveAbsolute();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #MoveShortestWay();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #MoveReference();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #MoveRelative();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #StopMove();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #QuickStop();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #TuneAxis();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #InPosition();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #CoupleGearAbsolute();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #CoupleGearRelative();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #CoupleGearVelocity();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #CoupleCAM();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #CoupleCurveTab();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #CoupleGearPolynom();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #CoupleAdditivePosDiff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #CoupleUserPos();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #CoupleUserPosExtended();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #CoupleDeltaPos();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #CoupleDeltaPosExtended();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #ChangeCoupleSettings();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #SetPosition();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #SetParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #SetSWEndPos();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #SetAdjustment();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[31]		:= #ReadPosition();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #ReadVelocity();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #ReadParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #ReadParameterLREAL();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #ReadSWEndPos();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #ReadAxisError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #ReadAxisStatus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #ReadMasterInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[39]		:= #ReadUserData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[41]		:= #CalcMovingTime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[42]		:= #SetFollowMode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[43]		:= #QuitError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[44]		:= #CalcMaxSlavePath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #CalcExtToAppliPos();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[47]		:= #CalcSpeedChangePath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[48]		:= #ChangeMoveSettings();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[49]		:= #GetPosInfoBeforeRampDown();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[50]		:= #GetSafetyState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[51]		:= #ReadSlavePosCam();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[52]		:= #SetDynSwEndPos();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[53]		:= #SetSafetyState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[55]		:= #GetLogFile();

#pragma warning (default : 74)
	_AxisBase::Control.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _AxisBase::Control.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AbsEncoder.pMeth			:= StoreMethod( #AbsEncoder::Read(), #AbsEncoder::Write() );
	IF AbsEncoder.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
//{{LSL_ENCRYPTION 16#800
37DEA058F342212FF2412A957A14F9952540EF5D8D12968C1B1FF33745F3082BF8C70BD76AED7F2F88755140CD0FC4A14D84DF74ACD72C1A27482B0E0840C52FCA47805098985BC8BF388DA0943AA6057063DF1C71E5B22B19B129D15577CC37B4EC3553
20DBF9C0F81353789F6CC75E1099DF10F37B3F768C5026AEBA6EAE97ED4F9DF845F1115B433DA10BBB77F42934AB2E402C2E26F59232B3DA9F8DF1358654A423BA10AA7901731F4EE949097B8BDF9294F9ADA29BF9ABC8D6884CCD79687B5F1AA35777CC
AD3B534ED9DD14BFDFF99BEB5DE3F80F12000E13647E695779F79F06A1794ED119F20705213B6F2B60682DEF4A53E912F9B453A9608BF3E503BB989FBB35FA86BA38305C234E84BD20A0B8F1F12980FD9D5E3F3FB11BA8BD0B4DCDF8B23E3C202BC4979F
7B23EE61752863A9467CB1C0F6D6451F3B8A7240B7615E6CB2804B01AFCEF9F534A8654546647A76D81E109F3E3EDB85A9B592FC04D23D92738E7F3C103AEBC18D6E8C2DCF57B46041EF0FB9EB1437F7D19786AE9942E8134D2586E060DED79D13031CFB
E280B84D04A0DA190FB52209EBE7F1A3024C1B5F672012C5A1B90532358E828CF806994A6DD64CA45EDCF55553EE5B50CF43E5F3DE4C10091F01B634F5030C935B7A3473476C4A85B51FF4E22F667CAAD5978B4EC7E52C554013632BFFA7FD50B078926C
E959BE1C95829E5FEF86159A922A2973EDF5F9A5B30E40226C9917473BE158434A43DE0A74891D10F14339F23FB5B57BFFDFF2A633DA2633CE293F13950CDA0DEDEB6DFC4387BD0D4C3443E272A7E25B86409F76E37650E853B59C1B14C2D7254841FCCD
0D9EFDFF324244ACE990B84A6F4A1F1330AE81DD976FB57180976A02044169778ED845EF0ABCB8FBCC1CE24B79F23C59FB9C82032C376E1C772C03896CDC2FCAD4879309E6E3908DA607E282BFD4610DAD23EE0F96E33E4C7ED089E23A315350105277EF
92656C697284AC708FFD62C9BC2E0998B1EBADDF3407ECAB00D1B150359B7A3D304ACC21E3BE76135AE8B027049176FF7BBD8392B0405C5473A8ABDAB63B3E1CC126F8577F81CADFB7982C2AFB1FCE0C0FAFC5D339A27F2C40DDB2B54970D9B349A7F251
3E1067D1519AC0BED123EACB230F42737C6FA4C92430C637CA1BF61D22E5A35160014523FF8549971B2F6DDF473FD8BB7FA3CA1B8E6962CDF9932CE53C78A05A69A4FB1A59A4F36752769FD7B66EBFA3ACA45E4BF137E1F8957A03AFE3C33D6413C53BC5
9F4C41A67309A82EA50201F340F5450452C6EBFCDF42CE50749889CEFEB4AEAA170706D58D03278CB09BFDB003A68DC25E041D25E403CE961480F4A562E086606C546EE287AC18074D646361C2A35FD45657E87DE454ED5939852B9F21AB6E486B9F05FA
B311F2332792D8082E52F56B0F574587CA326DA36124C13029E57449D15B49E81760DDBDDC5BB227AE735F9A63D74BF9AEFA1256CB418F4D61F668B7E04E5AC3188F9069CD70C7DF4FF1F2E0AE2EF1F8051C754A73FF3403E1B7DAB777F4F84C5D789E6B
4745EC36E244FAC91D86384CC44D940A1A92BBECC668DCF6E3A021647758A7B3198E8FC6F7FE8DE14AEAC8AB5F354BD26F7278CF114734E5E018491C92A6B64C672FB53409DC2CE7D75A3DD2D06B5C1BB08FD780F139BC769DBDC01ACF1F0AAA7D2ADC77
29B2060A10D19A5953F2833DB47135EC951A97B2368BE9D0DF3AC682ED26D163ED810BAF2C5FA51F652DE8EE99BBF817BDA611303CE7FBF0BF40258F6A4ECD49DB97E497861696D5D74A1FA0E6A675A6E71E83318E42BEC94837CEE471EA3B1D65421C67
4C4C6B7E2A0B29D517F9B6883FA6C1BE50FFFA4DB9A0837486C98B3043A84A4BEEC205BA507A153AEE2FE445A77A6B799B469D13B5AF3A44DA498EDD5F00901185E948D3B1CE1813F080F0E91EBEAED468E0B01651469987034B98437BA2C2552FAABFA9
E178B73E76497B043215C43A0B43A88551B1C20C5475CC13F1574BED842CE29DAF5EC7F1632AB9C8A79F7347B7B1EDEDF46B07694522AEA872CB468977948888DC6020BF327F9DFE54094AF1970F634D18E6FA3C7E1300F2EA1398CC7FA6589ABAF2577C
436B7E6D00FEC0368ABC90EC0C65B6EA143F099426B5D9F71C5A01139E60049124ABB35A19F80B2B8FEC1BF95CF7A3B1DCA8E18BC36835645D2DD0AE2C2EBCA3D558094D1F7F93EE1944D64CD0A8135EC028FD11CDC9F3F4D0DE51EB7E7BF413FCA23916
6C5CC5B895097331C78426F370FBE2F76467C98BD70F4F420FE50E996282115820ED48CF6717FDD9FB450279E16CC3367603F356F34C2F8FF55231B051581F049A71E51B51EE57FA9CC3D68F76199933A8BCFEB76990425AE36EC343D334FADEF4BAA99D
7E414BC5E3676585095BB0AD2BFADD172A02E291C52AA42740F71EFC786DA7C593D2A33B1994FE0456F818944A7A1412278979DA12CC05CEDDB5165A3200D078C96EA85999826231A5B5F4052D7C1FBE09652BE9822C4F8096B2795AF033F55C7E00E3C6
C925625D4AF76062D6CCA5B3D49F0CBBFB2FD8DB1B57EFB5F41B909D7FEAD45DA90818D8887A0C7B88CD826C417AACF006A61BB46AAE0C59CA79BF1E2FE6FE586213C543A233DC21578893F731D201E784402E0D4337EE8B2C96DA6CC985BA49E0E0E803
2217074E6BEA96D941185A0F60F3895FF088F08CE4538EE96E0632B4AF0360193602A04EFB219E6259660DE0D73CE99484CB42AEF75CF5DAB9FBB56C1B28FF14A8FB48C0002CE39A26CD13B2CBC99079509210B37C0E846ACA3A94B6FC72E58363D86133
43D6D07539CEE51D8503F7C893AFF1B46EC732D7467A3AA9F30AC333F4ADE7B66324D8F73D0FF4E16DE36082AB5F3B5BEDD674BE322977EFF11F9EE5CA18B5542F7355CC99BA94C67A3B64B6060F3BB7F624B79DAF81D40C7472D565E726E8461075BAA1
E8B84B06073DEAAC135040053AA01D2633B0B46380C0F1648598E1F3C426B27E9D1D2250096ECEC3CE02DDB8561ACFDC2D195A638E7681934021DF2A2CF831012F6D22F7FADBDD87C39EA3D420A551A122C40EB6FE336BF513034AE9C3D358DC18CAF1B1
B52F34F7886DFFB512D4DB1182B1A256248743EB5BE28D7B8AC432CC8B35FF06E1C86D45E1FBFB00B3EA898AA0CA10D4242EE7F3BC95E77307D18AF6F5472E6B79E37418262B08F17FE40DBBA4C973DA3CC74A39E42465798D7CB026B2D534A02BA14C53
1D7779E4B969E323DCC8281A06F2A95B83C4F3924F08BDE9FEAB7491B2E4C748F207B6BAAEB0CA6C65F5DEF39EEB360DC159DC862A7126A0DEDEFB2EC5021F3E8B4C6664D3C74E16B64D82983D0A1D5E668ED9B022FE67863E705F45D0E0819840BF026E
CFA723A280ACAB0AA6A0EAA47671FCBB9988A38C209395D97A33955733A1F5A0EEAC72C957169EB4406285B6BCAA50E16D6BB7DC3A05E9614865BCCCBC40168AC7E765EE5F9152B8B2A01B4E3FABE9D6F5AF656AC9D6649954CAAD2E17398B6008E09768
C35E19378F8DF234352E4E0981DCEEABE2998EC80403F57B2336B956BA75490F03E4119571A66EA302089E0DD30B61986CDFEBCE584842D583D3714B6AF854960F369A0D620E99636DFE12EBEA7954B786C46B269DCCFAA71CC5D788A13A37ED5D5AD945
D83B0BFD3AB5ABC26C37E65B51F4DC665044AB185C431991C48423C65C9B2AECD48D7703BEE72959345E6E0A245CF6F2F2AFF9300CBA6571B1CFA8FAC1914462FD84A11ED0D834D7089F1A3F1638BD0EB0C9EF47F936CE55C156535F5D2339E242C7FCBA
029EE780D537969BBA7B599263FEB05B4197F353E61DE084E56C17A132CB9E592AF63B2DCB60ED6C9EB427A5BE8A9F3C3639EC373800A7C65F21DAD502A9F127BD0D7F4A2F3A4A9EBC42070BEB39651CC0527BBE4C1B3A85F57301386B8D8BE39A6DD835
FB09929D86693E70802E8F6EC754124CF73D3EFF03B932692FDF65E915991485DF2FA5BA924A1081FD876EE894CB1844DEF4EE291E7304094B062B14D1A876F477FC1739F2D9D893CAC1BDE107B70947130359BDE74D490E6466087F7A180AAA016BA123
64E8E28F99F951254AA75086BC67523CB0A28503903D1706F3B0BF684B498630C9EED7EF4ED67D38E8170509CBC2DF841D3292E950FF96C580E22BA143F5DAB13791D785A4847DDB619113396C9C0BE3B6097914F30EB9C8F9685BA34F6FD4DC63794548
E2C345C75F40BD555C780DEE279F150BDBA41B610E7D0ACB85B066A59C3547FFEB35AC0AC0C153AF8C85D8314A76A90079CD668993031677B0D80D15E185430BB7928F1EF7909394D2A0D0A5C37C9D643412C8681CF6BCC3AD0FA51475C3C1B41D0DABB8
D0A4737DB1B03A10C80A20A4FA8413DE7B86A725C266D8B4CBE1E575B1FF2E6C73C8EA12A67F9D221291DB8EE11094A40C3912151CCF3DFAA03C3048E0E64D47E17C55524A70A8412CA6508A5157E1FA5331BB746A07C428AB83376AF0525AC0A8B6DD20
8220AC910D13D6DA16890082245A21DD1CD50B0063AF1A479EB789715663C3D18BF641CDBDB1C78DE03DB817E14ACBDB8EB6F622E4350F4B62BC06F9D0A15073C993DD32DF8B9E9C0222E972A5C677FE3523B34CEEDD867A31770BCCD891487A2BA9933F
473AA556BD7B61FDBA03B2B0EDF907878BF22A886C0D9C79CF250BD31AE91C01A09D05431F87EC6169B9A99233424506DE1C6861D9DE9899D445697C57C4E442AE3BEBC700C78CD7A13ED34396772A9E79B0CB75435B2184A7A8B7FFC87BA78DBAE13653
BC6E67A90B96CEE0DEBA53AEBF7ECE52911B3615B1891DD4DD7D75BD7617834F19E2AB2DC914ED6967607F7C19ADCFED91153A2433873FA95F7EB109BEEE6DD4579BF70CD7F46F59167BCDF29921FF88A062D0F8E97DB328FE3FF2A964023C43694C08E6
07F54CDFE5365AE646CF91781B91569B4600F4647A96B2C3C0CED972F81BBC17DF38C20CCBB3AE3E08929771282A8E4500A6C3E1972E5CF4626B4793D73651CB0DAD0AC2161393B3F9DB896429B4987F9BBB1D3580EA97236F32374781B9B6A08640F528
724171C6C42E85BE7E7CF770F5DBE97178657BA4C5FF53094C7E8E3AE02E6811C232277BB93B92B876DA9F738E8261B514F5189A42E17DF21D021A260588785700F7CED56DAF2CAB0025948094F9D4C949ED2F7577FD1D1E9D54E0AD30FC14A3F8B260D1
4C5DDA58940D7BEB276D96F57ABC352A3D9467C829961E8162779A3EED4FAAABC6E3C6C75BAC17D4D496500B156FDA7DF42C34FDC2BAC30E971FB0626AD205D1C8E2D8B9322BBB250163D674F9F2A601EFFBB5651F18608242C7543C94CDDACDDFCC443E
AD2CC7B4EE86465E5BD031910D2362790FB03AFB4AFCCD63BC515D633BFECD387DE60497BDB87058EE1C6E929E8F3D9CDA96E21E5AE8E7E3090200B3B68D7D432D2389F1506D73A2C8F7C19AF82EFFA7BF71CC61EF8B70ABC110DEE26BA8A318C8DB702A
299073956FDE39041D46E72E8B42C6347EEC436394ECEA908D14CAD5F6B38B36BAFD89C01CFADFB045552E0E8E1915BB67302FEB88210115273B8ED93042AF1657981C4CE0C0809B2541C4275AD1C5CB91079BAAF6C4B89B2AE39CB19CD62F34A61B2C69
0C40F01357D819334340A61566F610BD5B54CBC482274622E80ED874DD4B3E0CC5641BA6C93F953C649F17769BF79EE9EFFD2006CB2509CF1880A581006CDC147A80D6838799FDB3142298BCA8F9E42D072E01CB47960B7E68805EC64E0E3FF7BA1444FC
22191FEB85748A59998BE20D60A0B794500CCFA11D2FB03A52A59E1CF994CA3AA204FAE7C7772444D7F98ECF249CB43C3091D3C033431DFC804E27CE09D09E201F57D3FEFB2DF1679E144A643A71A1A6BB4DC488826B2FC23F2CF45B22B19DD6DF124634
4BCCA9543623F3FE7A67F18D3BD158699B6E269AC9AF833A3D97ECF0D156DAC92942BB1B45FA96CBFD1A7BE0C705C76E6AB08A27105178691CB4D39EA1B1519A20159AD9FF5D1B61FDC947590D6941784BAF1A151784C187CBC2EA1C5034E6B4DA76EE5D
5C921BBB061C603F80F11F06BFE4EA3A4469DDBE9DC794C28EA994E14A447326D3509B82DEC82E1FE92AD5D359C1715B2CAF5E8BB4BF3BB278F8F194FD2E76F128022C8074229A538991831B3FC930266FA63F928D95421D8A764B1F08A343F3F7E41932
386F61B25FB8742CA3CA7E048E175A181FBD510C51FC40FB4E0E40AFEB20F2BFF5093949C7F8C68BF3F8D876A80E0189529B94435CC88CEE3654A2D26519AA447C47D1F8F26E335A204DAECE1BC6A9AE25D3B56D6AB0B0F796243A30E9EC17D2808D46DC
6FCE82178987096058EE7202AF8A80253C60D40E534BD9159E119A66F7A6A076B382E725769395BC5FAF8587365E81F8EE5031F08F4E6BB6DBD484B7BD266616E719805C04141EF2D12E513A2F397332706074FA6332057C76E66C0C7024BD47DC4A7B82
76D86399C82A7F6F0A0B3A94A20625035AC3B377573391EBB5809A25A232472DF39ADC5F19E48538547164EDAFEEA76886CFD30A51A629C36625A39512ACC6737C8EAA1E458AFCD284C87C46F27BB447D659DDEA4145C989F44C9CD77E536069CD2B0C3D
8B3167E0152AB7710C3AAD0895070A6BFB943C0B8F1AE8D5F251A151769D9D33BC02343826A04E9D4CB9CFC7B60F152FD16D1451C511F747286089352A22CA7919DCA48ADF3FDE23259BF084EE1F61C68EB1D6262D1BBDE88A17309F484F36D1555E8775
2BEEC624FC7C76C2874028028B1533D076D0429310B797E7F3D7F668BCBEA69DB65F6FEA954539AF41579B8D53ECFB4CC8F94F82E509A5F89C1646CD8FF4B5CC9E290A301EC6213B193E56C350A9E46E4337890BE7C950F194AF64E8CCD03829A0ABBCE1
C342ECEA7C8F93E81FA2ADB98FD73896BDC46A660B8AE86A087E85DB13CB3C302A8D9C887D9A6FD6F3CABB38194437704CC56096937676AD4CA72170B4497609C13CF86F023C6182D83EDE85789C35DBB0DBAD5C03A9E8AE11B84A12EC5CD47863755692
E79A895E08B96BF15C1424F27D2038535DD2530C9F3AEEF37F26AB276AC8645753EC9BDBBFD7ABFD2ADE36DD8618860CBA8E58FB2A586937116733E1D650C45DCE37CC0D302F84AB403A1D918C78EFF68B53CE3EDC8F6632CCC8A4C443A6020DDD8DF24C
73D9E374505C03581AE701FFF9F90B17D45AB7EE74F31623EA4603DFCC68439D8BC957689A366F518E31F2884CC62F3306A0D8DA8E361848B5856E65A42F0555820B6DF12F5219F087531E8974CD03CC98328B41DBD4A445D47207BBEED6172B6A006354
2B75792294250291E37AA80C4762DCE586A738AA57ACBACA9A65FB01CD28A2A901EC7087364A6E648BA8EE8C67542591B974F988A5768172D9771C572FDB9635670BD8E31A9BEE0652840EAFFF0ACCD9668A7ED1CB6CE87229EBE4AACFCDBFEA613DA68A
939AE042F8ADF3765C78DBE8586A5335F48C227F762ABC45EDE99F6D7198C12A045889F866CC21FA7DE001477D8C2BED878FCF6AC2E15ABBAB79CF95A8C54A6D570E6400FF847EAB9CF8CF6AD2797614F6BADDB99F5B64D8955D71ED92DAA93D49916F80
C3280F04C780063BAB468DB1B0A0228B38307087984EDB81DB57969210DABE7FEA07687869C47FD7F45ECB34BDE47CB061EDA350FC11B96631FCA673BA01DA4FA31A177F444065E8828E17ABB97EA473C72C7D69BD115D7C1DCA0A75F3C5169D0A45F0D8
4E401212E8B7EF0B6DE6321FED0CAFC1FBC1EB90852761CF8418718435339CB25B8B73AD605E3738932DA3223990C5ED5D811D84E67327865BE2A4594378A44A51CC40BED4F49554A42BAA5B6587D988A6C45ED9F85683F6ECF4EE449C4200139E09FB7D
116984391F058C9E9BB50273C31C2151D90129D4683C8A7DE8EB1F18C90BAB6E282117332288D25FF05564B9A425D4F87DF1E0283FA29218B8DE584E5E8F71596FA7E0031CDE4776DDC1FDC00E54FFA46B64D2EAEC924BC2E03B7FE02A5DABFB9591D4AF
B9BF08192FCFE00FAEE68345CC0FEE8054B968074EB84A2611F1A76F7BB68E80389D2167645306CCD0EDAFE54B264C27C67CD2A4AD38887C082023B2E579E72D9EEF215DFE8E65410C0EE028EA8DB26E05F7FD467D1ADDFE2FB41B7351910B4D7EA497A8
21CA4E30C96A35A108225B15EC8929DD67683D3FE0F0018ADCB746E16CC4749E2A36BD42DF3A4E5D37FECA5C7FA26BC475E386137BBD0765049454B8D38E10897DCBF0DCDA2278CC124886B80E0FAF742D4178A6C556B21441B38E9576372C497FF09A5E
E23643319017188443B203AB4A5290BA1CDBB2C8A47F3ECACABE6A2417C441D50E3E1284EE4457FD1D3CEC0CC668EB392BE006A28B33EAAF89EFF3238CD2887E51399DE302833DACB59568C9B69CB6751910054501CB2275BC78933E8F6913A377521D70
76A1F7FECA498E53C40AAE871FA4653F59E7FFD2072793EDFA2BB30B08C4D3C73F0C7BEC74FE76563A648D437751E1C8C0F7BE2B3CEC32D3E8FB9406ECDED0EABA140063D565DCC3D7D37CD570994BC72F1A5349D4DAB591F1C78330BD74C2C2069699A4
2FD4CE18FF36D1F0F73F417D9F295DD29411FFD228C6AA737000FEBB8E68CA3620B6F8F2F6B3B6A646AF4E1945090A676A3DE3F033646463E2CE9A32ED3B5A3A6832F146A234BC8CE2F67FD8708D3B966854B9570A5447E2E70DF944CEBF56F89640C4B2
181993483A80AB5C269A7F4967BCCCE3A6C1F529884FC9D3D0B70757689CE3C3BBC93C53BAEC0C0A99E8EE599ECFB627AC703A2A6906EAC2E59DCD0A0AAD7463A4DFB95CC4A0D216F4F04A34058F203F9A0708E12B8044D79DA3770B85392535EA1E56C6
B8C7DC30D16E0707460C0B94DFAB16169C10631E6BF6CA30F0A35C44A78ED8A0EE41A1393E189E4013C99ED477AE598B5177CA5EAB5D7A34A40C18572027C277E60301D12BAD1F7B01DD9C581DCC8A4CCE3A2C0DA832BE70E554AC890FE7EE134EB890FE
2A43D3768400EC6280479B74CD6F7F171E860ED798C6FB4900785BC22778DA0D7441587BDEF5B64425197AE1015340A22256E307EC5B6CF3AE9F4F57E75378D187A492612C12F54D689EC7297F54D918CFE563A818E6DE55225CC97F3934E95AC04A213D
23DE8E75CD6D0E7A3F791A130C793337A020020ED00EFFFAEFA841F9BBA8783CA1284718C3F86AF234D5A4BDD45BEF148895CC852928DBC4730E52D8BA1FB68BB54DE7A2332324883714D43FFCB81816E2FA94501544B27E38B87B9B080396AAA2F8B4D0
633629B18CD5B98C51E7DA6B4894F0D74E887E5EAE1254A55CDA5237D6450BB619DB14484AE10D18F5C64DF75E0B057F4813B8BDE88E6FAE50A9F2C35E4EB9ADFE77F8308AF2AB0E7E53034AD21599120345EBF31293D247903E86E39FEF9BBCC5D50470
E70305D5E66A8FD708C5EC886F78BD715CB84BAD652569CA29CE46F7A6529C88DA5E58EE99AB0D1F4A6C6355A560EBD7AEF4F0C14728A99A012EBB93019A0AC26A4DA18543519A054AAD11B7B04D4070E1D5E5E2D61D1B6F6D25726808922E2AA8F34F7B
8B99C2BB2317C9AD9C66A5FEAC3B8D19C1B5ECC92609D822739254DF9B438DCD41E426076CAC5A48AB1975527B22DA7AD21CA10AD4863E9A5BD51E57DC486F0451F5C2020CB5BFB5148379744E8C030596DD0D59CFC7BCABB716F76E6D8BD47E35E028CC
BE3858838B7347D59ECB6CABDC752D9B3CE8A34B86E970E583C637C4274F9CC1C33E2CF48B37A274C85E7C93E2185BCF30476AEA6E9BF446D44FAFF1BF9CA8ED5EB26CC0976CAD43C55C5212BD22DEDB23DFDD68F104404988B5B9917A7900F9354B7C79
9199BA218BB6250555C5E7CEF6546CEE12AF978D64D610CAD5F12B116EB9383111EE4975B6C34DB75353D250AB4706E246C10A3AE388D9E9D3323886F0E8AD36DBE792F2743F5B43733BF35616BCCE413210BBE66C16D0C89CEC69887CFDC430C5F9B769
618EEC2C91B18745FD2CCD86A9732950825E23B4031993CCA97ADEE438C20D79084BD2404AE0F1CAB77D0032C2D42C0CAE8556F951DB44DD6654F05FA25D23E6B3B2AC2EBD06F3790343E6971AF3D5500320CA60E3E83032BB58F3634E75044ED0BE0620
54677A88E571F25BB5BCF3575A606BE1A4F04ACD91EB33CEBBA2355DFE65C90C57201318C19918389C926CC2A0BD0A4EB35B8EFF153E84E59D1E29A1771564FA870A3D0035A92851F3889F758CA35758628BA99B9CFDE213FA43558237A13876A1063B0B
61CC3A2A49D0677936E7219C74B02590A5313AB73FCA357F8FDD99876D1DD28BF39686375DCE93B16246C2130739CD14E122B7CA9865E278FD390AE7CB33C54008EE23FAEB71599462FE1238DC0D508D259B6BC7A582D8F789EF04A3F1B75851115D7AB6
22060285F54EC81BED700E5EB5F8783D75B9D6836F8C16B062EF4AF9CF163F499E0CE12E4F57E72773FF30CCCD42368342C0C64F6D8C1D88FC350A5948E709A249E61C722EA203115AB7AE3FF3596DC12495443D58A804A42B3C1FA7D884CEB804522678
188B1B44CD1B788393C6A2D4C0C48EF3F56842D0772CE9F494985263D0F26F8B644EB50A68070913787E99FCF2B8B2FBBBBDCE7EE9312CEC4CE1C75D88621C3D617F2F0402E37BA416660169A70261A2C49046CC7B3EE640417DA05E7F6D85AF5FDF611D
A5D5DF9C18A21CBDE8B8EB3C78EFC28603E881A3E64D88D16C60F390E5D110ECF70618D691F81C0DFAD8EE4FA053560DFC6E5D36E95ADC31473A2BB6D02E91C19E047BD3A214C84158CDE750860CE3CE66327448FBA7F35524D432B62EBEC9982C491D83
B0AA1C0768F7E3FE80044FEA26CC0C15B5403CDC28BF6BB23AF395BA0D93217DF9D8074E1CF3B0EA9989E317694EAC519E832311D3E272A23DBFE4C2151F886C2EA93B5A219309E7A4D484F1556B1B8296904BA054D6DFCD030150585758B4F5FF166D4F
A4892696B4DABBE1795DCDB74A66B21CB750B27A69A93DB3AC5CD10D4294FCDF73D0FA11D3F37F12E385DEBA6F59871183ABE3E8AA772BEDC41FB10E7DF76E6637D64B6692E71570E46A68079F740654A5BD251EFCC1BB01B9C98579244E3FDB87CC4B8E
F2D4D9E4F1F552A465F48C5EED44872339C6D74E2A06C4AF9201B18BA99EE22AC199EEFB55D4D8613F7EB549FE0EBDF16A55671CFF8DB8880FE20AEA9F425EFAC56FC54329377F4E49871661AB104310924C0FDE0128E7C11A54057B2112BFEDB3E9D803
4A0E1CF37550D8769BEA74233F188FFCB0113FCAE1A3813E372A5E9792FE5E5B8B9E24E1A3F545D81C5B2D7D5D217F26A09579B9A72729348B60569B4C271A74771FF5AEA9DCCB4339ED313E29F022F9AA880679AC369D5B5E089F824308FB412D716C2F
EF12612EED5853BEA7A0B34D47A1E913E5B34B8CBA399A8513D8E92EFB99FDD13E3D3CD554D9CB0FD3171E353883989ACF26FE10F066B429B7AE4C5FB507D1FEB55AFDB53EEC15E97BEF7BAA89D740608D1C4E001473EA15D575769976BC1714F42D7CEF
C98973D24764820C7EE3FADA404475AD5C751E1493D54C9059E3732F09FD0C69FDF8F68B50F5E33A01A5C0E07B2F27BB67BFE0257CD07EBD2CF9645F78DE76F721C10A24F7A734D16AC52E38C9D623D58FBB41F787EB2B466DC808910706164FE93A20C8
C510A5ED06F4FAD537D15822808ECF26571D374830C3DA0E3E670445F50845DF493892D411002B5793CE43B41FC31BEA865F466726F49F13E37184C2198411E544AF75E8E4C95C1D88465ABB5C0A3B4657053AED22F194D8C4F61B61FA9A31A8877F0FF5
5183AB9E478C58B5BB71631D8111E1CDA4C913B04B62B9CE65082FD7D51E1F2E7988983564F7D883CACB9E8BEF862D65FCFF0B063896115F3A3FB3BA7B244265D32EF47F86633B257A59000AFC10F4F23D462418880C3894C1A912545EF853E47CCE0C5F
29AFD8084B1FE53D6B5D8AB521BF31D4998FE75F7638D4A1FF6EB83A744948685D8AA153933D7E88C44E7D52C4CF2BC7E9634777FBFAF375677515ECCCFB1258D7083B90D3DEBAD7B16AEB342713068C7A0A36C73BC46D2B83A16A085F253EC2D9230089
8DFA7E2C79EB89D6913565B24CC85D8F5CF6DF9687F7AB942FFD137FF12366AFB8DAEB04165E885BC4AF6D3948FA615DCDE8250DB7639F2C9635F394003F3DD180F85C0FEAE0EBB6955EF58BC4CFDE8C92EC101556396B8B3ADA7771A25B4B88C4A9FB37
10953AC1041049EF15C0121A2F8490DFDB5FF56A602C6404EB782186BDEC724A0F909EA248F5DB60693CF7B2EC66D758984A2B1B0AAB1DD156FA6A9C291CBE31E1A533E39E8194A9357E61E95008019415C1F6265B74B8EC49E5D47FAB05D13607F15FD1
E9197CFB87B240281BCC527B40149D4E9019D0E782E805C94195BE28CE0B2BA0E22F2FD5F2C8698A706544095DA76DF199F1F3BF488ACB20D3F2A1B8E84FA5E2F236DFEA50E0853F847E895089CE1306996CF0323471F23DBA191CDCEE1B97B682E60FF0
DC0E435E0BBDACFDBBC40DF51E53CBDCADF2BD647973B58137AA11D8AAAEADF5E815ECEC30870D92C5F03C7ACCA8CD60FD3301CE7C15422C419DCF86984B1B06A3839904E94359D360FC78A4C3A9B1DB1DC7296AC3EE49BBB2E8A0F8E758C790F2EF1910
702EEB9E09B1E44E7786F50CB56676536036D51EF1AD4C4EE409E763CC31D55B27C902CB1E02F4F6323C34EA456D8F743DBB0CB6F11A4E0BE5B9E39EF6C933E058562B1CED24969F66B795013C8AC5166344C1C4C7BABD2BE53F5B68445B9081DE749617
4D2539968B02F6A30C0EB191C118C8ADA23D2688E9D6F9204A3B649A016D710614C4B7D896CAA321048FC4B0CC69B42FD0AE3A689721F13F77DF964B6DABB12C51149985537598C0AAA47621A2A2A052B4E62A809F6576D4BF9A00001A46858A6D130A08
C505853563BCF3391D5E032CEFE51D0F34356044C6F562B6BFE402E1A7A6EA63B21E08C58129544CB97C02F84E8E65D24DE48D66CBDEAEDDFB92A387A0636F6088E7D2F6D0530B92375DE447C72E3B909ECA739158AD748FC1ECF1EA892484EB2D6519F9
6CF12AE7468AFC252C0A4269AE54BE7A41A8092AA6F825B892445F46A9A00E446E9FDB13BA392B4D18DEEE46E9AC65FAC10D5041ABFD33007064EE669B71DE6F5ADFE02AFC24D0F684746901C805ABC97CC8E8FCED401EA67C3B04FA99EA5242BA0660EB
BF4A3D29C2DAD2F6E9E79BB6EA469B8A13AF026CF8D1248C753B08C73DF3622E917C82FC7F901323BB4BB6F6EC604184E3D148693F8E5E445922284E957C974D7D89924F50385ECFF259A7F2A16322829EFAAA904C07B916DF770CB766C341CA48160A68
573D95010861FD73D80077E127B9F0A1FFA9C84B31DC0ABF00C86333B69C8045D6D545575176C8A43D96D9773288E40982FF2E45CA24389BB8B9B99C147B8E2D400A0BEE056A1F4AD48E76E3BB6523089BB102D7A7A9437BA023E6035B1D4E4E80230F8E
5D7D2CB9FF800B41532CA76E3CE80435EFE3B5CDB6744515FF220163E6FF90742C470DF5AFC87FE36386CF487632CF7839421C7D155916DB698F1C8454C84A961437F26EF9443CF03BD97C682AEB6AC47F53B339EB96480C8AA9DA8C96C61CA30BD55907
065459849BD1A639890B7D15401E275878F3B105EE5FB81313E0E23D12A208789443C25DCFAC39D2E60A2218A07756F8B5649F33CC9C3C1D96F6AC4A788509BC09E7246FE8C8CD0B38918C30B6D77FF26FF3494377CE40EA433B2200A0E518EE11FDFCA4
927A4C30B47ECC359B23708AE2FCF7B48F7624E89421FFC6FF80506ACE93C31FBBCAB4066CE115D8D1F59692EEE792A1FAE45084155365F69BF2303AA9B30ACAA9EB0066FA78FDDA1CCF82A7658D75E02DFFED8AC55E92FC8D99F60AF9894DDFC76C169C
94BF189CDA52B7F272AEA225378938574D4E2F84B067F59D50BA6A75D7A9DB1B6963CD2F52433E960D2A31EE6DD62B6F7B205013B5C26E0DED84E3DD93CE2FABBED82324FAEDCFE9B8D9631539505BAA495BF8A30BF6A74780AE464378809181D138F222
10213E54326CDF521BC3B22A6F048A919A3AC1341E2D0FE3D7FD5344E9DABBCC4EB0EA28E89C92B291765D4CAF7D786C80E93DF3C38DC343E28A90B110D8604EACB4B54C21B04D7696EE308ABD6FF152DBDC08C8C8FDD7885B5F7F8721B921A8E500A24E
2607180B40B9F54B648E63233F54FD0E2ED205A6B2892C91D19C867A899D7C2CC51501F19692ACC10F9901EAE88DA0EB91F615973B06CDB12D1BE62C6F7AC40C6D13F3F928424AD83A85FC0D30EFA9EE8042C916126B6CAC419F4131B2E59A8088AA20CE
7143091F37B56AA2C5AE1D648AD72F43C2D5C195563725BA3388E4BEB753CA3B0EE8841FFC8FEF03D1F16B14C3847722188CE4CC849A4EAD9CB4327C2DDEFDB0E7FE3D50A3E4E548AE5BC3E0D3978B7ABDF8D870D501B23761DAC06D9930393C73DA8B0A
D885EE472C62DD4DA355709176FCDAB0EDA70D5D44897238DBC1F0944FC84D6713979F9F4ECF9BEE36B91F50EEC639BA5B030594A2316C25E01273E2B7C0633B40BDD0A215ED06F124D39EE99AC9DD8BDEBACCBE11F08980AB0AA54A52332804186BFC17
75E6DC7CE1D5725EBA2E21DB0D467B41491189AD36E82480EEE730985F5C5F0C7A403ABE0488B40B01730834D00F5659283D00FB265B11429DC7B0C9D39CD98448282C55F98D1FE29E45C0789E0BA418539908244CCFDEB5B95BD691BB626C040538BEDC
0C9872E72EF416F5A70E06785924B7CD09AEFFAA4498339CD68975EC254D284C2F1A8840F64ED649AABB7FCBDE66A5A84001832A51D70933320D51E8F2ACA9F6D9D6CC8C2997C70FA88C1D48B02439C6879A1EA79B8A8A84F1578D0E2E5F1D6B721329F5
6AB1A32D760B7C34C3E6512327D757640FFA723E03D341610C4FB1E07D5B15D72F01478F01227383ABA6208D4FA8BDC859E0B4210B7D912336E0635C529EBEDB0B116B1F2F0AFC1170841A5DB0DFCC766C0FAFBF970AD4DED9C3FEBCB9525951F0BD8253
653118DB24F012597973183451148E58E1E52666FBFCF3B22D6E6B842D1691BD81E24BCC9E4C1B38CE249E6E3DD3B897306AF1436DD01E5CE86206CF3E7BE8DDE50E8CC4CE4E048E3B6D28B3B9B658984F07CD8DF2E1D2CB66C6CCE0A69006ECF225FFAE
E3EDE9D5C252687A561F76D9EF3A2592A8A0C30723AB70B5F97EC0375EDFEC9DD904BB9079980C419F17A350A708BAE116994A7CF87A7AE6E357889786C2BEC8A8212288272552BC9CCA990D41F09EF7062393EA4284A7A9A2676FAF09222927710491C3
4F7BF90D402EF895ABCFD73D3E1829F3B4D2DFE4892E15880A7A59CAEBBF5641A1005DF88D024A9D5AD64A8C6ADBD661A16F2D42F1194C128A14F16BED7F25A6B9967FE800569544FC4298A6D07B8C740B38A4102B6BCFA04A7395B3AC80CA33C5F3E359
C362F2AA103A266C8A0F3EFD908F068F68D36B75E970F333B5401D64062C9343A639A4C8A8CD76689FF963331C9262C5C97BFEC85FA66BBD5DB2DFD72FF14F1F31B0C4EC0B8BA1560F5577024FD61A5A80D556D750199E9CF938ECDCE02FBC9BF3961214
D12E8EAC24D3C3C03A62786DB20C63C64E3297422EC5862F6455C33F349979BDF9CCA960537428B2626B17CAE7A27B2DD84B08C2E79B7404AC6ECD38183B3A6E415D4F6BFA53E82ED94E676D020BD0A16A194A8F58A74B1AE89BE3733BD49DADFB4B60F9
5787549B702411526F51BF6E0D22E243D862B35870159D00DC75A5E14D94DCC218E00FC65E37E86A5D6C07799C3CB2854BB57F9A3E462E96CED1E7974F2AB1991B56046711C99ACFD08BDD71A62C7A157DD993576DC24AAC1AF7EC2CA609467F9763A2B1
7DB67427EAE1857C9D00A953F250A34C31E4057D23BDEB665EFB1486619B28C056380BB8D6576EFBC97D7A76611140D0F317FF115BB016C439E6E537C2BE2994CFF65B59389E8317D4B9D11F8F93B59E3B5971C7F5B7C8FD25670C3F49E1F70CFB8A38A2
35CD3A470ABD10561231407AA21D51471AD227B7EAF28E32C4402BEC0F55D805C2A4984B54C02D06D29CEB6AC5497EEDA95F50E81D3C094FA0606C0E85FAF75CC7C235253875851D123E7E3D8167BA3D10FD33A683026ADD097A82C1593A684FDE40CDC1
AF93A59AA3ACD8102F6360E6FF2EC6915669FDF336E3927687D89A80CAEC3C97258D1F89A6934404B183F693100FAF62F432A17581E0778B5A3385B4EB7C9A3BA29D070E3329CDCA3D079145039B1B589FC9D3027B8D6C3C64F7947E293EE4FB7DBBAE6C
3F6F6AEBBCD25F6A5017E0F361BA9D48D88DBD3B6A226F15FDE403D4B1CB7239DB96FDA8AB37FC87234033C66BC21AD94A3F8961BF3F9BAA6A11966E03E764168A6CB689DAD30557F0EB05082E1A8635D2A8808F98289691BE538AC979392699EE289E05
F8349FBF25301DF706272AB13FD7B4D45324FC17C4E9E2440E5340EA60BB0FF763E578A4973B5D55E3D249905369329FACEDDCD887C00FE292902BB7C6255D06934E1EF0C6E22228BC23F309C9D4E6F6B390A6E8C51D500E8C1396D7B45AFBEC619DBE77
DEA8C33570F908CEACC800B6DC109C4ACA0803E6514B50EE18638E3EF9029886A0B5789074518DED123FB5378CD03BDFA60D323339F07CC5B9118DA7C388269FC37F3551B0A1FFC228AD074ED95C18B58BEF3E2D09EFA805A4AC17C0A19CB1F4835DC93B
678DD80200B55DFA882BE1CE276B0ED1541810C6D37E0DF371399973540F5FE90E89169A8A071CDDD5B1C86F94A3B1F77D497C9C77516100357D0814F1990097D2BA68BD5BFBB98397F5ED2A4D1E5605EFDE22D47E79916D52C8B3B7A5DE4A33137E796F
889ADA6546E140F733E140F9FF951C165D14894DC87980235436DA8553B479AFEA0F5C1BB997D1CADD1E594133A5348BA6A799FE6642013E14CA56120B439DDF58062D46FA36132D9A8863308BE10ECE52DFD65927E31044748E388D6AA6FF317F233124
94BC45D15A6C5503F427205F8174BC04ADB01B6F41C241BB692E94112E9F9D540CDD3C8D1232025F77A8E193C4BB968625E26AA81302C7D5261F9C026CECC68135E64BEFC1BE875B5F763CB1B72C8174DCE7AEEA2C666D71AF160015E34CDADEC7A585CB
B273253D5DDEA582BC37166A101F50E4BABED1565A0780BBEC32ED0344115D781632AB0D64C910C6BEB1BE06DB48C59DE6867058C8A61DCCDBB498191DFD9A374813A4BBFD8E88A192BE0F8C25FAFD28C8E3DFD1D50C896F3AB5451E00801C66A2193ABF
B0AF873C16840188C959609743DDC1E708C3747DBFACF8A11F07BC53CCEC7E65551A61AB29BD15E2A28D4CAD1B97FF1BAF2CC7EC357D71709F4228DEE9C8F42F00130123F20F935C7227F96BE5A63E9808B49257CC97694F10447AA3CF913B7E5507959C
5196B5E380E2E6756860B91F4FE78B993DFD2B9408E39D843FA0DF80BD1EA0A3049E958551DDECF9689547BB787E82732C8E3F5E8BC809BECC80CEFA0DBE6E56A3A1A3A76F53B8D584262F5D69598C18F9E5503356BA6EB752E56AF5595A7CED8BD72D28
ACEF7B51557A264CF336174007CD6C998F4F605FBA7DDCBF427BCFB52F05E5D4A6A016B148CE519E2E6DF812F5F9D0EA3BD58F65CD84BCF830D5FB8D375512A9AED62612396AC194641049B0AFE588D2BD41DFAAE5632790B151039C680719D9663A1DDE
05B9F3C8227CA9EA8886FADAFF89FF728CEB48D66A08D52A142BEEA2B8F34A70EC2DB5A6795E746AA236A8E5F1D1B6132303380BAF44A98DB42B2AFE50A649F7C8A40BA83A30775F2CE0B31D1050B10C5C73E1FBEABAB69AAA85CC1BD9AE1F9B1DD5C19E
8B4D3F27549B9FF0EAC1F48E6A22836BFBC64CA0F1D5C8838B2841D72D84A3559D73749CD4AFAF02B9BF5352BE71DC9C3BBCE617489404B71D5A7072D485DF61149CF6D2CA442DD8CF6728DABA8BE8EE61BF5DBE10D33C513B0660247FB5534007E4E452
9661BDB8BDEC4CEC9221BC63CE5FC02F90ADC72BD5E5BD7AE76F7A5B75B8A57C9297EFB37B1752A35969AF11843F4F8BF1EA8ED1B26D68F1044FC5BF631BA301AF32603D186C210C2D1BD4FA69C9D69370D27C5EE3B00A4597177592033FA0B3173050AC
D699ADED8E7E090DAA40D9D43ADBAD8E65B7EFE2C81F4F45F802DFB40EAD640270838209BCBBB3D656E1283A9748CDF6A00862D9F60016BF5A5586E129A8B5E9EA7345AE4C9F69714B759040FE2F9E0BEEB2D27BB1EED8A47043CFD446CDF5EC9EE51D17
5DCFEA824C3881204A40EFCBA136630F53C92BE25D5BCB57BC8B37520CD4D9B2A208F3DA4F5E8D9ECDE8915994A2F4DAD147F799FCCB2F7CD989455CFDFAD950332579617E16EEBE7196F2E9CDE13A6A685CD393F782EAC31B3D0818C56EAA0BB9802463
0F632A96C8C2D7C95FB18F3F101AA96E9146C53E70C0BBAFAF1DC47BC52B1541A4A467DC931D41FA03EAB7D545863333EE09BE08D57E4918410DA1FE18ADA243AC8451EF62B26179E1F184F110C27FF0B8C52BA403C75EDCE986AE210283BFA410905C90
E3F68D92DA44C26447C7DB42D3C4547A5D2605E6A9757CA0CF31CFA081D4B19F130AF8CC68601619BBFCCE91472F686ED23117AC4A0E422FA10519400ACF169680D8D2E4FAD577D8B4D5D671635EF330B9BAA24ABBA1D1F40743AFAA3B9FB48BBF2D283B
F020AC78BA92D2B31BB72B790715E76701619527F4EB033530B5B3F95A196C5AE1D246863F936539B960F131094430B4AFF00314147EF57126B9BCB3C3EB453DBA65E86287BA9B955646707A73A8393C8FC3E9AF886C5CE8268F5FD710BE87E19C9C3FE4
DC34FBDA738A12E8DDEF304E438463D5C097DEB1742F3C7E36D32E18BD81DD43DD62B4ACAED4BCA6FB9B0AE5309F94886D44B0C68FD1582CB76146A1A0FF0780225C41F85F31A02454F46E40FC4FA7F1E8FA65814B12C521FD21B7B82CF7B72AFB1A493B
6391056142360F89ACB6BB372A124B5526B6A98A0F9FBAC0DC0C1003EE7F0B6CEDA4A443B13B1E8DE12729F58C4F292BCB5959AD98772154823F607B8989B77F6D17EF6D0ABAAEC0CDBB74A1DB63ED24D0A8F391C4A3DF18E59F8274879F2C789371A87C
BE9F189F8E15A2651DDB8E071CFCA5CA0BB69DEA5B3D519A0AC8E6129FD913A29B183E7835C385822238ACA2AA9F2E3CD37E7996216841B1E3F429191BE92A766CEC838F24B098CB823B33BC196D1C40F0BA08C3E5BD10990B0635BB66530B4F4773AC39
1CA8B3727F7A338A0B7FF104A07D247A2AEB7277AFCFA3DFC487AB4C4273DA566A278D7B15D439D34C0859486052525D85B5134AB8F85FBB3683B4031C6839E44A484B52CF3E0EF0DF5EAD0A4A4F3B188A6A2D0469B11A86DD29B4EFCA40729C78A4D654
A7BABAFB2E21E4847D9595B9ECD049CF599B96741AF7831423EA8A4B933495037ECBF4C216F32322D0EA18CF8B17F132AEBA4B262B4475F7D5C66EA750857A7598D7E4846218BA792F46CE5D0439EB00E2CEFBF2DD4D55B7A22440405747A2D80B6D4AB9
B56AA0260214D477EF4CF2F31471A615F54495C2DA0302976BB0BB5B81EAFC6727ED5E605ACFF6F3F6DDD43C37B74CB0FAD1B81CB89FC20C782ADB0A51D32C6B6500FC7E7A2B4740F2241E5C1BA128ECF27F3C763388E3F4703532E375E4BC543CBBF830
9646128D3FB09240DA83D4262986902A4B570B80E3551F3B84E489F5F3C8197DF298D8D4E01F0E079BB07E671466EA3F19479424AE4BBB64A0B97CA3FBE1161B664A8DF704227A083F74D828F22DFECB888C5EA51083B0149232D7D300218B6494D42E35
ACB39C9CB44746B8F66C7E3E99B475A8E0EA1423865F0FE09FC85FF98B1DFB79EB9DEA335F03AEF8C43A370E7EF3570FF00C50CE492A53011FE4BA9796C70D66FE940B6CD83E1F800B62B8A13642BD4941AB8CA3F83B02284B6B77A4A3AD66417F03FCDA
80E6A8C83C527D2F2F92AEFAECF1D49F6350555B0E6A53663018DB986D97BAF52FC08C2F06DAAA325A7126553D1837EDBB34329721F254254D9E4C41CFA89F8DC4C9CC4B808DCA572CAA07F745F732C3370C00BECC3DF2BF3C7BB2D8A1EBE36D685A009C
5FD5232F4C7F7DAB66674F64B44F877BCE26755228FF36B358E48E1E317256C179D9FEBF3F2D5181C70CD1A4E087B63D801654D35CADA2680D94DB3A586756F681FF2C541EE9311809B0626913389164C05E4CEBE441D988A0FC827F28EC205420B2E026
467C50BE68DEE9E0CB11136598F34EA0AB5B7497B702E867EBE5D936B123CC847F4F38D60DF0EAC7978A8515523B39232E1AC8E523E2D1267718DF4A8A04FEB4B7B55591B4EC09B35639F607C98005A84901E893CE41E805BDE6704EA083CF2DA3DED60F
805D91699B01369B6435745F7F9DBEF0895BA10853E6C737E67E0E62248CEC362B7F4553734F8E1E14E7E310CF9022F6076D6536958D727FAF0B918A12B68E7632692BAB12C2C43C80E1C20EE3D930BC430C7C9865B76A4F093EB4A6D949591FFDC93E7F
CD4494B25D72DB2A5E047DDFD8289ED28B95E5AA1C9A26521ECD4F994D568478140A65666D29DBD25679B11EE5BF9022F3F977F6B4720BBF9B20A36DF4DD879DD383563DD27535599AF4A5E57D7CA9152A1352088CF3F52EF16D8EF0A8658A3D75622526
8EF97AC681D359617BBF769B1FC86F1469E4C2AEEBB9AD1BBAE224D4F286C9204D079846A9C500CD415FB475DA3140D09A034AF120B8B5A9BA726793440A506E408EC73CD75CAF0CCBED94A45E4877F2AAF771B09D08FD2A194E78197020CE0DFC95D93D
F9C6B2AEFA91EC551DF4C622F876EE2D49856C2598D98CEDC983014B0E8DB1BF2C84ECA2AC2EE6253E6FA5FD6437DA292656794BC5523887B8A6554C5311213DB77128C5050FE0A452DA70712B0DB5DC9035672819473A08977BD8368870F1C01AB480B9
A726EE37FFE6FBB10E5F74C5E03C247F2F264DF0911CEF6EA50059CC8A7C4B9AE5958C822C341ADDDEA8C4A87E680F8E3F1278A38D574BCFBD627CD0B156A0F26118439D11675C7E054ED90A023A1B40AA4F12E565D87E9C033FC1F9F155E854B38A8416
17E2C9F9DD42590FEF10151F5447C7AD10E9E2735B7E5DDC3DCC676296B0CC3D430D644871BD527BC66926A59632447A7BF2C96DD863513A4F58B63703DA269696756AFCFD04990C977D68A78215591F06D5EEEFD21D39BB52AEDD45DE8E1825E7B95F14
3E537431B9CE2F8B8AD6AF377C5FF33160E0A9D1C2B5B1D33D99F93725C70512B694C8445D72546F3A8D4961DA6A448D6321392A3089A77FCA0820DE17475904124F31F6A69AE0F7FDBEFF02EF1A44AA52AC3D6849F6671075E4472A0609D50043E21FC1
E8A253794147751523F7D717CBF6FBE414E4B9DD3557CD4B4AE80E623BCF11D8C965F9996249D6A02CF8705DAFEB009615464C3CD9C433EF987059259A1650DE889C92B29A9934C4868BBFAF666615C43C783E4DD5763C3F9185084E29E349E28AC2D106
4369908B222AE35801888F9B8742F3B6822D3FB31830273DBAC86674EDDAA0F65EFD08BDE3B1C81B943BED56A903188AC777630ABDC9B05D6D189197D01CEBAFA6E6DC7F7063E3D3A4B26478412475B76DCD0758334A9950A162ED5DDBC62CF4800802A2
E791647B02AC6A878AD820C7683ABF7702ECD20D560D69AC3BE3C9BF68D8FEE055C8D999826016F475CC7C469F77B613D0679100591315E4EAD8811072B0D7BC847A47606945B681A27E37421DF870F98D6516EEE7521B959B2A08D00DC6FD33D6E5E3C8
F421F858A7D498F3C6C82BC1140EBF6B9EBA6406FC6BCECFB472B7793DA22B7270D0B84F4DDE2D877699EAA7471960855B3CE995B4F8D595616D9787D1284B25969E187BE987F423D781C883A35CBEDCA1AB12633C1AD4FE61C1C2A36E1F53B53A2636F4
5BCDE3D3D45AF763D5D7C62BED57ADAD2453EEA54EE3337513A22E258907FF13090C2E2E7DDCA12CFB81A06F3E73BC469CED450C5C421AE12777E8E5FC63CE39FA605F23996724E20457D963303E310EB2C521F601406F3731DCD28F8BE490F302C253B8
75521F6DB554C0FFA732DD7CB4C5A5F5D6E998B4D62241BB8651D207B8E980510EAA7FFC448C331E9C2F7441E276483339424995C9C23065A72A360E4AF4720F45683536EAD22EE24696373F6504897B703CA2646FE9BD9B207704BD5786D71AC7AB1E5E
757489AEF285300785CE4E72D039D2AF71E658EB9601A08D1A8724A7AB67A32CA7F3873CBB07A34EE6E898A4776ECD92857E4F6E3DF0C759F46CAD33736F820E654065918ECB581E02F6685D6395E1288DA4EB1644B3ABE6B6D556614B409CA6030A8CEF
9D491257C07228980DF543F96D9B43E832EE9758F6DC62232BAC19B6A6E217341CF47841A7BD95426039F1F947B1C4BFF03EDAE47BDAF64D008698203DD59B2F639A5EAA3BF8F9EE0927CD5C35E1D3C239D5A0EB9135B88C86B72221BDC061DB5247F882
50F3A2D838323A32FF2EFBF6B7FDA13C3A820B0D9506B6CA240B2670E911B057AB0A5CD614328BBA97E00248141A8DAC73B95559E91F9AE497DE38904DA9B8EC41BBF4F1A90C24B3D36076123468BE8F7C774DE52DE4EF0F2111FEF28A342E6C4B26BF41
73F998F0C00B9E8735B6F56DB592496397089328B86235B485371E0852EB7B129217FA574D7CA38CAE060F64CC372B8A59E3D22C429BF23DC000F8012BB28D1C837AEF472AF6F7E7B81AA9809C78F13F91C6E20A1BB1A306156EB37FE1A1178B06172FC3
CF64190E92D1FFBE2F1E4B49F1AF29DEF00B313511FCF483DB13A88914072F87597180D4B5EBD2F26764F2D814CCF6E60C284F81A3344D4E3061EBB228E4E4C71004DF33CF13DFA423D20D2A5F1F5A398B315A9EB24E1B3C7E5C1B6DD4353F3FD939AEA5
E6842F291F99A90C9DAC239F6D5655DB3933B28D8B335AA88D7E2CDECF12623EB7A94DAF8EC177384CCEB7FF689749554B0243CA6BCDC97BFC603278F21C8A2188C98085D40216687E6E28803975ED8BBA88D2A2D4374EB60CC54E7C346A3CEB074B3A88
A260E5FFAD94B4B8F243B3CF342B814BB917E7EE4ACDA29B5199932A00E372B4E1F9456CDCFA6B575AA1455E5FAF314EE2341CA5EC17DE61372EA5C0188E20EB09218F90B6B2F677C831899692D5EF7771E6CF1292D499B71204CD923F70586708C6E8FE
A6E8AD8D43145B325833B31881CF500B3EABE00E46FC97833A6D59CD83EA2094711092C87B765EB00E3C82B94A790B4F719048F1CF887A30F61C237E19D42E525617821B86A635301212155C72416C3FEE08973E1672938E42493410854FA409AED0B12D
5F889648642CFD7D05053FC353D7E4A5206F9B79B6731DC0BC631B34E9E674CCE0AE41871B7BAF5A95A0720CB79B9889DA8A7CD50BF559408568377574BD6CB970B34283080CAF33439B83647F6804E49AC274A1505D80B845F84843853AC0B25D2F4421
B8FC4240D1D685CC8E501BAD0C8C5C695212054F9332A4A8B1CD9C20B01581263DF098C21E89DC00FB4D551B718B2672B47895E060B5536C1FAE1C2A50A31B2E36935549EB49B37E801D7BA2E80C07406B1FE84AC76729F7E8B3FDB58494D2100CF42D93
AD54216C3066E6D169116BDBD8B37B952622E05FBAD91372F291F9B9541E2102498B6C50CCF6468256D25F59C499412FAA0687317E6F21F746457DFE082752E8C679F0AE78A2BD1AF91AC67FBF72B2BCFEB7E76005399197E4092D2C2AD9C2895D2CD2CA
F32A13F7E7C7EA151F90BA275CF39AA821CE274E8853A67ADA855F12F3F2E740CBB58A05CB4E7A0B39BEB188D94C03A47B518202448D41B13762F087A0033FB193DB6516DA8700A4D3939BE6172475AAE4C49C8B97BDF5944DDB19D895D62014026B01D3
6D603829FA586A19ABC6AF345778DB9E3D39B5CB86FC87B427073338287F07C1B693B3D13C6F24E780AD1C91B4F305412B7ACE061C6C2B95086043432F0352E77499BD8D6FDC618E84E74B9BB4BE5EFF09D613ADED8F1A3D0FE68A4B9213A7C96BE6D721
DC75D5E55683708E230DE8388F11A53EF4B61912503D6222425966CDFB753FE1D355A5A96E09C58158078C292E6075684ADA75AFC2F893D5A8560001BEB026EBC7945A7C8B145DF3AA8CEF08C7C113D73055957F996D6849B6D8D918A3E689C406495326
E2B408C01583E629F3AD0916B9C137841E1DE455467AC55E368B123D364E5073C45C2E9D9755AC80503A8A3BC5CAD2E388CEE0100489AD1B0D2B7695DEBB98B4B0EF64133FB4C8367D3DA753D587877E98E94173BBA48BD1C1F186D7C017F69CBA0CC07D
F7EDF0287E413E5EA02C4410970D60B132C9381698F0117AE73571DEB7D630CA68A2C48D4F1FB0DA120319C90A2945D7C302309D2B3E9D9D4ECBF2436DA37DC0AF073ED69482BA58EA06D82B44B5D2C4FFCBC7F758EC332E30BC29BBF29A341703D76CD6
CC529E98B592397F71B92850F83F0AAEDB81AE1C93F0A09950913F5978F581DDE108F0551432A0AA20FF1E44D3B9F3EAA6521F36ED7003C57E8B568315F2B01676A7891CEBBA86C9A877866309A419DA26BABAAC8E59264AC2FF98041323CC763187F5DC
53B9DDC5A23222CB525F99565294E85304906A882D65F28D7A11253B63EDA727D57336C95D24E582F572789064F244CACDD974E3CB47E7B0F32A47675E83EDD5ECFC7105948CC67D7A2F706DE90030CD0367CE98A5D05F1BCEC294F4F9181F667A5470D9
66B6A0C31B5D3910BC41991CC263165D56E867CFF58FE6283DD567F3C499103A08E675C67EFBB05770F75CBF0EBA302DCE1D7C3D77ABF8D7D479760CD4251B8242C72A40FFE805BA0899F8F6919AD41D