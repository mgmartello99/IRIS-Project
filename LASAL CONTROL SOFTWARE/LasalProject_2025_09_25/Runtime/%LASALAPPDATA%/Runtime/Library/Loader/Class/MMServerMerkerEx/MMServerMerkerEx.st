//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "MMServerMerkerEx"
	Revision           = "0.0"
	GUID               = "{59B2DECB-99FD-4249-BBFF-008A5C4E52D7}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="m_udLength" WriteProtected="false">
		</Server>
		<Client Name="MMServer" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FimLuc"/>
		<Dokumentation Revision="0.0" Date="2015-10-07" Author="FimLuc" Company="Sigmatek" Description="erstellt"/>
	</RevDoku>
	<Network Name="MMServerMerkerEx">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{81A53572-7129-4EB5-9BD1-4E09EFD4364A}"
				Class      = "MerkerEx"
				Position   = "(240,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="m_udLength"/>
					<Client Name="ThreadSafe" Value="0"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.m_udLength" Destination="_base.m_udLength" Vertices="(712,210),(540,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using MerkerEx

MMServerMerkerEx : CLASS
: MerkerEx
  //Servers:
  //Clients:
	MMServer 	: CltChCmd_MMServerBase;
  //Variables:
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Use this function to change the size of the data buffer&#13;&#10;Diese Funktion kann die Größe des Datenpuffers ändern.&#13;&#10;" Name="SetSize"/>
	FUNCTION VIRTUAL GLOBAL SetSize
		VAR_INPUT
			udSize 	: UDINT;			//! <Variable Comment="needing this size of memory" Name="SetSize.udSize"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment=" Use this function to change a part of the data buffer.&#13;&#10; Call SetSize before, to make sure, the internal data buffer is&#13;&#10; sufficiently big.&#13;&#10;Mit dieser Funktion kann ein Teil des internen Datenpuffers&#13;&#10;beschrieben werden. Um sicherzustellen, daß ausreichend Speicher&#13;&#10;zur Verfügung steht, muß vorher ggf. SetSize() aufgerufen werden.&#13;&#10;" Name="SetDataAt"/>
	FUNCTION VIRTUAL GLOBAL SetDataAt
		VAR_INPUT
			pData 	: ^USINT;			//! <Variable Comment="pointer to a new block of memory" Name="SetDataAt.pData"/>
			udSize 	: UDINT;			//! <Variable Comment=" Anzahl der zu kopierenden Bytes" Name="SetDataAt.udSize"/>
			udAt 	: UDINT;			//! <Variable Comment=" start copy at this offset in the internal buffer" Name="SetDataAt.udAt"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment=" Call this function, to get back a certain part from&#13;&#10; the stored data&#13;&#10; Mit dieser Funktion kann ein bestimmter Teil des internen Daten-&#13;&#10;puffers zurückgelesen werden.&#13;&#10;" Name="GetDataAt"/>
	FUNCTION VIRTUAL GLOBAL GetDataAt
		VAR_INPUT
			pData 	: ^USINT;			//! <Variable Comment=" Zeiger auf einen ausreichend großen Ziel-Datenpuffer" Name="GetDataAt.pData"/>
			udSize 	: UDINT;
			udAt 	: UDINT;			//! <Variable Comment=" Start-Offset für den Kopiervorgang" Name="GetDataAt.udAt"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment=" Mit dieser Funktion kann der gesamte interne Datenpuffer des&#13;&#10; Objekts gesetzt werden. Die Funktion erwartet sich einen Zeiger auf&#13;&#10; einen Datenpuffer mit der Größe des internen Puffers. Exakt diese&#13;&#10; Datenmenge wird dann nämlich auf den internen Puffer umkopiert.&#13;&#10; this is the function that enables the user to&#13;&#10; set all the data of the data buffer. The function expects a&#13;&#10; pointer to a data buffer with at least the size&#13;&#10; of the internal data buffer, exactly the size of the internal&#13;&#10; buffer is copied from the source&#13;&#10;" Name="SetData"/>
	FUNCTION VIRTUAL GLOBAL SetData
		VAR_INPUT
			pData 	: ^USINT;
		END_VAR;
				//! <Function Comment="returns the size of the internal data buffer in bytes&#13;&#10;Liefert die Größe des internen Datenpuffers.&#13;&#10;" Name="GetSize"/>
	FUNCTION VIRTUAL GLOBAL GetSize
		VAR_OUTPUT
			udSize 	: UDINT;
		END_VAR;
				//! <Function Comment=" Call this function to get all the data back from&#13;&#10; the internal buffer.&#13;&#10;  Diese Funktion kopiert den Inhalt des internen Datenpuffers auf&#13;&#10; den bereitgestellten Puffer um.&#13;&#10;" Name="GetData"/>
	FUNCTION VIRTUAL GLOBAL GetData
		VAR_INPUT
			pData 	: ^USINT;
		END_VAR;
				//! <Function Comment="The function returns the pointer to the internal data buffer of the MerkerEx object. The&#13;&#10;results of this function may vary between different calls to this function due to calls&#13;&#10;to the SetSize function inbetween.&#13;&#10;Therefore it&apos;s not recommanded to access the internal data buffer by means of this&#13;&#10;function!&#13;&#10;Die Funktion liefert einen Zeiger auf den internen Datenpuffer des MerkerEx-&#13;&#10;Objekts zurück. Wenn zwischen einzelnen Aufrufen dieser Funktion die&#13;&#10;Funktion SetSize aufgerufen wird, dann kann sich dieser Zeiger verändern.&#13;&#10;Daher wird der Zugriff auf diesen Puffer nicht empfohlen!&#13;&#10;" Name="GetDataPtr"/>
	FUNCTION VIRTUAL GLOBAL GetDataPtr
		VAR_OUTPUT
			pData 	: ^USINT;			//! <Variable Comment="pointer to internal data buffer" Name="GetDataPtr.pData"/>
		END_VAR;
				//! <Function Comment="Use this function to assign a new block of memory to the&#13;&#10;MerkerEx - object. m_udLength has to be changed simultaniously.&#13;&#10;" Name="SetDataPtr"/>
	FUNCTION VIRTUAL GLOBAL SetDataPtr
		VAR_INPUT
			pData 	: ^void;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;To make memory allocation more efficient, one can set the value&#13;&#10;udGrowBy. Memory will the be allocated in pieces of udGrowBy-bytes,&#13;&#10;instead of allocating only the exactly needed number of bytes.&#13;&#10;In this way calls to the OS-memalloc function can be saved.&#13;&#10;" Name="SetGrowBy"/>
	FUNCTION VIRTUAL GLOBAL SetGrowBy
		VAR_INPUT
			udGrowBy 	: UDINT;			//! <Variable Comment="grow mem block in pieces of n bytes" Name="SetGrowBy.udGrowBy"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;function does the memory allocation&#13;&#10;" Name="Alloc"/>
	FUNCTION VIRTUAL GLOBAL Alloc
		VAR_INPUT
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pCode 	: ^void;			//! <Variable Comment="pointer to allocated block" Name="Alloc.pCode"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateToFile;
	
	FUNCTION VIRTUAL GLOBAL LockOn;
	
	FUNCTION VIRTUAL GLOBAL LockOff;
	
	FUNCTION VIRTUAL GLOBAL ObjectTraceMessage
		VAR_INPUT
			txt 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetCRC
		VAR_OUTPUT
			udCRC 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL m_udLength::GetState
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL m_udLength::Kill
		VAR_OUTPUT
			ret_code (EAX) 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL m_udLength::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL m_udLength::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL m_udLength::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd MMServerBase


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MMServerMerkerEx::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MMSERVERMERKEREX
0$UINT, 0$UINT, (SIZEOF(::MMServerMerkerEx))$UINT, 
0$UINT, 1$UINT, 0$UINT, 
TO_UDINT(2202808712), "MMServerMerkerEx", //Class
TO_UDINT(2225119864), "MerkerEx", 1$UINT, 20$UINT, //Baseclass
//Servers:
//Clients:
(::MMServerMerkerEx.MMServer.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3912347455), "MMServer", TO_UDINT(2479275025), "MMServerBase", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_MMServerMerkerEx 15

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MMServerMerkerEx] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MMServerMerkerEx::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= MerkerEx::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= MerkerEx::m_udLength.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, MerkerEx::m_udLength.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_MMServerMerkerEx;
	vmt.CmdTable.GetState		:= #m_udLength::GetState();
	vmt.CmdTable.Kill		:= #m_udLength::Kill();
	vmt.CmdTable.NewInstr		:= #m_udLength::NewInst();
	vmt.CmdTable.Read		:= #m_udLength::Read();
	vmt.CmdTable.Write		:= #m_udLength::Write();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #SetSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #SetDataAt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetDataAt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #SetData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #GetData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #GetDataPtr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #SetDataPtr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #SetGrowBy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #Alloc();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #UpdateToFile();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #LockOn();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #LockOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #ObjectTraceMessage();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetCRC();

#pragma warning (default : 74)
	MerkerEx::m_udLength.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF MerkerEx::m_udLength.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma warning(disable:73);
#pragma warning(disable:74);
FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::Alloc
	VAR_INPUT
		udSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pCode 	: ^void;
	END_VAR
  
  // wird nicht unterstützt
  pCode := NIL;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::GetData
	VAR_INPUT
		pData 	: ^USINT;
	END_VAR
  
  MMServer.GetDataAt(pData, GetSize(), 0);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::GetDataAt
	VAR_INPUT
		pData 	: ^USINT;
		udSize 	: UDINT;
		udAt 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
  MMServer.GetDataAt(pData, udSize, udAt);
  ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::GetDataPtr
	VAR_OUTPUT
		pData 	: ^USINT;
	END_VAR
  
  // wird nicht unterstützt
  pData := NIL;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::GetSize
	VAR_OUTPUT
		udSize 	: UDINT;
	END_VAR
  
  udSize := MMServer.GetBufferLen(MM_BufferIn);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::Init

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::LockOff
  
  // wird nicht unterstützt

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::LockOn
  
  // wird nicht unterstützt

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::ObjectTraceMessage
	VAR_INPUT
		txt 	: ^CHAR;
	END_VAR
  
  MerkerEx::ObjectTraceMessage(txt);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::SetData
	VAR_INPUT
		pData 	: ^USINT;
	END_VAR
  
  // wird nicht unterstützt

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::SetDataAt
	VAR_INPUT
		pData 	: ^USINT;
		udSize 	: UDINT;
		udAt 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
  MMServer.WriteDataOff(udSize, udAt, pData);
  ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::SetGrowBy
	VAR_INPUT
		udGrowBy 	: UDINT;
	END_VAR

  // wird nicht unterstützt

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::SetDataPtr
	VAR_INPUT
		pData 	: ^void;
	END_VAR
  
  // wird nicht unterstützt

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::SetSize
	VAR_INPUT
		udSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
  // wird nicht unterstützt
  ret_code := C_INCOMPATIBLE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::UpdateToFile
 // method is not used in here, just to keep compatibility to RamEx, String, StringInternal
END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::m_udLength::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	output := MMServer.Data.Read();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::m_udLength::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

  // nicht erlaubt
	result := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::m_udLength::Kill
	VAR_OUTPUT
		ret_code (EAX) 	: IprStates;
	END_VAR
  
  // wird nicht unterstützt
	ret_code := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::m_udLength::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR

	ret_code := MerkerEx::NewInst(pPara, pResult);
  
  IF (pPara^.uiCmd > 2) THEN
    MMServer.NewInst(pPara, pResult);
  END_IF;
    
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::m_udLength::GetState
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR

	ret_code := MMServer.Data.GetState(pPara, pResult);
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMServerMerkerEx::GetCRC
	VAR_OUTPUT
		udCRC 	: UDINT;
	END_VAR
  
  udCRC := MMServer.GetCRC();

END_FUNCTION

#pragma warning(default:73);
#pragma warning(default:74);