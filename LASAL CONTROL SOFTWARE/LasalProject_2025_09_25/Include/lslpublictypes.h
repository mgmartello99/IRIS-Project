//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
#RE_IN_DE
#pragma define (store)
#if _LSL_COMPILERVERSION >= 42
_LMCModuleBase : CLASS;
HwcLogging : CLASS;
SigCLib : CLASS;
#endif
_AxisBase : CLASS_PUBLIC
	TYPE
	  _LMCAXIS_POSINFOMODE :
	  (
	    POSINFO_TIME,
	    POSINFO_DISTANCE
	  )$UDINT;
	  _LMCAXIS_READPARAMETER_LREAL :
	  (
	    LMCAXIS_PAR_RD2_JMAX,
	    LMCAXIS_PAR_RD2_ACC
	  )$UDINT;
	  CmdControl :
	  (
	    IPRPowerOn,
	    IPRPowerOff,
	    IPRMoveRelative,
	    IPRMoveAbsolute,
	    IPRMoveReference,
	    IPRMoveEndless,
	    IPRMoveHand,
	    IPRStopMove,
	    IPRCoupleGearVelocity,
	    IPRCoupleDeltaPos,
	    IPRCoupleUserPos,
	    IPRCoupleProfilePos,
	    IPRCoupleGearRelative,
	    IPRCoupleGearAbsolute,
	    IPRCoupleCurveTab,
	    IPRSetSWEndPos,
	    IPRSetPosition,
	    IPRChangeCoupleSettings,
	    IPRTuneAxis,
	    IPRReadPosition,
	    IPRReadVelocity,
	    IPRInPosition,
	    IPRReadAxisStatus,
	    IPRReadAxisError,
	    IPRReadMasterInfo,
	    IPRSetFollowMode,
	    IPRReferenceReady,
	    IPRInpositionOk,
	    IPRCoupleGearPolynom,
	    IPRSetParameter,
	    IPRSetAdjustment,
	    IPRReadParameter,
	    IPRReadSWEndPos,
	    IPRCalcMovingTime,
	    IPRQuitError,
	    IPRCalcMaxSlavePath,
	    IPRCalcExtToAppliPos,
	    IPRReadUserData,
	    IPRGetMasterInformation,
	    IPR_SetErrorToMasterCoupleMonitoring,
	    IPRSetSafetyState,
	    IPRGetSafetyState
	  )$UINT;
	  t_e_LMCAXIS_GETSAFETYPARAMETER :  //! <Type Public   = "true" Comment  = "Public type which defines the allowed parameters of method GetSafetyData(). Check the comments of the single enum entries for more detailed information of the parameter.&#13;&#10;Available parameters:&#13;&#10;LMCAXIS_PAR_GET_SAFETY_SAFETYERROR - Reads the safety error information from either safety core 1 or safety core 2 (use mode to choose)&#13;&#10;LMCAXIS_PAR_GET_SAFETY_VERIFYSTATE - Reads the verify state of the connected axis. Does no trigger reading the a new value - the stored result of the hardware class is returned.&#13;&#10;LMCAXIS_PAR_GET_SAFETY_REFERENCESTATE - Reads the reference state of the connected axis. Does no trigger reading the a new value - the stored result of the hardware class is returned.&#13;&#10;LMCAXIS_PAR_GET_SAFETY_SBTSTATE - Reads the SBT state of the connected axis. Command triggers reading a new value by itself." Revision = "1.0" Name     = "t_e_LMCAXIS_GETSAFETYPARAMETER"> <RevDoku>  <Owner Company="Sigmatek"/>  <Dokumentation Revision="1.0" Date="2023-07-17" Author="StePhi" Company="Sigmatek" Description="Initial version of type"/> </RevDoku></Type>
	  (
	    LMCAXIS_PAR_GET_SAFETY_SAFETYERROR,
	    LMCAXIS_PAR_GET_SAFETY_SAFETYFUNCERROR,
	    LMCAXIS_PAR_GET_SAFETY_VERIFYSTATE,
	    LMCAXIS_PAR_GET_SAFETY_REFERENCESTATE,
	    LMCAXIS_PAR_GET_SAFETY_SBTSTATE,
	    LMCAXIS_PAR_GET_SAFETY_RUNSTATE,
	    LMCAXIS_PAR_GET_SAFETY_CNTRLSTATEWORD
	  )$UDINT;
	  t_e_LMCAXIS_SETSAFETYPARAMETER :  //! <Type Public   = "true" Comment  = "Public type which defines the allowed parameters of method SetSafetyData(). Check the comments of the single enum entries for more detailed information of the parameter.&#13;&#10;Available parameters:&#13;&#10;LMCAXIS_PAR_SET_SAFETY_SETVERIFY - Command sends a verify command to the connected axis. The command automatically reads the verify state afterwards.&#13;&#10;LMCAXIS_PAR_SET_SAFETY_CLEARVERIFY - Command sends a clear verify command to the connected axis. The command automatically reads the reference state afterwards.&#13;&#10;LMCAXIS_PAR_SET_SAFETY_CLEARREFERENCE - Command sends a clear reference command to the connected axis. The command automatically reads the reference state afterwards." Revision = "1.0" Name     = "t_e_LMCAXIS_SETSAFETYPARAMETER"> <RevDoku>  <Owner Company="Sigmatek"/>  <Dokumentation Revision="1.0" Date="2023-07-17" Author="StePhi" Company="Sigmatek" Description="Initial version of type"/> </RevDoku></Type>
	  (
	    LMCAXIS_PAR_SET_SAFETY_SETVERIFY,
	    LMCAXIS_PAR_SET_SAFETY_CLEARVERIFY,
	    LMCAXIS_PAR_SET_SAFETY_CLEARREFERENCE,
	    LMCAXIS_PAR_SET_SAFETY_QUITERROR,
	    LMCAXIS_PAR_SET_SAFETY_CHANGESERVICEMODE
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
_LMCRefBase : CLASS_PUBLIC
	TYPE
#pragma pack(push, 1)
	  _LMCAXIS_REFDATA : STRUCT
	    Status : iprStates;
	    Velocity : DINT;
	    Acc : DINT;
	    vSetRef1 : DINT;
	    vSetRef2 : DINT;
	    PosWindow : DINT;
	    LatchPosRef : DINT;
	    Speed : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  _LMCREF_READPARAMETER :
	  (
	    ZPULSE_DIST
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
#pragma InclDefBlk _LMCAxisBase
_LMCAxisBase : CLASS_PUBLIC
: _AxisBase
#include <.\lsl_st_systrace.h>
#include "..\Class\_LMCAxisBase\C_MathAxis.h"
#include "..\Class\_LMCAxisBase\_LMCTraceView.h"
#include "..\Class\_LMCAxisBase\BacklashLogin.h"
#include "..\Source\DriveSafetyIF.h"
	TYPE
	  _CommandList :
	  (
	    CPowerOn,
	    CPowerOff,
	    CInposition,
	    CMoveHand,
	    CMoveEndless,
	    CMoveAbsolut,
	    CMoveReference,
	    CMoveRelative,
	    CStopMove,
	    CCoupleGearAbsolute,
	    CCoupleGearRelative,
	    CCoupleGearVelocity,
	    CCoupleCurveTab,
	    CCoupleUserPos,
	    CCoupleDeltaPos,
	    CCoupleProfilePos,
	    CSetPosition,
	    CSetAutoOffset,
	    CSetCoupleParameter,
	    CSetParameter,
	    CReadPosition,
	    CSetSWEndPos,
	    CReadSWEndPos,
	    CReadAxisError,
	    CReadAxisStatus,
	    CReadMasterInfo,
	    CReadVelocity,
	    CReadParameter,
	    CTuneAxis:=28,
	    CInternModuloOverFlow:=29,
	    CFollowMode:=30,
	    CCoupleGearPolynom:=31,
	    CCoupleAdditivePosDiff:=32,
	    CCoupleCAM,
	    CMoveShortestWay,
	    CCalcMovingTime,
	    CQuitError,
	    CCalcMaxSlavePath,
	    CCalcExtToAppliPos,
	    CChangeMoveSettings,
	    CGetPosInfoBeforeRampDown,
	    CSetDynSWEndPos,
	    CQuickStop,
	    CSetSafetyData,
	    CGetSafetyData
	  )$UDINT;
	  _CoupleMonitorExtendedConfig : BDINT
	  [
	    1 ReportErrorToMaster,
	    2 ReportSlaveErrorToMaster,
	    3 ReportMasterErrorToSlave,
	    4 ReportSlaveErrorToSlave,
	    5 SwLimitMonitoring,
	    6 PowerOffMonitoring,
	  ];
	  _LogStruct : STRUCT
	    Command : _CommandList;
	    CommandoResult : _LMCAXIS_CMDERROR;
	    TimeStamp : UDINT;
	    RTStamp : UDINT;
	  END_STRUCT;
	  _LogFile : STRUCT
	    Logmode : DINT;
	    AccesNr : DINT;
	    LogData : ARRAY [0..101] OF _LogStruct;
	  END_STRUCT;
	  t_BLMMeasFlags : BINT
	  [
	    1 StartMeasurement,
	    2 DoMeasurement,
	    3 FinishedMeasurement,
	    4 BLValueDetected,
	    5 BLAmountNegCalced,
	    6 BLAmountPosCalced,
	    7 GetHWInfo,
	    8 HWInfoError,
	    9 DoBLValCorrection,
	    10 InvCurr,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 DoMeasurementError,
	  ];
	  t_BLCCompFlags : BINT
	  [
	    1 DirFlg,
	    2 TransitionActive,
	    3 Enabled,
	    4 EnabledMarker,
	    5 UseTable,
	    6 CallTable,
	    7 CalcBL,
	    8 Standstill,
	    9 StandstillMarker,
	    10 MoveDirChanged,
	    11 ValidTable,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 TransferBLAmountError,
	    16 ExecuteBacklashError,
	  ];
	  t_s_LMCAxis_SafetyState : BDINT  //! <Type Public   = "true" Comment  = "Public type defining the safety axis state information of SafetyAxisState server." Revision = "1.0" Name     = "t_s_LMCAxis_SafetyState"> <RevDoku>  <Owner Company="Sigmatek"/>  <Dokumentation Revision="1.0" Date="2023-07-17" Author="StePhi" Company="Sigmatek" Description="Initial version of type"/> </RevDoku></Type>
	  [
	    1 SafeAxis,
	    2 SpeedLimited,
	    3 AxisReady,
	    4 AxisOperational,
	    5 AxisError,
	    6 ServiceModePending,
	    7 SafeErrorQuitPending,
	    8 AxisVerified,
	    9 AxisVerifyFailed,
	    10 AxisReferenced,
	    11 AxisReferenceActive,
	    12 AxisReferenceNeeded,
	    13 AxisReferenceFailed,
	    14 SBTAvailable,
	    15 SBTActive,
	    16 SBTFailed,
	    17 FSoESetupFailed,
	    18 AutomaticSS2Active,
	  ];
	  te_BLCmdClassSvr :
	  (
	    IPBLCGetPointerBacklash:=51,
	    IPBLCSetBacklashAmount,
	    IPBLCGetPointerBLCompFlags,
	    IPBLCExecute,
	    IPBLCSetPointerSetPosVel,
	    IPBLCSetTimeBase,
	    IPBLCDetectMoveDirChange,
	    IPBLCReset,
	    IPBLMGetPointerBacklashValue:=71,
	    IPBLMDoMeasurement,
	    IPBLMGetPointerMeasFlags,
	    IPBLMSetTimeBase,
	    IPBLMSetExtIntUnits,
	    IPBLMSetPlaceAxisNo,
	    IPBLMSetCurrSign,
	    IPBLMReset
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
#pragma InclDefBlk _LMCMathFunctions
_LMCMathFunctions : CLASS_PUBLIC
#include "..\Class\_LMCMathFunctions\C_MathFunct.h"
	TYPE
#pragma pack(push, 4)
	  _coeff_ : STRUCT
	    coA : LREAL;
	    coB : LREAL;
	    coC : LREAL;
	    coD : LREAL;
	    coE : LREAL;
	  END_STRUCT;
#pragma pack(pop)
	  _COORD_2D : ARRAY [0..1] OF DINT;
#pragma pack(push, 4)
	  _LMC_VECTOR3 : STRUCT
	    coord_x1 : LREAL;
	    coord_x2 : LREAL;
	    coord_x3 : LREAL;
	  END_STRUCT;
#pragma pack(pop)
	  t_e_LMC_MoveProf_Jerk_ProfTypes :
	  (
	    LMC_ProfType_Jerk_TT,
	    LMC_ProfType_Jerk_TW,
	    LMC_ProfType_Jerk_WW,
	    LMC_ProfType_Jerk_WT,
	    LMC_ProfType_Jerk_XW,
	    LMC_ProfType_Jerk_XT
	  )$UDINT;
	  t_e_LMCMath_Retcodes :
	  (
	    LMCMathRet_NoError,
	    LMCMathRet_NegRoot,
	    LMCMathRet_InputErr,
	    LMCMathRet_NotPossible
	  )$UDINT;
#pragma pack(push, 1)
	  t_st_LMC_MoveProf_Jerk_Point : STRUCT
	    lrT : LREAL;
	    lrS : LREAL;
	    lrV : LREAL;
	    lrA : LREAL;
	    lrJ : LREAL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_st_LMC_MoveProf_Jerk : STRUCT
	    ProfileType : t_e_LMC_MoveProf_Jerk_ProfTypes;
	    aPts : ARRAY [0..9] OF t_st_LMC_MoveProf_Jerk_Point;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
END_CLASS;
#pragma define (restore)
_LMCPublisher : CLASS_PUBLIC
	TYPE
	  _Config_ : BDINT
	  [
	    1 VirtualAxis,
	    2 RealAxis,
	  ];
	  _LMCPublisher_Cmd :
	  (
	    _LOGINCMD:=123
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
_ModBusTCPSLAVE : CLASS_PUBLIC
#include "..\Source\MB_Definitions.h"
	TYPE
#pragma pack(push, 1)
	  _ONE_ENTRY : STRUCT
	    udEntryNo : UDINT;
	    uiAddress : UINT;
	    usReg : USINT;
	    usAccess : USINT;
	    ptr : ^DINT;
	    usType : USINT;
	    dDataType : DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
END_CLASS;
#pragma define (restore)
_SerLib : CLASS_PUBLIC
	TYPE
	  CmdCommand :
	  (
	    StartUserIPR,
	    StopUserIPR,
	    SerCloseIPR,
	    SerSendIPR,
	    RecvCharIPR,
	    SetOnlineIPR,
	    GetRecvStateIPR,
	    GetSendStateIPR,
	    GetErrorIPR,
	    IsInitializedIPR,
	    ClearRecBufferIPR,
	    RtsOnOffIPR,
	    rdRtsIPR,
	    rdCtsIPR,
	    DtrOnOffIPR,
	    rdDtrIPR,
	    rdDcdIPR,
	    rdDsrIPR,
	    rdRiIPR,
	    SetRSModeIPR,
	    GetRSModeIPR,
	    GetInterfaceTypeIPR
	  )$UINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Attuatore : CLASS_PUBLIC
	TYPE
	  t_fsm_actuator :
	  (
	    idle,
	    Push,
	    Pull
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Controller : CLASS_PUBLIC
	TYPE
	  _LMCCONTROLLER_SETPARAMETER :
	  (
	    _LMCCONTROLLER_PAR_SET_CYCLIC_DRIVE_ENABLED_CHECK,
	    _LMCCONTROLLER_PAR_SET_QUICKSTOP_ERRORREACTION
	  )$UDINT;
	  t_e_LMCCONTROLLER_SAFETY_PARAM :
	  (
	    _LMCCONTROLLER_SAFETY_GETVERIFYSTATE,
	    _LMCCONTROLLER_SAFETY_GETREFERENCESTATE,
	    _LMCCONTROLLER_SAFETY_GETSAFETYRUNSTATE,
	    _LMCCONTROLLER_SAFETY_GETSBTSTATE,
	    _LMCCONTROLLER_SAFETY_GETSBTTESTTIME,
	    _LMCCONTROLLER_SAFETY_GETSBTMINTORQUE,
	    _LMCCONTROLLER_SAFETY_GETSBTTESTINTERVAL,
	    _LMCCONTROLLER_SAFETY_GETSAFETYERROR,
	    _LMCCONTROLLER_SAFETY_GETSAFETYFUNCERROR,
	    _LMCCONTROLLER_SAFETY_READAXISSTATE:=101,
	    _LMCCONTROLLER_SAFETY_GETSAFECNTRLSTATEWORD,
	    _LMCCONTROLLER_SAFETY_DOSAFETYAXERRORQUIT:=201,
	    _LMCCONTROLLER_SAFETY_SETVERIFYAXIS,
	    _LMCCONTROLLER_SAFETY_SETREFERENCEAXIS,
	    _LMCCONTROLLER_SAFETY_SETACKZEROPOSITION,
	    _LMCCONTROLLER_SAFETY_SETSBTSTATE,
	    _LMCCONTROLLER_SAFETY_SBTACTIVE,
	    _LMCCONTROLLER_SAFETY_CHANGESERVICEMODE,
	    _LMCCONTROLLER_SAFETY_LOGINAXIS:=301
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
IrradiationManager : CLASS_PUBLIC
	TYPE
	  t_timerCase :
	  (
	    Idle:=30,
	    tablet1:=0,
	    tablet2:=10,
	    tablet3:=20
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
MainSequence : CLASS_PUBLIC
	TYPE
	  t_MainSequence_step :
	  (
	    Idle,
	    Homing,
	    Phasing,
	    Charge,
	    Irradiation,
	    Discharge,
	    Stop,
	    Reset,
	    Error,
	    HardReset
	  )$UDINT;
	  t_Sequence_Cmd :
	  (
	    Cmd_idle,
	    Cmd_start,
	    Cmd_stop,
	    Cmd_reset,
	    Cmd_charge,
	    Cmd_irradiation,
	    Cmd_Discharge,
	    Cmd_misure,
	    Cmd_error
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Manager_globale : CLASS_PUBLIC
	TYPE
	  t_IrradiationPhase :
	  (
	    Irradiation_Idle,
	    Irradiation_Start:=10,
	    Irradiation_Over:=20
	  )$UDINT;
	  t_Manager_globale_state :
	  (
	    Idle,
	    Start:=10,
	    Charge:=20,
	    Irradiation:=30,
	    Discharge:=40,
	    Reset:=60,
	    ErrorState:=70,
	    Stop:=80
	  )$UDINT;
	  t_MeasurementPhase :
	  (
	    Measurement_Idle,
	    Measurement_Start:=10,
	    Measurement_Over:=20
	  )$UDINT;
	  t_ReCoupleM3 :
	  (
	    RecoupledM3_idle:=0,
	    RecoupledM3_Startmoving:=10,
	    RecoupledM3_moving:=20,
	    RecoupledM3_ok:=30
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
ManagerMotori : CLASS_PUBLIC
	TYPE
	  t_Sequence_Cmd_ManagerMotori :
	  (
	    Cmd_ManagerMotori_idle,
	    Cmd_ManagerMotori_homing,
	    Cmd_ManagerMotori_phasing,
	    Cmd_ManagerMotori_charge,
	    Cmd_ManagerMotori_irradiation,
	    Cmd_ManagerMotori_discharge,
	    Cmd_ManagerMotori_misure,
	    Cmd_ManagerMotori_stop,
	    Cmd_ManagerMotori_reset,
	    Cmd_ManagerMotori_Stopped
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Manual_Motor : CLASS_PUBLIC
	TYPE
	  T_Manual_Case :
	  (
	    Idle,
	    M_Stop,
	    M_Stopped,
	    Error,
	    Reset,
	    Movement,
	    M_PowerOn,
	    M_PowerOff,
	    Home_forward,
	    Home_reverse,
	    OneStep_forward,
	    OneStep_reverse
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Manual_MotorBT : CLASS_PUBLIC
	TYPE
	  T_Manual_Case :
	  (
	    Idle,
	    M_Stop,
	    M_Stopped,
	    Error,
	    Reset,
	    Movement,
	    M_PowerOn,
	    M_PowerOff,
	    Home_forward,
	    Home_reverse,
	    OneStep_forward,
	    OneStep_reverse
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
ManualMotor_CBCM : CLASS_PUBLIC
	TYPE
	  T_Manual_Case :
	  (
	    Idle,
	    M_Stop,
	    M_Stopped,
	    Error,
	    Reset,
	    Movement,
	    M_PowerOn,
	    M_PowerOff,
	    Home_forward,
	    Home_reverse,
	    OneStep_forward,
	    OneStep_reverse
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
ManualMotor_DB : CLASS_PUBLIC
	TYPE
	  T_Manual_Case :
	  (
	    Idle,
	    M_Stop,
	    M_Stopped,
	    Error,
	    Reset,
	    Movement,
	    M_PowerOn,
	    M_PowerOff,
	    Home_forward,
	    Home_reverse,
	    OneStep_forward,
	    OneStep_reverse
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
MerkerEx : CLASS_PUBLIC
#include <.\lsl_st_mt.h>
	TYPE
	  Cmdm_udLength :
	  (
	    GET_DATA_PTR,
	    EXCHANGE_DATA_PTR,
	    SAVE_DATA_TO_RAMEXFILE
	  )$UINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Mode_selector_class : CLASS_PUBLIC
	TYPE
	  T_Selector :
	  (
	    Automatic:=0,
	    Manual:=1,
	    Idle
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Motore_M1 : CLASS_PUBLIC
	TYPE
	  t_sequence_Cmd_motore_M1 :
	  (
	    Cmd_motore_M1_idle,
	    Cmd_motore_M1_homing,
	    Cmd_motore_M1_phasing,
	    Cmd_motore_M1_movement,
	    Cmd_motore_M1_reset,
	    Cmd_motore_M1_Error,
	    Cmd_motore_M1_stop,
	    Cmd_motore_M1_stopped
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Motore_M2 : CLASS_PUBLIC
	TYPE
	  t_sequence_Cmd_motore_M2 :
	  (
	    Cmd_motore_M2_idle,
	    Cmd_motore_M2_homing,
	    Cmd_motore_M2_phasing,
	    Cmd_motore_M2_movement,
	    Cmd_motore_M2_reset,
	    Cmd_motore_M2_stop,
	    Cmd_motore_M2_stopped,
	    Cmd_motore_M2_Error
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Motore_M3 : CLASS_PUBLIC
	TYPE
	  t_sequence_Cmd_motore_M3 :
	  (
	    Cmd_motore_M3_idle,
	    Cmd_motore_M3_homing,
	    Cmd_motore_M3_phasing,
	    Cmd_motore_M3_movement,
	    Cmd_motore_M3_reset,
	    Cmd_motore_M3_stop,
	    Cmd_motore_M3_stopped,
	    Cmd_motore_M3_Error
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Motore_M4 : CLASS_PUBLIC
	TYPE
	  t_sequence_Cmd_motore_M4 :
	  (
	    Cmd_motore_M4_idle,
	    Cmd_motore_M4_homing,
	    Cmd_motore_M4_phasing,
	    Cmd_motore_M4_movement,
	    Cmd_motore_M4_reset,
	    Cmd_motore_M4_stop,
	    Cmd_motore_M4_stopped,
	    Cmd_motore_M4_Error,
	    Cmd_motore_M4_movement_2
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Motore_M5 : CLASS_PUBLIC
	TYPE
	  t_sequence_Cmd_motore_M5 :
	  (
	    Cmd_motore_M5_idle,
	    Cmd_motore_M5_homing,
	    Cmd_motore_M5_phasing,
	    Cmd_motore_M5_movement_CHARGING,
	    Cmd_motore_M5_reset,
	    Cmd_motore_M5_movement_IRRADIATION,
	    Cmd_motore_M5_movement_DISCHARGING,
	    Cmd_motore_M5_stop,
	    Cmd_motore_M5_stopped,
	    Cmd_motore_M5_Error
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Motore_M6 : CLASS_PUBLIC
	TYPE
	  t_sequence_Cmd_motore_M6 :
	  (
	    Cmd_motore_M6_idle,
	    Cmd_motore_M6_homing,
	    Cmd_motore_M6_phasing,
	    Cmd_motore_M6_movement,
	    Cmd_motore_M6_reset,
	    Cmd_motore_M6_stop,
	    Cmd_motore_M6_stopped,
	    Cmd_motore_M6_Error
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Motore_M7 : CLASS_PUBLIC
	TYPE
	  t_sequence_Cmd_motore_M7 :
	  (
	    Cmd_motore_M7_idle,
	    Cmd_motore_M7_homing,
	    Cmd_motore_M7_phasing,
	    Cmd_motore_M7_movement,
	    Cmd_motore_M7_reset,
	    Cmd_motore_M7_Error,
	    Cmd_motore_M7_stop,
	    Cmd_motore_M7_stopped
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
MPS : CLASS_PUBLIC
	TYPE
	  CaseMPS :
	  (
	    MPS_Idle,
	    MPS_Ok_To_IRIS,
	    MPS_No_To_IRIS
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
Rack12V : CLASS_PUBLIC
	TYPE
	  t_CommandRack :
	  (
	    Idle:=10,
	    Command_On:=1,
	    Command_Off:=0
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
SafetyCDIAS_Base : CLASS_PUBLIC
#include "..\Class\SafetyCDIAS_Base\SafetyCDIAS_Base.h"
#include "..\Source\interfaces\lsl_st_safety.h"
#include "..\Class\SafetyManager\SafetyManager.h"
	TYPE
	  FrameTypeType : BSINT
	  [
	    1 Cfg,
	    2 ToP,
	    3 Standard,
	    4 PDO,
	    5 TDO,
	    6 Reserved1,
	    7 Reserved2,
	    8 Response,
	  ];
#pragma pack(push, 1)
	  SDOStdHeader : STRUCT
	    CRC : UDINT;
	    Cmd : USINT;
	    Typ : FrameTypeType;
	    SeqNr : USINT;
	    Len : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  SDOHeader : STRUCT
	    StdHeader : SDOStdHeader;
	    SrcAdr : HDINT;
	    DstAdr : HDINT;
	    SessId : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
END_CLASS;
#pragma define (restore)
SafetyUDP : CLASS_PUBLIC
	TYPE
	  _FSM_UDP_ERROR :
	  (
	    _NO_ERROR_UDP_ERROR:=0,
	    _INIT_TCP_USER_UDP_ERROR:=4294967295,
	    _NO_IP_ADDRESS_UDP_ERROR:=4294967294,
	    _NO_MEMORY_SOCKET_UDP_ERROR:=4294967293,
	    _NO_MEMORY_SENDBUFFER_UDP_ERROR:=4294967292,
	    _INVALID_HANDLE_UDP_ERROR:=4294967291,
	    _SHUTDOWN_UDP_ERROR:=4294967290,
	    _CLOSESOCKET_UDP_ERROR:=4294967289,
	    _ALLOCATE_SOCKET_UDP_ERROR:=4294967288,
	    _SET_BIND_UDP_ERROR:=4294967287,
	    _RECV_UDP_ERROR:=4294967286,
	    _SEND_UDP_ERROR:=4294967285,
	    _NO_LOCAL_IP_UDP_ERROR:=4294967284,
	    _NO_DESTINATION_IP_UDP_ERROR:=4294967283,
	    _INVALID_UDP_PORT_UDP_ERROR,
	    _INVALID_INTERFACE_NUMBER_UDP_ERROR,
	    _NO_MEMORY_RECEIVE_BUFFER_UDP_ERROR,
	    _NO_MEMORY_CONNECTION_BUFFER_UDP_ERROR
	  )$DINT;
	  _FSM_UDP_USER :
	  (
	    _STATE_INIT_UDP,
	    _STATE_IDLE_UDP,
	    _STATE_SOCK_UDP,
	    _STATE_CONNECT_UDP,
	    _STATE_ONLY_SEND_UDP,
	    _STATE_RECV_UDP,
	    _STATE_SEND_UDP,
	    _STATE_SHUTDOWN_UDP,
	    _STATE_CLOSE_SOCK_UDP,
	    _STATE_ERROR_UDP
	  )$UDINT;
	  _INITSTEPS :
	  (
	    _NO_OPERATION,
	    _ADD_SOCKET,
	    _CHECK_IF_SOCKET_OPEN,
	    _BIND_SOCKET,
	    _CLOSE_CON
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
#pragma InclDefBlk SdiasBase
SdiasBase : CLASS_PUBLIC
#include "..\Class\SdiasManager\SdiasManager.h"
#include "..\Class\SdiasBase\SdiasBase.h"
#include "..\Class\HwControl\HwControl.h"
#include "..\Source\interfaces\lsl_st_hardwaretree.h"
#include "..\Source\interfaces\lsl_st_mt.h"
	TYPE
	  t_b_SdiasFWState : BINT
	  [
	    1 VoltageNotOk,
	    2 NoSync,
	    3 FlashDataCRCError,
	    4 RAMDataCRCError,
	    5 FlashUnsafe,
	    6 BusTimeNotSupported,
	    7 ToggleBit,
	  ];
#pragma pack(push, 1)
	  t_s_SdiasFWStateStandard : STRUCT
	    ErrorBits : t_b_SdiasFWState;
	    Reserved : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_SPI_AccessControl : STRUCT
	    udAccessHandle : UDINT;
	    usAccessLength : USINT;
	    usAccessOffset : USINT;
	    pControlByte : t_SDIAS_pControlByte;
	    pStateByte : t_SDIAS_pStateByte;
	  END_STRUCT;
#pragma pack(pop)
	  t_SPI_PDO_DataWrite : ARRAY [0..SDIAS_MAX_PDO_SIZE-1] OF USINT;
	  t_SPI_PDO_DataRead : ARRAY [0..SDIAS_MAX_PDO_SIZE-1] OF USINT;
	  t_e_SPIWriteSSW :
	  (
	    _SPIWrite_Idle,
	    _AllocateMemory,
	    _SetRequest,
	    _ReadGrant,
	    _ReadSectorData_SetPageAddress,
	    _ReadSectorData_Wait4SetPageAddress,
	    _ReadSectorData_SetReadPageCommand,
	    _ReadSectorData_Wait4SetReadPageCommand,
	    _ReadSectorData_ReadReceiveBufferPart1,
	    _ReadSectorData_ReadReceiveBufferPart2,
	    _EraseSector_SetPageAddress,
	    _EraseSector_Wait4SetPageAddress,
	    _EraseSector_SetEraseSectorCommand,
	    _EraseSector_Wait4SetEraseSectorCommand,
	    _WriteSectorData_SetPageAddress,
	    _WriteSectorData_Wait4SetPageAddress,
	    _WriteSectorData_WriteTransmitBufferPart1,
	    _WriteSectorData_WriteTransmitBufferPart2,
	    _WriteSectorData_SetWritePageCommand,
	    _WriteSectorData_Wait4SetWritePageCommand,
	    _VerifySectorData_SetPageAddress,
	    _VerifySectorData_Wait4SetPageAddress,
	    _VerifySectorData_SetReadPageCommand,
	    _VerifySectorData_Wait4SetReadPageCommand,
	    _VerifySectorData_ReadReceiveBufferPart1,
	    _VerifySectorData_ReadReceiveBufferPart2,
	    _VerifySectorData_CompareData,
	    _ClearRequest,
	    _DisableDataObjects,
	    _FreeMemory,
	    _FinishSPIWrite
	  )$UDINT;
	  usWriteModes : USINT;
#pragma pack(push, 1)
	  t_s_SPIWriteVars : STRUCT
	    sWriteAccess : t_s_SPI_AccessControl;
	    pWriteData : ^t_SPI_PDO_DataWrite;
	    sReadAccess : t_s_SPI_AccessControl;
	    pReadData : ^t_SPI_PDO_DataRead;
	    sReadStateAccess : t_s_SPI_AccessControl;
	    pReadStateData : ^USINT;
	    pSectorMemoryRead : ^USINT;
	    pSectorMemoryWrite : ^USINT;
	    pSectorMemoryVerify : ^USINT;
	    pUserWriteData : ^USINT;
	    udUserWriteLength : UDINT;
	    usUserSectorNumber : USINT;
	    usUserPageNumber : USINT;
	    usUserPageOffset : USINT;
	    eSPIWriteSSW : t_e_SPIWriteSSW;
	    eSPIWriteSSWError : t_e_SPIWriteSSW;
	    uiCurrentPage : UINT;
	    udCurrentSectorMemoryOffset : UDINT;
	    usRetryCnt : USINT;
	    bsFinished : BSINT
	    [
	      1 Finished,
	      2 Error,
	      3 Bit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	    ];
	    usCycleWaitCnt : USINT;
	    udTimeout : UDINT;
	    NotReadyCnt : DINT;
	    usFinishedWriteLog : USINT;
	    usWriteMode : usWriteModes;
	    udMemoryToAllocate : UDINT;
	    uiLastPage : UINT;
	    udUserDataOffset : DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
END_CLASS;
#pragma define (restore)
ST151Base : CLASS_PUBLIC
: SdiasBase
	TYPE
	  bd_EnabledFreqLimit : BDINT
	  [
	    1 FullStep,
	    2 HalfStep,
	    3 MicroStepping4,
	    4 MicroStepping8,
	    5 MicroStepping16,
	    6 MicroStepping32,
	    7 MicroStepping64,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
	  bd_ExtendedStateWord : BDINT
	  [
	    1 ZeroPosition,
	    2 OverTempWarning,
	    3 OverTempFailure,
	    4 OverCurrentFailureGND,
	    5 OverCurrentFailureBridge1,
	    6 OverCurrentFailureBridge2,
	    7 Encoder5VOk,
	    8 Bit8,
	    9 BridgeVoltageTooLow,
	    10 BridgeVoltageTooHigh,
	    11 ExternEnableSTO1,
	    12 ExternEnableSTO2,
	    13 SafetyStartUpOK,
	    14 MotorEnableError,
	    15 ThreeTimeSyncInLost,
	    16 SafeRampDownPending,
	    17 LoadWarning,
	    18 LoadDisableBridge,
	    19 LoadDisableResistor,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
	END_TYPE
END_CLASS;
#pragma define (restore)
StepperControl : CLASS_PUBLIC
: Controller
	TYPE
	  te_SCMicroSteps :
	  (
	    MS_1:=1,
	    MS_2:=2,
	    MS_4:=4,
	    MS_8:=8,
	    MS_16:=16,
	    MS_32:=32,
	    MS_64:=64,
	    MS_128:=128,
	    MS_256:=256,
	    MS_512:=512
	  )$UDINT;
	END_TYPE
END_CLASS;
#pragma define (restore)
VirtualBaseInit : CLASS_PUBLIC
	TYPE
	  CmdData :
	  (
	    GET_ADD_INFO,
	    READ_DATA,
	    WRITE_DATA,
	    READ_DATA_OFF,
	    WRITE_DATA_OFF
	  )$UINT;
	END_TYPE
END_CLASS;
#pragma define (restore)

#RE_IN_DE
