//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Source\MB_Definitions.h"

(*!
<Class
	Name               = "_ModBusTCPSLAVE"
	Revision           = "1.36"
	GUID               = "{3C8302A4-FDE1-4DC2-BBE1-25FE25307769}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(590,120)"
	Comment            = "Slave for ModBus over TCP Communication">
	<Channels>
		<Server Name="UseOffset" GUID="{D471DB9C-450A-498A-B89D-D64D2C0B8868}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="for HOLDING register&#13;&#10;0 = Offset is not added (default)&#13;&#10;1 = Offset from client StartAddrOffset is subtracted from the startadress of incoming message"/>
		<Server Name="UseOffsInputReg" GUID="{6EA82A67-23A5-49D0-8575-7BDB9956FA28}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="for INPUT register&#13;&#10;0 = Offset is not added (default)&#13;&#10;1 = Offset from client StartAddrOffset is subtracted from the startadress of incoming message"/>
		<Client Name="cBufSize" Required="true" Internal="false" DefValue="100" Comment="buffer size for HOLDING registers&#13;&#10;[number of parameter entries]"/>
		<Client Name="cBufSizeInputReg" Required="true" Internal="false" DefValue="100" Comment="buffer size for INPUT registers&#13;&#10;[number of parameter entries]"/>
		<Client Name="cFileOrTable" Required="true" Internal="false" Comment="Bitset for configuration &#13;&#10;Bit 0 ... HOLDING registers: 0 = Use File / 1 = Use Table&#13;&#10;Bit 1 ... INPUT registers: 0 = Use File / 1 = Use Table&#13;&#10;"/>
		<Client Name="coFileSys" Required="false" Internal="false" Comment="ObjectChannel to _FileSys&#13;&#10;has not to be required"/>
		<Client Name="Config" Required="false" Internal="false" Comment="CONFIG BITMASK&#13;&#10;&#13;&#10;Bit 0: modbus exception logging&#13;&#10;0 ... modbus exception logging off&#13;&#10;1 ... modbus exception logging on"/>
		<Client Name="coSigCLib" Required="false" Internal="false"/>
		<Client Name="coString" Required="false" Internal="false" Comment="Object Channel to String - Name of parameter-file for HOLDING registers&#13;&#10;"/>
		<Client Name="coStringInputReg" Required="false" Internal="false" Comment="Object Channel to String - Name of parameter-file for INPUT registers"/>
		<Client Name="coSysMsg" Required="false" Internal="false"/>
		<Client Name="cTable" Required="false" Internal="false" Comment="if a parameter-table for HOLDING registers is in use, this client must be connected"/>
		<Client Name="cTableInputReg" Required="false" Internal="false" Comment="if a parameter-table for INPUT registers is in use, this client must be connected"/>
		<Client Name="cTurnBytes" Required="true" Internal="false" DefValue="1" Comment="0: Do not turn bytes&#13;&#10;1: Turn bytes of data like specified in modbus-specification"/>
		<Client Name="StartAddrOffset" Required="false" Internal="false" Comment="HOLDING register: Offset to the StartAddress&#13;&#10;(Has to be activated by server UseOffset)"/>
		<Client Name="StartAddrOffsInputReg" Required="false" Internal="false" Comment="INPUT register: Offset to the StartAddress&#13;&#10;(Has to be activated by server UseOffsInputReg)"/>
		<Client Name="to_AsciiBin" Required="true" Internal="false" Comment="ObjectChannel to ASCII_BIN&#13;&#10;has not to be required"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\MB_Definitions.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="SIGMATEK"/>
		<Dokumentation Revision="1.36" Date="2020-08-03" Author="KaiAnd" Company="SIGMATEK" Description="new class server &quot;sDisable&quot; to deactivate the TCPIP server"/>
		<Dokumentation Revision="1.35" Date="2018-01-24" Author="SchMat" Company="SIGMATEK" Description="-improvement: modbus exception logging&#13;&#10;-bugfix: corrected wrong result of method Check_Request using modbus function 0x04 (read input registers)&#13;&#10;-bugfix: corrected message lenght in modbus application header in exception response&#13;&#10;-bugfix: corrected exception code in method Check_Request()"/>
		<Dokumentation Revision="1.34" Date="2016-11-30" Author="KaiAnd" Company="SIGMATEK" Description="Many extensions for implementation of &quot;Read Input Registers&quot;&#13;&#10;-- new clients: cTableInputReg, coStringInputReg, cBufSizeInputReg, UseOffsInputReg, StartAddrOffsInputReg&#13;&#10;-- client cFileOrTable is a bitmask now; Bit 0 for HoldingREgister, Bit 1 for InputRegister&#13;&#10;-- variable vAddressEntries renamed to vAddrEntriesHolding&#13;&#10;--new variable for InpuRegisters vAddrEntriesInput (according to vAddrEntriesHolding)&#13;&#10;-- new code for Table and CSV for INPUT (according to existing HOLDING-code)&#13;&#10;-- check client cFileOrTable now as bitmask&#13;&#10;-- method ::Response(): new variant MB_FUNC_RD_MULTIPLE_INPUT_REG (Define, Code - according to MB_FUNC_RD_MULTIPLE_REG)&#13;&#10;&#13;&#10;Extensions in:  ::Init(), ::ReadTable(), ::ReadCSVFile(), ::ReadFileParams(), ::SortEntries(), ::CheckEntryError(), ::AddParameter(), ::AddParameterList(), &#13;&#10;::DeleteParameterEntries(), ::Search_Parameter(), ::Read_Multiple_Registers(), ::Write_Multiple_Registers(), ::Check_Request(), ::Response()"/>
		<Dokumentation Revision="1.33" Date="2016-01-04" Author="HubChr" Company="SIGMATEK" Description="- Fixed possible crash if a String-Object was connected to coString that did not contain a dpne."/>
		<Dokumentation Revision="1.32" Date="2015-09-03" Author="dusdan" Company="SIGMATEK" Description="- new methods to add a list of parameters and to delete all entries&#13;&#10;- bugfix: do not search for parameters if there are none&#13;&#10;- added client to decide whether sended bytes should be turned or not"/>
		<Dokumentation Revision="1.31" Date="2014-07-08" Author="Matthias Schuiki" Company="SIGMATEK" Description="-) bug fix&#13;&#10;     -) increased the response data buffer to 260 byte (maximal message size Modbus TCP)"/>
		<Dokumentation Revision="1.30" Date="2014-01-13" Author="spimar" Company="SIGMATEK" Description="Improvement: Check if message fits in the receive buffer;"/>
		<Dokumentation Revision="1.20" Date="2013-07-12" Author="spimar" Company="SIGMATEK" Description="ARM ready&#13;&#10; - Fixed a bug which can occur if the number of parameters is greater than the defined buffersize;&#13;&#10;Fixed a bug when parameters were defined in a CSV file, the read and write function doesn&apos;t work correct;&#13;&#10;Methods ReadFileParams() and Check_Request() are now virtual;"/>
		<Dokumentation Revision="1.10" Date="2013-02-05" Author="spimar" Company="SIGMATEK" Description="- New client and a new server, for offset useage&#13;&#10;- The offset functionality was extended to an automatic detection mode;&#13;&#10;- Fixed a bug which can occur if the buffersize has the same size as number of parameters;"/>
		<Dokumentation Revision="1.4" Date="2012-07-23" Author="spimar" Company="SIGMATEK" Description="The object client to_AsciiBin is now required because of the latest change of the class ASCII_BIN;"/>
		<Dokumentation Revision="1.3" Date="2012-02-23" Author="spimar" Company="SIGMATEK" Description="Changed path of Headerfile;"/>
		<Dokumentation Revision="1.2" Date="2011-10-10" Author="SCHMAT" Company="SIGMATEK" Description="read/write lasal server with size of one register  (16 bit)"/>
		<Dokumentation Revision="1.1" Date="2011-07-19" Author="SCHMAT" Company="SIGMATEK" Description="using modbus parameter addresses greater than 9 possible&#13;&#10;client coString added to define own names of modbus parameter files"/>
		<Dokumentation Revision="1.0" Date="11.10.2010" Author="KELSTE" Company="SIGMATEK" Description="Slave for ModBus over TCP Communication"/>
	</RevDoku>
	<Network Name="_ModBusTCPSLAVE">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name           = "_base"
				GUID           = "{D8B4F72F-9CD4-4AFE-80BB-BE1AA240645B}"
				Class          = "_TCPIP_SERVER"
				Position       = "(218,120)"
				Visualized     = "false"
				BackgroundTime = "always">
				<Channels>
					<Server Name="sControl"/>
					<Server Name="sDisable"/>
					<Server Name="SemaName01"/>
					<Server Name="SemaName02"/>
					<Server Name="sError"/>
					<Server Name="TaskName"/>
					<Client Name="cConfig"/>
					<Client Name="cMaxConnections" Value="0"/>
					<Client Name="co_MultiTask"/>
					<Client Name="co_SigCLib"/>
					<Client Name="co_StdLib"/>
					<Client Name="co_Task"/>
					<Client Name="cPort"/>
					<Client Name="cSizeOfTXBuffer"/>
					<Client Name="cTimeout"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.sControl" Destination="_base.sControl" Vertices="(996,210),(824,210),"/>
			<Connection Source="this.sError" Destination="_base.sError" Vertices="(996,270),(824,270),"/>
			<Connection Source="_base.cPort" Destination="this.cPort" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.cTimeout" Destination="this.cTimeout" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.cSizeOfTXBuffer" Destination="this.cSizeOfTXBuffer" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.sDisable" Destination="_base.sDisable" Vertices="(996,330),(824,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _TCPIP_SERVER

_ModBusTCPSLAVE : CLASS
: _TCPIP_SERVER
	TYPE
#pragma pack(push, 1)
	  _ONE_ENTRY : STRUCT  //! <Type Public="true" Comment="MODBUS parameter information" Name="_ONE_ENTRY"/>
	    udEntryNo : UDINT;  //! <Type Comment="number of entry" Name="_ONE_ENTRY.udEntryNo"/>
	    uiAddress : UINT;  //! <Type Comment="MODBUS address" Name="_ONE_ENTRY.uiAddress"/>
	    usReg : USINT;  //! <Type Comment="number of MODBUS register" Name="_ONE_ENTRY.usReg"/>
	    usAccess : USINT;  //! <Type Comment="access rights&#13;&#10;MB_READ_ONLY... read only&#13;&#10;MB_WRITE_ONLY ... write only&#13;&#10;MB_READ_WRITE ... read &amp; write" Name="_ONE_ENTRY.usAccess"/>
	    ptr : ^DINT;  //! <Type Comment="pointer to server or variable" Name="_ONE_ENTRY.ptr"/>
	    usType : USINT;  //! <Type Comment="type of entry&#13;&#10;MB_TYPE_SERVER ... server&#13;&#10;MB_TYPE_VARIABLE ... variable" Name="_ONE_ENTRY.usType"/>
	    dDataType : DINT;  //! <Type Comment="data type of entry&#13;&#10;MB_DAT_VAL ... value&#13;&#10;MB_DAT_STRING ... string" Name="_ONE_ENTRY.dDataType"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _ADDRESS_ENTRIES : STRUCT
	    udNo : UDINT;  //! <Type Comment="number of entries" Name="_ADDRESS_ENTRIES.udNo"/>
	    pEntries : ^_ONE_ENTRY;  //! <Type Comment="pointer to memory for MODBUS entries" Name="_ADDRESS_ENTRIES.pEntries"/>
	  END_STRUCT;
#pragma pack(pop)
	  _FSMParamSearch :
	  (
	    _GetParamAddress,
	    _GetRegisterCnt,
	    _GetAccessRights,
	    _GetPointer,
	    _AddParam
	  )$UDINT;
#pragma pack(push, 1)
	  _MB_REGISTER : STRUCT
	    usHighByte : USINT;  //! <Type Comment="higher byte" Name="_MB_REGISTER.usHighByte"/>
	    usLowByte : USINT;  //! <Type Comment="lower byte" Name="_MB_REGISTER.usLowByte"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _MBAP_HEADER : STRUCT
	    RegTrID : _MB_REGISTER;  //! <Type Comment="transaction identifier" Name="_MBAP_HEADER.RegTrID"/>
	    RegPrID : _MB_REGISTER;  //! <Type Comment="protokol identifier" Name="_MBAP_HEADER.RegPrID"/>
	    RegDataBytes : _MB_REGISTER;  //! <Type Comment="number of data bytes" Name="_MBAP_HEADER.RegDataBytes"/>
	    usUnID : USINT;  //! <Type Comment="unit identifier" Name="_MBAP_HEADER.usUnID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _REQUEST : STRUCT
	    MBAP_header : _MBAP_HEADER;  //! <Type Comment="MODBUS application header" Name="_REQUEST.MBAP_header"/>
	    usFunction : USINT;  //! <Type Comment="MODBUS function code" Name="_REQUEST.usFunction"/>
	    aData : _LONGSTRING;  //! <Type Comment="data buffer for request data" Name="_REQUEST.aData"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _RESPONSE : STRUCT
	    MBAP_header : _MBAP_HEADER;  //! <Type Comment="MODBUS application header" Name="_RESPONSE.MBAP_header"/>
	    usFunction : USINT;  //! <Type Comment="MODBUS function code" Name="_RESPONSE.usFunction"/>
	    aData : _LONGSTRING;  //! <Type Comment="data buffer for response data" Name="_RESPONSE.aData"/>
	  END_STRUCT;
#pragma pack(pop)
	  _USER_RETCODE :
	  (
	    USER_FAILED,
	    USER_IDIDIT
	  )$UDINT;
	END_TYPE
  //Servers:
	UseOffset 	: SvrCh_DINT;
	UseOffsInputReg 	: SvrCh_DINT;
  //Clients:
	cTable 	: CltCh_DINT;
	cTableInputReg 	: CltCh_DINT;
	cBufSize 	: CltCh_DINT;
	cBufSizeInputReg 	: CltCh_DINT;
	cFileOrTable 	: CltCh_DINT;
	coFileSys 	: CltChCmd__FileSys;
	to_AsciiBin 	: CltChCmd_ASCII_BIN;
	coString 	: CltChCmd_StringInternal;
	coStringInputReg 	: CltChCmd_StringInternal;
	StartAddrOffset 	: CltCh_DINT;
	StartAddrOffsInputReg 	: CltCh_DINT;
	cTurnBytes 	: CltCh_DINT;
	coSigCLib 	: CltChCmd_SigCLib;
	coSysMsg 	: CltChCmd__SysMsg;
	Config 	: CltCh_BDINT;
  //Variables:
		vAddrEntriesHolding 	: _ADDRESS_ENTRIES;			//! <Variable Comment="information of all MODBUS address entries type HOLDING register" Name="vAddrEntriesHolding"/>
		vAddrEntriesInput 	: _ADDRESS_ENTRIES;			//! <Variable Comment="information of all MODBUS address entries type INPUT register" Name="vAddrEntriesInput"/>
		NewStartAddr 	: UINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="This method prepares the response" Name="Response"/>
	FUNCTION VIRTUAL GLOBAL Response
		VAR_INPUT
			pData 	: ^void;			//! <Variable Comment="Pointer to Data" Name="Response.pData"/>
			udSize 	: UDINT;			//! <Variable Comment="Size of Data" Name="Response.udSize"/>
			dSock 	: DINT;			//! <Variable Comment="Socketnumber" Name="Response.dSock"/>
		END_VAR;
				//! <Function Comment="This function reads MODBUS Parameter from the ModBus_Parameters.csv-File" Name="ReadCSVFile"/>
	FUNCTION ReadCSVFile
		VAR_INPUT
			CsvType 	: DINT;			//! <Variable Comment="CSV file type&#13;&#10;0 = file for HOLDING registers&#13;&#10;1 = file for INPUT registers&#13;&#10;" Name="ReadCSVFile.CsvType"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="This function reads MODBUS parameter from table.&#13;&#10;A connection from the client cTable to a parameter table is needed." Name="ReadTable"/>
	FUNCTION ReadTable
		VAR_INPUT
			TabType 	: DINT;			//! <Variable Comment="table type&#13;&#10;0 = table for HOLDING registers&#13;&#10;1 = table for INPUT registers&#13;&#10;" Name="ReadTable.TabType"/>
		END_VAR;
				//! <Function Comment="This function sorts all MODBUS parameter entries by the MODBUS address" Name="SortEntries"/>
	FUNCTION SortEntries
		VAR_INPUT
			RegisterType 	: DINT;			//! <Variable Comment="register type&#13;&#10;0 = HOLDING registers&#13;&#10;1 = INPUT registers&#13;&#10;" Name="SortEntries.RegisterType"/>
		END_VAR;
				//! <Function Comment="This function searches through all MODBUS parameter entries and looks for &#13;&#10;some address entries" Name="CheckEntryError"/>
	FUNCTION CheckEntryError
		VAR_INPUT
			RegisterType 	: DINT;			//! <Variable Comment="register type&#13;&#10;0 = HOLDING registers&#13;&#10;1 = INPUT registers&#13;&#10;" Name="CheckEntryError.RegisterType"/>
		END_VAR
		VAR_OUTPUT
			bError 	: BOOL;
		END_VAR;
				//! <Function Comment="Init function for struct &quot;MODBUS parameter information&quot;&#13;&#10;This function sets all values in the structure &#13;&#10;for the MODBUS parameter information 0" Name="INIT_ENTRY"/>
	FUNCTION INIT_ENTRY
		VAR_INPUT
			ptr 	: ^_ONE_ENTRY;
		END_VAR;
				//! <Function Comment="Filter the ModBus Header out of the incoming Data" Name="Filter_MBAPHeader"/>
	FUNCTION Filter_MBAPHeader
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ReqStr 	: _REQUEST;
		END_VAR;
				//! <Function Comment="This function moves a MODBUS register to a 2 byte value" Name="Reg_to_UINT"/>
	FUNCTION Reg_to_UINT
		VAR_INPUT
			pRegister 	: ^_MB_REGISTER;
		END_VAR
		VAR_OUTPUT
			uiOutput 	: UINT;
		END_VAR;
				//! <Function Comment="Overwrite this function to create new MODBUS functions" Name="UserFunctions"/>
	FUNCTION VIRTUAL GLOBAL UserFunctions
		VAR_INPUT
			pRequest 	: ^_REQUEST;			//! <Variable Comment="Pointer to Request" Name="UserFunctions.pRequest"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: _USER_RETCODE;			//! <Variable Comment="USER_FAILED or USER_IDIDIT" Name="UserFunctions.dRetcode"/>
		END_VAR;
				//! <Function Comment="This function handles the actions for the MODBUS function &#13;&#10;&quot;READ MULTIPLE REGISTERS&quot;" Name="Read_Multiple_Registers"/>
	FUNCTION Read_Multiple_Registers
		VAR_INPUT
			RegisterType 	: DINT;
			strtaddr 	: UINT;			//! <Variable Comment="register type&#13;&#10;0 = HOLDING registers&#13;&#10;1 = INPUT registers&#13;&#10;" Name="Read_Multiple_Registers.strtaddr"/>
			regno 	: UINT;
			pdata 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
				//! <Function Comment="This function moves a 2 byte value to a MODBUS register" Name="UINT_to_Reg"/>
	FUNCTION UINT_to_Reg
		VAR_INPUT
			uiInput 	: DINT;
			pRegister 	: ^_MB_REGISTER;
		END_VAR;
				//! <Function Comment="This function handles the actions for the MODBUS function &#13;&#10;&quot;WRITE MULTIPLE REGISTERS&quot;" Name="Write_Multiple_Registers"/>
	FUNCTION Write_Multiple_Registers
		VAR_INPUT
			RegisterType 	: DINT;			//! <Variable Comment="register type&#13;&#10;0 = HOLDING registers&#13;&#10;1 = INPUT registers&#13;&#10;" Name="Write_Multiple_Registers.RegisterType"/>
			strtaddr 	: UINT;
			regno 	: UINT;
			pdata 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
				//! <Function Comment="This method searches for one parameter&#13;&#10;in the parameter list and gives back the pointer &#13;&#10;to its parameter information" Name="Search_Parameter"/>
	FUNCTION Search_Parameter
		VAR_INPUT
			RegisterType 	: DINT;			//! <Variable Comment="register type&#13;&#10;0 = HOLDING registers&#13;&#10;1 = INPUT registers&#13;&#10;" Name="Search_Parameter.RegisterType"/>
			address 	: UINT;
		END_VAR
		VAR_OUTPUT
			ppara 	: ^_ONE_ENTRY;
		END_VAR;
				//! <Function Comment="This function checks the request for errors" Name="Check_Request"/>
	FUNCTION VIRTUAL Check_Request
		VAR_INPUT
			ptr 	: ^_ONE_ENTRY;
			uiRegNo 	: UINT;
			usFunction 	: USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
				//! <Function Comment="This function reads the value from a server in application " Name="ReadServer"/>
	FUNCTION ReadServer
		VAR_INPUT
			ptr 	: ^_ONE_ENTRY;
			pdata 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
				//! <Function Comment="This function writes a value to a variable in the application" Name="WriteVariable"/>
	FUNCTION WriteVariable
		VAR_INPUT
			ptr 	: ^_ONE_ENTRY;
			pData 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
				//! <Function Comment="This function writes a value to a server in the application" Name="WriteServer"/>
	FUNCTION WriteServer
		VAR_INPUT
			ptr 	: ^_ONE_ENTRY;
			pdata 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
				//! <Function Comment="This function reads the value from a variable in application" Name="ReadVariable"/>
	FUNCTION ReadVariable
		VAR_INPUT
			ptr 	: ^_ONE_ENTRY;
			pData 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
				//! <Function Comment="This method turns the bytes of a 2 byte value&#13;&#10;&#13;&#10;0x1234 -&gt; 0x3412" Name="Turn_2_Bytes"/>
	FUNCTION Turn_2_Bytes
		VAR_INPUT
			iValue 	: UINT;
		END_VAR
		VAR_OUTPUT
			iRetVal 	: UINT;
		END_VAR;
				//! <Function Comment="This method turns the bytes of a 4 byte value&#13;&#10;&#13;&#10;0x12345678 -&gt; 0x78563412" Name="Turn_4_Bytes"/>
	FUNCTION Turn_4_Bytes
		VAR_INPUT
			udValue 	: UDINT;
		END_VAR
		VAR_OUTPUT
			udRetVal 	: UDINT;
		END_VAR;
				//! <Function Comment="Function to add one MODBUS parameter&#13;&#10;to the parameter list" Name="AddParameter"/>
	FUNCTION GLOBAL AddParameter
		VAR_INPUT
			uiAddress 	: UINT;			//! <Variable Comment="ModBus Address" Name="AddParameter.uiAddress"/>
			usRegisterNo 	: USINT;			//! <Variable Comment="Number of Registers" Name="AddParameter.usRegisterNo"/>
			usAccess 	: USINT;			//! <Variable Comment="Access-Level (Read/Write/ReadWrite)" Name="AddParameter.usAccess"/>
			usType 	: USINT;			//! <Variable Comment="1 .. Server&#13;&#10;2 .. Variable" Name="AddParameter.usType"/>
			usDataTyp 	: USINT;			//! <Variable Comment="1 .. MB_DAT_VAL   &#13;&#10;2 .. MB_DAT_STRING&#13;&#10;" Name="AddParameter.usDataTyp"/>
			ptr 	: ^void;			//! <Variable Comment="Pointer to Server or Variable" Name="AddParameter.ptr"/>
			RegisterType 	: DINT := 0;			//! <Variable Comment="register type&#13;&#10;0 = HOLDING registers&#13;&#10;1 = INPUT registers&#13;&#10;" Name="AddParameter.RegisterType"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="-1000 .. PARA_NOT_FOUND &#13;&#10;-1 ..... MB_ERR_ADD_PARA&#13;&#10;1 ...... MB_PARA_OK     &#13;&#10;" Name="AddParameter.retcode"/>
		END_VAR;
				//! <Function Comment="Method to add a list of parameters.&#13;&#10;One entry is of the structure-type _ONE_ENTRY.&#13;&#10;So the input-variable pData must contain the number of &#13;&#10;struct-entries the is given in the input-variable udEntryCount. " Name="AddParameterList"/>
	FUNCTION GLOBAL AddParameterList
		VAR_INPUT
			pData 	: ^void;			//! <Variable Comment="pointer to list of parameter-entries" Name="AddParameterList.pData"/>
			udEntryCount 	: UDINT;			//! <Variable Comment="number of parameters that are listed in pData" Name="AddParameterList.udEntryCount"/>
			RegisterType 	: DINT := 0;			//! <Variable Comment="register type&#13;&#10;0 = HOLDING registers&#13;&#10;1 = INPUT registers&#13;&#10;" Name="AddParameterList.RegisterType"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="-1000 .. PARA_NOT_FOUND &#13;&#10;-1 ..... MB_ERR_ADD_PARA&#13;&#10;1 ...... MB_PARA_OK     &#13;&#10;" Name="AddParameterList.retcode"/>
		END_VAR;
				//! <Function Comment="Function resets all parameter entries." Name="DeleteParameterEntries"/>
	FUNCTION GLOBAL DeleteParameterEntries
		VAR_INPUT
			RegisterType 	: DINT := 0;			//! <Variable Comment="register type&#13;&#10;0 = HOLDING registers&#13;&#10;1 = INPUT registers&#13;&#10;" Name="DeleteParameterEntries.RegisterType"/>
		END_VAR;
	
	FUNCTION VIRTUAL ReadFileParams
		VAR_INPUT
			CsvType 	: DINT;			//! <Variable Comment="CSV file type&#13;&#10;0 = file for HOLDING registers&#13;&#10;1 = file for INPUT registers&#13;&#10;" Name="ReadFileParams.CsvType"/>
			pData 	: ^CHAR;
			dDataLen 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL ExceptionLogging
		VAR_INPUT
			pRequest 	: ^_REQUEST;
			ExceptionCode 	: USINT;
		END_VAR;
	
	FUNCTION VIRTUAL ExceptionLoggingDetail
		VAR_INPUT
			pRequest 	: ^_REQUEST;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd _SysMsg
#pragma usingLtd ASCII_BIN
#pragma usingLtd SigCLib
#pragma usingLtd StringInternal


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _ModBusTCPSLAVE::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__MODBUSTCPSLAVE
1$UINT, 36$UINT, (SIZEOF(::_ModBusTCPSLAVE))$UINT, 
2$UINT, 15$UINT, 0$UINT, 
TO_UDINT(1436589033), "_ModBusTCPSLAVE", //Class
TO_UDINT(26234884), "_TCPIP_SERVER", 1$UINT, 38$UINT, //Baseclass
//Servers:
(::_ModBusTCPSLAVE.UseOffset.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(191238809), "UseOffset", 
(::_ModBusTCPSLAVE.UseOffsInputReg.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2769221167), "UseOffsInputReg", 
//Clients:
(::_ModBusTCPSLAVE.cTable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4283523978), "cTable", 
(::_ModBusTCPSLAVE.cTableInputReg.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2152439339), "cTableInputReg", 
(::_ModBusTCPSLAVE.cBufSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2051365976), "cBufSize", 
(::_ModBusTCPSLAVE.cBufSizeInputReg.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2065253790), "cBufSizeInputReg", 
(::_ModBusTCPSLAVE.cFileOrTable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(234583732), "cFileOrTable", 
(::_ModBusTCPSLAVE.coFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(940542775), "coFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::_ModBusTCPSLAVE.to_AsciiBin.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1866623137), "to_AsciiBin", TO_UDINT(2897291062), "ASCII_BIN", 1$UINT, 21$UINT, 
(::_ModBusTCPSLAVE.coString.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2952252283), "coString", TO_UDINT(2898603620), "StringInternal", 1$UINT, 85$UINT, 
(::_ModBusTCPSLAVE.coStringInputReg.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(815278798), "coStringInputReg", TO_UDINT(2898603620), "StringInternal", 1$UINT, 85$UINT, 
(::_ModBusTCPSLAVE.StartAddrOffset.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4245114328), "StartAddrOffset", 
(::_ModBusTCPSLAVE.StartAddrOffsInputReg.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3919243512), "StartAddrOffsInputReg", 
(::_ModBusTCPSLAVE.cTurnBytes.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2777210092), "cTurnBytes", 
(::_ModBusTCPSLAVE.coSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1750761597), "coSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 42$UINT, 
(::_ModBusTCPSLAVE.coSysMsg.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(398371951), "coSysMsg", TO_UDINT(792524216), "_SysMsg", 0$UINT, 0$UINT, 
(::_ModBusTCPSLAVE.Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(611510522), "Config", 
END_FUNCTION


#define USER_CNT__ModBusTCPSLAVE 15

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__ModBusTCPSLAVE] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _ModBusTCPSLAVE::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _TCPIP_SERVER::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _TCPIP_SERVER::sControl.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _TCPIP_SERVER::sControl.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__ModBusTCPSLAVE;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #Response();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #UserFunctions();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #Check_Request();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #ReadFileParams();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #ExceptionLogging();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #ExceptionLoggingDetail();

#pragma warning (default : 74)
	_TCPIP_SERVER::sControl.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _TCPIP_SERVER::sControl.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	UseOffset.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF UseOffset.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	UseOffsInputReg.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF UseOffsInputReg.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

// ****************************************************************************
// * ModBus TCP Slave                         		               	            *
// ****************************************************************************
// *							                                                            *
// *	Created: Sigmatek 10/2010 by KELSTE 			                              *
// *	Version: V1.00              					                                  *
// *                                                    					            *
// *	Changes: 						                                                    *
// *								                                                          *
// ****************************************************************************


FUNCTION VIRTUAL GLOBAL _ModBusTCPSLAVE::Init

  if (_firstscan) then
  
    _TCPIP_SERVER::Init();
  
    cBufSize          := cBufSize.Read();               // Read Clients
    cBufSizeInputReg := cBufSizeInputReg.Read();        // V.1.34
    cTurnBytes        := cTurnBytes.Read();
  
    //-----------------------------------------------------------------------------------------------------
    //  HOLDING-Registers   V.1.34
    //-----------------------------------------------------------------------------------------------------
    vAddrEntriesHolding.pEntries$^void := co_stdLib.Malloc(size := to_UDINT(cBufSize) * sizeof(_ONE_ENTRY));   // allocate memory for address entries
    if (vAddrEntriesHolding.pEntries = NIL) then                                                           // allocate memory failed ??
      TRACE("_ModBusTCPSLAVE : Allocate memory for HOLDING address entries failed !");                     // make trace entry
      sError := -99;                                                                                       // allocate Memory failed
    else
    
      if ((cFileOrTable and 16#01) = 0) then    // Read Modbus Parameters from csv-File
        ReadCSVFile(0);                         // read data from HOLDING csv-flie

      else                                      // Read Modbus Parameters from table
        if (ISCLIENTCONNECTED(#cTable)) then    // is parameter table connected ??
          ReadTable(0);                         // read data from HOLDING table
        end_if;
      end_if;

    end_if;
  
    //-----------------------------------------------------------------------------------------------------
    //  INPUT-Registers   V.1.34
    //-----------------------------------------------------------------------------------------------------
    vAddrEntriesInput.pEntries$^void := co_stdLib.Malloc(size := to_UDINT(cBufSizeInputReg) * sizeof(_ONE_ENTRY)); // allocate memory for address entries
    if (vAddrEntriesInput.pEntries = NIL) then                                                             // allocate memory failed ??
      TRACE("_ModBusTCPSLAVE : Allocate memory for input INPUT entries failed !");                         // make trace entry
      sError := -98;                                                                                       // allocate Memory failed
    else
    
      if ((cFileOrTable and 16#02) = 0) then            // Read Modbus Parameters from csv-File
        ReadCSVFile(1);                                 // read data from INPUT csv-flie
    
      else                                              // Read Modbus Parameters from table
        if (ISCLIENTCONNECTED(#cTableInputReg)) then   // is parameter table connected ??
          ReadTable(1);                                 // read data from INPUT table
        end_if;
      end_if;

    end_if;
    //-----------------------------------------------------------------------------------------------------

  end_if;


END_FUNCTION


FUNCTION _ModBusTCPSLAVE::ReadTable
	VAR_INPUT
		TabType 	: DINT;
	END_VAR
  VAR
    pTable      : ^USINT;
    udTabLen,
    udSearched,
    udStrLen    : UDINT;
    ptrSvrCh    : ^SvrCh;
    pEntry      : ^_ONE_ENTRY;
    doIt        : BOOL;
  END_VAR

  //----- Tab-type HOLDING registers  V.1.34 -----
  if (TabType = 0) then
    pTable := (cTable.Read())$^USINT;                                                 // get pointer to table
    pEntry$^void := vAddrEntriesHolding.pEntries;                                     // set pointer to memory
    vAddrEntriesHolding.udNo := 0;
  end_if;
  //----- Tab-type INPUT registers  V.1.34 -----
  if (TabType = 1) then
    pTable := (cTableInputReg.Read())$^USINT;                                         // get pointer to table
    pEntry$^void := vAddrEntriesInput.pEntries;                                       // set pointer to memory
    vAddrEntriesInput.udNo := 0;
  end_if;

  udTabLen   := pTable^$UDINT;                                                        // read length of the table
  pTable     += sizeof(UDINT);                                                        // set pointer to data
  udSearched := 0;

  while (udSearched < udTabLen) do                                                    // search trough the table
    
    doIt := FALSE;
    //----- Tab-type HOLDING registers  V.1.34 -----
    if (TabType = 0) then
      if (vAddrEntriesHolding.udNo < to_UDINT(cBufSize)) then                         // buffer isn't full ... just do it
        doIt := TRUE;
      end_if;
    end_if;
    //----- Tab-type INPUT registers  V.1.34 -----
    if (TabType = 1) then
      if (vAddrEntriesInput.udNo < to_UDINT(cBufSizeInputReg)) then                  // buffer isn't full ... just do it
        doIt := TRUE;
      end_if;
    end_if;
    
    if (doIt = TRUE) then
      
      pEntry^.usType := MB_TYPE_SERVER;
      pEntry^.dDataType := MB_DAT_VAL;

      //-------------------------------------------------------------
      // get MODBUS address
      //-------------------------------------------------------------
      pEntry^.uiAddress := pTable^$UINT;                                              // read MODBUS address from table

      //-------------------------------------------------------------
      // get number of MODBUS registers
      //-------------------------------------------------------------
      pTable += sizeof(UINT);                                                         // set pointer to the number of registers
      pEntry^.usReg := pTable^;                                                       // read the number of registers from table

      //-------------------------------------------------------------
      // get parameter access rights
      //-------------------------------------------------------------
      pTable += sizeof(USINT);                                                        // set pointer to access right
      pEntry^.usAccess := pTable^;                                                    // read the access right from the table
      //----- Tab-type INPUT registers  V.1.34 -----
      if (TabType = 1) then
        pEntry^.usAccess := MB_READ_ONLY;    // INPUT registers are READ_ONLY!
      end_if;

      //-------------------------------------------------------------
      // get pointer to server .. add entry
      //-------------------------------------------------------------
      pTable += sizeof(USINT);                                                        // set pointer to server name ("obj.svr")
      _LookUpEmbed_C(pTable, #ptrSvrCh, NIL);                                         // get pointer to server channel
      
      if (ptrSvrCh <> NIL) then
        pEntry^.ptr := ptrSvrCh$^DINT;                                                // add pointer to entry

        //----- Tab-type HOLDING registers  V.1.34 -----
        if (TabType = 0) then
          vAddrEntriesHolding.udNo += 1;                                              // increase the number of entries
          pEntry^.udEntryNo := vAddrEntriesHolding.udNo;                              // add actual number to entry
        end_if;
        //----- Tab-type INPUT registers  V.1.34 -----
        if (TabType = 1) then
          vAddrEntriesInput.udNo += 1;                                                // increase the number of entries
          pEntry^.udEntryNo := vAddrEntriesInput.udNo;                                // add actual number to entry
        end_if;

        pEntry += sizeof(_ONE_ENTRY);                                                 // set pointer to the next free space in memory
      end_if;
      
      udStrLen := _strlen(pTable);                                                    // read length of the server name
      pTable += (udStrLen + 1) * sizeof(CHAR);                                        // set pointer to to the next table entry
      udSearched += (udStrLen +1) * sizeof(CHAR) +2 * sizeof(USINT) + sizeof(UINT);   // increase table counter
      
//  spimar 4.2.13 - Rev. 1.5      
//      INIT_ENTRY(ptr := pEntry);                                                    // clear the next entry space in allocated memory 
    else
      sError := -1;
      return;

    end_if;
  end_while;

  //----- Tab-type HOLDING registers  V.1.34 -----
  if (TabType = 0) then
    if (vAddrEntriesHolding.udNo > 0) then                                            // if there is more than one Entry, sort them
      SortEntries(TabType);
    end_if;
  end_if;
  //----- Tab-type INPUT registers  V.1.34 -----
  if (TabType = 1) then
    if (vAddrEntriesInput.udNo > 0) then                                              // if there is more than one Entry, sort them
      SortEntries(TabType);
    end_if;
  end_if;


END_FUNCTION


FUNCTION _ModBusTCPSLAVE::INIT_ENTRY
  VAR_INPUT
    ptr 	: ^_ONE_ENTRY;
  END_VAR

  // clear struct of one parameter entry
  
  ptr^.ptr       := NIL;
  ptr^.uiAddress := 0x0000;
  ptr^.usAccess  := 0x0000;
  ptr^.usReg     := 0x00;

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::SortEntries
	VAR_INPUT
		RegisterType 	: DINT;
	END_VAR
  VAR
    tmpentry    : _ONE_ENTRY;
    i,j         : UDINT;
    ptr, hptr   : ^_ONE_ENTRY;
    myNo        : UDINT;
    myPtr       : ^_ONE_ENTRY;
  END_VAR

  //----- type HOLDING registers  V.1.34 -----
  if (RegisterType = 0) then
    myNo  := vAddrEntriesHolding.udNo;
    myPtr := vAddrEntriesHolding.pEntries;
  end_if;
  //----- type INPUT registers  V.1.34 -----
  if (RegisterType = 1) then
    myNo  := vAddrEntriesInput.udNo;
    myPtr := vAddrEntriesInput.pEntries;
  end_if;


  for i:=(myNo -1) to (1) by -1 do
  
#pragma warning(disable: 74);
    j := i;
#pragma warning(default: 74);

    ptr := myPtr;

    for j:=1 to (i) do
      
      hptr := ptr + sizeof(_ONE_ENTRY);
      
      if (ptr^.uiAddress > hptr^.uiAddress) then
       
        _memcpy(#tmpentry, ptr, sizeof(_ONE_ENTRY));            // copy the entry into the temporary buffer
        _memcpy(ptr, hptr, sizeof(_ONE_ENTRY));                 // copy the next entry into the memory of this entry
        _memcpy(hptr, #tmpentry, sizeof(_ONE_ENTRY));           // copy the entry from temporary buffer into the memory of the next entry
     
     end_if;
     
     ptr += sizeof(_ONE_ENTRY);                                
    
    end_for;
  
  end_for;
  
  //----- type HOLDING registers  V.1.34 -----
  if (RegisterType = 0) then
    myNo := vAddrEntriesHolding.udNo;
    ptr  := vAddrEntriesHolding.pEntries;
  end_if;
  //----- type INPUT registers  V.1.34 -----
  if (RegisterType = 1) then
    myNo := vAddrEntriesInput.udNo;
    ptr  := vAddrEntriesInput.pEntries;
  end_if;
  
  for i:=1 to (myNo) do
    
    ptr^.udEntryNo := i;
    ptr += sizeof(_ONE_ENTRY);
  
  end_for;
  
  CheckEntryError(RegisterType);
  
END_FUNCTION


FUNCTION _ModBusTCPSLAVE::CheckEntryError
	VAR_INPUT
		RegisterType 	: DINT;
	END_VAR
	VAR_OUTPUT
		bError 	: BOOL;
	END_VAR
  VAR
    ptr, hptr   : ^_ONE_ENTRY;
    i           : UDINT;
    myNo        : UDINT;
  END_VAR

  bError := false;                                                      // init retcode

  //----- type HOLDING registers  V.1.34 -----
  if (RegisterType = 0) then
    myNo := vAddrEntriesHolding.udNo;
    ptr  := vAddrEntriesHolding.pEntries;
  end_if;
  //----- type INPUT registers  V.1.34 -----
  if (RegisterType = 1) then
    myNo := vAddrEntriesInput.udNo;
    ptr  := vAddrEntriesInput.pEntries;
  end_if;

  if (myNo > 1) then                                                    // only if there are more than one parameter entries available

    for i:=0 to (myNo -2) do                                            // search through all entries
      hptr := ptr + sizeof(_ONE_ENTRY);                                 // set help pointer to the next parameter entry
      if ((ptr^.uiAddress + ptr^.usReg) > hptr^.uiAddress) then         // look for an address error
        bError := true;                                                 // if error occurred -> set retcode to error
        TRACE("ModBusTCPServer_New::CheckEntryError: address error!");
      end_if;
      ptr += sizeof(_ONE_ENTRY);                                        // set pointer to the next parameter entry
    end_for;

  end_if;

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::ReadCSVFile
	VAR_INPUT
		CsvType 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    pMem        : ^void;
    dFileHandle : DINT;
    dFilesize   : DINT;
    udRetcode   : UDINT;
    udStrLen    : UDINT;
    szFileName  : ARRAY [0..127] OF CHAR;
    bGetName    : BOOL;
  END_VAR

  retcode := -1;
  bGetName := false;

  //----- CSV-type HOLDING registers  V.1.34 -----
  if (CsvType = 0) then
    // --- Hubchr v1.33 if string object does not contain a dpne, we use the Standardpath now.
    if (IsClientConnected(#coString) = true) then    // a string object is connected
      udStrLen := coString.GetLength() + 1;          // If we read length+1 we always get a 0-Termination!
      if ((udStrLen > 4) & (udStrLen <= 127)) then   // check if string is longer than 4 (at least "C:\a" and shorter than the array (this is the size INCLUDING the terminating 0).
        coString.GetDataAt(pData := #szFileName[0], udSize := udStrLen, udAt := 0); // read the data, including the terminating 0.
        bGetName := true;                            // we successfully received a name -> set flag.
      else
        // do nothing, bGetName stays false so the standardpath is used.
      end_if;
    end_if;
    // --- End Hubchr v1.33
  end_if;

  //----- CSV-type INPUT registers  V.1.34 -----
  if (CsvType = 1) then
    // --- Hubchr v1.33 if string object does not contain a dpne, we use the Standardpath now.
    if (IsClientConnected(#coStringInputReg) = true) then  // a string object is connected
      udStrLen := coStringInputReg.GetLength() + 1;        // If we read length+1 we always get a 0-Termination!
      if ((udStrLen > 4) & (udStrLen <= 127)) then          // check if string is longer than 4 (at least "C:\a" and shorter than the array (this is the size INCLUDING the terminating 0).
        coStringInputReg.GetDataAt(pData := #szFileName[0], udSize := udStrLen, udAt := 0); // read the data, including the terminating 0.
        bGetName := true;                            // we successfully received a name -> set flag.
      else
        // do nothing, bGetName stays false so the standardpath is used.
      end_if;
    end_if;
    // --- End Hubchr v1.33
  end_if;

 
  if (bGetName = false) then                              // if no Filename is found, search for Modbus_Parameters.csv

    //----- CSV-type HOLDING registers  V.1.34 -----
    if (CsvType = 0) then
      _strcpy(dest := #szFileName[0], src := "C:\Modbus_Parameters.csv");
      bGetName := true;
    end_if;
    //----- CSV-type INPUT registers  V.1.34 -----
    if (CsvType = 1) then
      _strcpy(dest := #szFileName[0], src := "C:\Modbus_ParametersInput.csv");
      bGetName := true;
    end_if;

  end_if;


  if (bGetName = true) then
    dFileHandle := coFileSys.FileOpen(filename:= #szFileName[0], attributes:= ATT_READ_ONLY);  // open File
    if (dFileHandle >= 0) then
      dFilesize  := coFileSys.FileLength(handle:= dFileHandle);
      pMem := co_StdLib.Malloc(size:=(dFileSize + 1)$UDINT);    // allocate Cache
      if (pMem <> NIL) then
        (pMem + dFileSize)^ := 0;
        udRetcode := coFileSys.FileRead(handle:=dFileHandle, buffer:=pMem, length:=dFilesize$UDINT);   // copy Data from File
        if (udRetcode) then
          ReadFileParams(CsvType, pData:=pMem$^CHAR, dDataLen:=dFilesize); // add Parameters
          retcode := 0;
        end_if;
        co_StdLib.Free(mptr:=pMem);                 // give Cache free
      end_if;
      coFileSys.FileClose(handle:=dFileHandle);     // close File

    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL _ModBusTCPSLAVE::ReadFileParams
	VAR_INPUT
		CsvType 	: DINT;
		pData 	  : ^CHAR;
		dDataLen 	: DINT;
	END_VAR
  VAR
    dSearched       : DINT;
    pActLine        : ^CHAR;
    pNextLine       : ^CHAR;
    pSearch         : ^CHAR;
    udStrLen        : UDINT;
    FSMParamSearch  : _FSMParamSearch;
    uiAddress       : UINT;
    usRegisterCnt   : USINT;
    biFormat        : BINT;
    usParamAccess     : USINT;
    pServer         : ^void;
    pParam          : ^_ONE_ENTRY;
  END_VAR

  if (pData = NIL) then
    return;
  end_if;

  biFormat := 0x0800;

  dSearched := 0;
  pActLine := pData;
  
  //----- CSV-type HOLDING registers  V.1.34 -----
  if (CsvType = 0) then
    pParam := vAddrEntriesHolding.pEntries + vAddrEntriesHolding.udNo;
  end_if;

  //----- CSV-type INPUT registers  V.1.34 -----
  if (CsvType = 1) then
    pParam := vAddrEntriesInput.pEntries + vAddrEntriesInput.udNo;
  end_if;

  // search line after line and copy Parameters into Puffer
  while (dSearched < dDataLen) do
    pSearch := _strchr(src:=pActLine, chr:=0x0D);
    if (pSearch <> NIL) then
      pSearch^  := 0x00;
      pSearch   += sizeof(CHAR);
      dSearched += sizeof(CHAR);
      if (pSearch^ = 0x0A) then
        pSearch   += sizeof(CHAR);
        dSearched += sizeof(CHAR);
      end_if;
      pNextLine := pSearch;
      udStrLen  := _strlen(src := pActLine);
      dSearched += (udStrLen * sizeof(CHAR))$DINT;

      FSMParamSearch := _GetParamAddress;

      while (pActLine$UDINT < pNextLine$UDINT) do

        case FSMParamSearch of

          //=======================================================================================
          _GetParamAddress, _GetRegisterCnt, _GetAccessRights:
          //=======================================================================================
            pSearch := _strchr(src:=pActLine, chr:=0x3B);
            if (pSearch <> NIL) then
              pSearch^ := 0x00;
              udStrLen := _strlen(src:=pActLine);
              
              case FSMParamSearch of

                //---------------------------------------------------------------------------------
                _GetParamAddress:
                //---------------------------------------------------------------------------------
                  uiAddress := (to_AsciiBin.Ascii2Bin(pta:=pActLine, ptb:=#biFormat))$UINT;      // copy Startaddress
                  FSMParamSearch := _GetRegisterCnt;

                //---------------------------------------------------------------------------------
                _GetRegisterCnt:
                //---------------------------------------------------------------------------------
                  usRegisterCnt := (to_AsciiBin.Ascii2Bin(pta:=pActLine, ptb:=#biFormat))$USINT;  // copy No of Registers
                  FSMParamSearch := _GetAccessRights;

                //---------------------------------------------------------------------------------
                _GetAccessRights:
                //---------------------------------------------------------------------------------
                  usParamAccess := (to_AsciiBin.Ascii2Bin(pta:=pActLine, ptb:=#biFormat))$USINT;  // copy Access-Right
                  //----- CSV-type INPUT registers  V.1.34 -----
                  if (CsvType = 1) then
                    usParamAccess := MB_READ_ONLY;    // INPUT registers are READ_ONLY!
                  end_if;
                  
                  if ((usParamAccess = MB_READ_ONLY) | (usParamAccess = MB_WRITE_ONLY) | (usParamAccess = MB_READ_WRITE)) then  // ckeck Access-Rights
                    FSMParamSearch := _GetPointer;
                  else  
                    exit;
                  end_if;

              end_case;

              pActLine += (udStrLen + 1) * sizeof(CHAR);

            else
              exit;
            end_if;

          //=======================================================================================
          _GetPointer:
          //=======================================================================================
            _LookUpEmbed_C(pText:=pActLine, pObj_ch:=#pServer, pObj:=NIL);

            if (pServer <> NIL) then
              FSMParamSearch := _AddParam;
            else
              exit;
            end_if;

          //=======================================================================================
          _AddParam:
          //=======================================================================================
            INIT_ENTRY(ptr:=pParam);
            
            // copy Parameter into Puffer
            pParam^.uiAddress := uiAddress;
            pParam^.usReg     := usRegisterCnt;
            pParam^.usAccess  := usParamAccess;
            pParam^.ptr       := pServer$^DINT;
            pParam^.usType    := MB_TYPE_SERVER;
            pParam^.dDataType := MB_DAT_VAL;
            
            //----- CSV-type HOLDING registers  V.1.34 -----
            if (CsvType = 0) then
              vAddrEntriesHolding.udNo += 1;
    
              if (vAddrEntriesHolding.udNo < cBufSize$UDINT) then
                pParam += sizeof(_ONE_ENTRY);
              else
                return;
              end_if;
            end_if;

            //----- CSV-type INPUT registers  V.1.34 -----
            if (CsvType = 1) then
              vAddrEntriesInput.udNo += 1;
    
              if (vAddrEntriesInput.udNo < cBufSizeInputReg$UDINT) then
                pParam += sizeof(_ONE_ENTRY);
              else
                return;
              end_if;
            end_if;

            exit;
        end_case;

      end_while;
      pActLine := pNextLine;
      
    // --- HubChr v1.33 infinite loop in case a wrong file was assigned (file not containing a ';').
    elsif (pActLine = pNextLine) then // this means we are at the last line and did not find a ';'.
      exit;
    end_if;
    // --- End HubChr v1.33
  end_while;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _ModBusTCPSLAVE::Response
  VAR_INPUT
    pData 	: ^void;
    udSize 	: UDINT;
    dSock 	: DINT;
  END_VAR
  VAR
    aResponse       : ARRAY [0..260] OF USINT;
    pResponse       : ^_RESPONSE;
    uiDataSize      : UINT;
    uiRDStartAddr   : UINT;
    uiRDRegNum      : UINT;
    uiWRStartAddr   : UINT;
    uiWRRegNum      : UINT;
    aRespData       : ARRAY [0..260] OF USINT;
    bErrInReq       : BOOL;
    usErrCode       : USINT;
    dRet            : _USER_RETCODE;
    pRequest        : ^_REQUEST;
    ReqStr          : _REQUEST;
    dRetcode        : DINT;
  END_VAR

  if (udSize < 8) then                                                                        // If Message too short fpr a ModBus-Message, return 
    sError := -14;
    return;
  end_if;

  if (udSize > 260) then                                                                      //  If Message too long for a ModBus-Message, return
    sError := -16;
    return;

  end_if;

  ReqStr := Filter_MBAPHeader(pData:= pData, udSize:= udSize);                                // Filter the MBAP Header out of Data
  
  if ((ReqStr.MBAP_header.RegDataBytes.usLowByte + 0x06) <> udSize) then                      // check if send Data is equal with specified Data
    sError := -15;
    return;
  end_if;

  
  pRequest := #ReqStr;                                                                        // Set the Pointer to RequestRegister

  bErrInReq := false;                                                                         // init exeption flag
  usErrCode := NO_ERROR;                                                                      // init MODBUS exeption code
  dRet := UserFunctions(pRequest := pRequest);                                                // call user function

  if (dRet = USER_FAILED) then

    case pRequest^.usFunction of

      //===========================================================================================
      // MODBUS function: read multiple HOLDING registers
      //===========================================================================================
      MB_FUNC_RD_MULTIPLE_REG:

        uiDataSize := Reg_to_UINT(pRegister:=#pRequest^.MBAP_header.RegDataBytes);            // get the number of data bytes from MBAP header
        uiRDStartAddr := Reg_to_UINT(pRegister:=(#pRequest^.aData[0])$^_MB_REGISTER);         // get the start address of the registers to read

        case UseOffset of

          //====================================================================================
          //  no offset usage
          //  the incomming address would be used
          //------------------------------------------------------------------------------------
          0:
            NewStartAddr := uiRDStartAddr; //  restore original start address

          //====================================================================================
          //  Fix mode
          //  the offset, defined on client, would be subtracted from the incomming address
          //====================================================================================
          1:
            StartAddrOffset := StartAddrOffset.Read();
            if (NewStartAddr <> (uiRDStartAddr - StartAddrOffset)) then   // add offset only one time
              NewStartAddr := uiRDStartAddr;                              // store original start address
              NewStartAddr -= StartAddrOffset$UINT;                       // add offset
            end_if;

          //====================================================================================
          //  Automatic mode
          //  the offset, defined on client, would be subtracted from incomming address
          //  if the incomming address is greater than the defined offset check
          //====================================================================================
          2:
            StartAddrOffset := StartAddrOffset.Read();
            if (uiRDStartAddr > MB_OFFSET_CHECK) then
              NewStartAddr := uiRDStartAddr;
              NewStartAddr -= StartAddrOffset$UINT;
            else
              NewStartAddr := uiRDStartAddr;
            end_if;

          //====================================================================================
        end_case;

        uiRDRegNum := Reg_to_UINT(pRegister:=(#pRequest^.aData[2])$^_MB_REGISTER);            // get the number of MODBUS registers

        usErrCode := Read_Multiple_Registers(RegisterType := 0,                               // call function to construct the response  V.1.34
                                             strtaddr := NewStartAddr,                        
                                             regno := uiRDRegNum,                             // with the given information from the request
                                             pdata := #aRespData[0]);

        if (usErrCode = 0x00) then                                                            // no error occurred?
          pResponse := (#aResponse[0])$^_RESPONSE;                                            // set pointer to the response string to fill the STRUCT with data
          _memcpy(pResponse, pRequest, 0x08);                                                 // copy the MBAP header from the reqest into the response
          UINT_to_Reg(uiInput := 0x03 + (uiRDRegNum * 0x02),                                  // set the number of bytes into the MBAP header of the response
                      pRegister := #pResponse^.MBAP_header.RegDataBytes);
          pResponse^.aData[0] := to_USINT(uiRDRegNum * 2);                                    // set the number of response data bytes (without MBAP header)
          _memcpy(#pResponse^.aData[1], #aRespData[0], uiRDRegNum * 2);                       // copy the response data into the response string
        
          dRetcode := SendData(pData:=pResponse, udSize:=0x09 + uiRDRegNum*2, dSock:=dSock, bDirect:=0);
                               
          if (dRetcode < 0) then
            sError := dRetcode;
          end_if;

        else                                                                                  // error occurred ?
          bErrInReq := true;                                                                  // set flag to send an exeption response
        end_if;


      //===========================================================================================
      // MODBUS function: read multiple INPUT registers
      //===========================================================================================
      MB_FUNC_RD_MULTIPLE_INPUT_REG: 

        uiDataSize := Reg_to_UINT(pRegister:=#pRequest^.MBAP_header.RegDataBytes);            // get the number of data bytes from MBAP header
        uiRDStartAddr := Reg_to_UINT(pRegister:=(#pRequest^.aData[0])$^_MB_REGISTER);         // get the start address of the registers to read

        case UseOffsInputReg of

          //====================================================================================
          //  no offset usage
          //  the incomming address would be used
          //------------------------------------------------------------------------------------
          0:
            NewStartAddr := uiRDStartAddr; //  restore original start address

          //====================================================================================
          //  Fix mode
          //  the offset, defined on client, would be subtracted from the incomming address
          //====================================================================================
          1:
            StartAddrOffsInputReg := StartAddrOffsInputReg.Read();
            if (NewStartAddr <> (uiRDStartAddr - StartAddrOffsInputReg)) then // add offset only one time
              NewStartAddr := uiRDStartAddr;                                  // store original start address
              NewStartAddr -= StartAddrOffsInputReg$UINT;                     // add offset
            end_if;

          //====================================================================================
          //  Automatic mode
          //  the offset, defined on client, would be subtracted from incomming address
          //  if the incomming address is greater than the defined offset check
          //====================================================================================
          2:
            StartAddrOffsInputReg := StartAddrOffsInputReg.Read();
            if (uiRDStartAddr > MB_OFFSET_CHECK) then
              NewStartAddr := uiRDStartAddr;
              NewStartAddr -= StartAddrOffsInputReg$UINT;
            else
              NewStartAddr := uiRDStartAddr;
            end_if;

          //====================================================================================
        end_case;

        uiRDRegNum := Reg_to_UINT(pRegister:=(#pRequest^.aData[2])$^_MB_REGISTER);            // get the number of MODBUS registers

        usErrCode := Read_Multiple_Registers(RegisterType := 1,                               // call function to construct the response  V.1.34
                                             strtaddr := NewStartAddr,                        
                                             regno := uiRDRegNum,                             // with the given information from the request
                                             pdata := #aRespData[0]);

        if (usErrCode = 0x00) then                                                            // no error occurred?
          pResponse := (#aResponse[0])$^_RESPONSE;                                            // set pointer to the response string to fill the STRUCT with data
          _memcpy(pResponse, pRequest, 0x08);                                                 // copy the MBAP header from the reqest into the response
          UINT_to_Reg(uiInput := 0x03 + (uiRDRegNum * 0x02),                                  // set the number of bytes into the MBAP header of the response
                      pRegister := #pResponse^.MBAP_header.RegDataBytes);
          pResponse^.aData[0] := to_USINT(uiRDRegNum * 2);                                    // set the number of response data bytes (without MBAP header)
          _memcpy(#pResponse^.aData[1], #aRespData[0], uiRDRegNum * 2);                       // copy the response data into the response string
        
          dRetcode := SendData(pData:=pResponse, udSize:=0x09 + uiRDRegNum*2, dSock:=dSock, bDirect:=0);
                               
          if (dRetcode < 0) then
            sError := dRetcode;
          end_if;

        else                                                                                  // error occurred ?
          bErrInReq := true;                                                                  // set flag to send an exeption response
        end_if;


      //===========================================================================================
      // MODBUS function: write multiple HOLDING registers
      //===========================================================================================
      MB_FUNC_WR_MULTIPLE_REG: 

        uiDataSize := Reg_to_UINT(pRegister:=#pRequest^.MBAP_header.RegDataBytes);                // get the number of data bytes from MBAP header
        uiWRStartAddr := Reg_to_UINT(pRegister:=(#pRequest^.aData[0])$^_MB_REGISTER);             // get the start address of the registers to read

        case UseOffset of

          //====================================================================================
          //  no offset useage
          //  the incomming address would be used
          //------------------------------------------------------------------------------------
          0:
            NewStartAddr := uiWRStartAddr; //  restore original start address

          //====================================================================================
          //  ***  Fix mode  ***
          //  the offset, defined on client, would be subtracted from the incomming address
          //------------------------------------------------------------------------------------
          1:
            StartAddrOffset := StartAddrOffset.Read();
            if (NewStartAddr <> (uiWRStartAddr - StartAddrOffset)) then   // add offset only one time
              NewStartAddr := uiWRStartAddr;                              // store original start address
              NewStartAddr -= StartAddrOffset$UINT;                       // add offset

            end_if;

          //====================================================================================
          //  ***  Automatic mode  ***
          //  the offset, defined on client, would be subtracted from incomming address
          //  if the incomming address is greater than the defined offset check
          //------------------------------------------------------------------------------------
          2:
            StartAddrOffset := StartAddrOffset.Read();
            if (uiWRStartAddr > MB_OFFSET_CHECK) then
              NewStartAddr := uiWRStartAddr;
              NewStartAddr -= StartAddrOffset$UINT;
            else
              NewStartAddr := uiWRStartAddr;
            end_if;

          //====================================================================================

        end_case;

        uiWRRegNum := Reg_to_UINT(pRegister:=(#pRequest^.aData[2])$^_MB_REGISTER);               // get the number of MODBUS registers

        usErrCode := Write_Multiple_Registers(RegisterType := 0,                                 // call function to construct the response 
                                              strtaddr := NewStartAddr,
                                              regno := uiWRRegNum,                               // with the given information from the request
                                              pdata := #pRequest^.aData[5]);

        if (usErrCode = 0x00) then                                                               // no error occurred ?
          pResponse := (#aResponse[0])$^_RESPONSE;                                               // set pointer to the response string to fill the STRUCT with data
          _memcpy(pResponse, pRequest, 12);                                                      // copy the first 12 bytes from the request into the response
          UINT_to_Reg(uiInput:=6$UINT, pRegister:=#pResponse^.MBAP_header.RegDataBytes);         // set the number of bytes into the MBAP header of the response
        
          dRetcode := SendData(pData:=pResponse, udSize:=12, dSock:=dSock, bDirect:=0);
                                 
          if (dRetcode < 0) then
            sError := dRetcode;
          end_if;
            
      else                                                                                       // error occurred ?
        bErrInReq := true;                                                                       // set flag to send an exeption response
      end_if;


    else
      //===========================================================================================
      // invalid MODBUS function in request
      //===========================================================================================
      bErrInReq := true;                                                                         // set flag to send an exeption response
      usErrCode := INVALID_FUNC;                                                                 // set exeption code for invalid function

      //===========================================================================================

    end_case;

  end_if;
  
  if (bErrInReq = true) then                                                                     // error occurred ?

    //=====================================================
    //  MODBUS Exeption Codes
    //
    //  0x01 ... illegal function
    //  0x02 ... illegal data address
    //  0x03 ... illegal data value
    //  0x04 ... slave device error
    //=====================================================

    _memcpy(#aResponse[0], pRequest, 8);                                                         // copy 0x08 byte from the request into the response
    aResponse[4]$UINT := Turn_2_Bytes(0x0003);
    aResponse[7]      := aResponse[7] + 0x80;                                                    // add 0x80 to the MODBUS function (signs error)
    aResponse[8]      := usErrCode;                                                              // add the exeption code to the response
    
    dRetcode := SendData(pData:=#aResponse[0], udSize:=0x09, dSock:=dSock, bDirect:=0);

    if (dRetcode < 0) then
      sError := dRetcode;
    end_if;

    Config := Config.Read();
    if (Config.1 = true) then
      ExceptionLogging(pRequest, usErrCode);
    end_if;

  end_if;

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::Filter_MBAPHeader
  VAR_INPUT
    pData 	: ^void;
    udSize 	: UDINT;
  END_VAR
  VAR_OUTPUT
    ReqStr 	: _REQUEST;
  END_VAR

  _memset(dest:= #ReqStr, usByte:= 0, cntr:= sizeof(ReqStr));                                   // clear Data Buffer
  
  _memcpy(ptr1:= #ReqStr, ptr2:= pData, cntr:= 7);                                              // Copy the first 7 Byte (MBAO Header)
  
  pData += 7;                                                                                   // Set Pointer to next 7 Bytes
  
//  uiBytes := Reg_to_UINT(pRegister:= #ReqStr.MBAP_header.RegDataBytes) - 1;                     // turn bytes (because of MODBUS protocol)
  
  _memcpy(ptr1:= #ReqStr.usFunction, ptr2:= pData, cntr:= (udSize - 7));                        // Copy the function and the data

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::Reg_to_UINT
  VAR_INPUT
    pRegister 	: ^_MB_REGISTER;
  END_VAR
  VAR_OUTPUT
    uiOutput 	: UINT;
  END_VAR

  // convert a MODBUS register into a UINT value
  uiOutput := 0x0000;
  uiOutput := (uiOutput) OR (pRegister^.usHighByte SHL 8);
  uiOutput := uiOutput OR pRegister^.usLowByte;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _ModBusTCPSLAVE::UserFunctions
#pragma warning(disable: 73 );
  VAR_INPUT
    pRequest 	: ^_REQUEST;
  END_VAR
#pragma warning(default: 73 );
  VAR_OUTPUT
    dRetcode 	: _USER_RETCODE;
  END_VAR

  dRetcode := USER_FAILED;

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::Read_Multiple_Registers
	VAR_INPUT
		RegisterType 	: DINT;
		strtaddr 	: UINT;
		regno 	: UINT;
		pdata 	: ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: USINT;
	END_VAR
  VAR
    ptr       : ^_ONE_ENTRY;
    hpdata    : ^void;
    uiRegSrc  : UINT;
    usBytes   : USINT;
    tmpFunc   : USINT;
  END_VAR

  if (pData = NIL) then                                               // invalid pointer?
    retcode := 0x04;                                                  // set error code ... slave device error
    return;                                                           // exit function because we do not handle with NILpointer
  end_if;

  if ((regno >= 0x0001) & (regno <= 0x007D)) then
    ptr := Search_Parameter(RegisterType, strtaddr);                  // find parameter with given MODBUS address in entry buffer
    if (ptr <> NIL) then                                              // is pointer valid / parameter found ?
      if (RegisterType = 0) then
        tmpFunc := MB_FUNC_RD_MULTIPLE_REG;
      else
        tmpFunc := MB_FUNC_RD_MULTIPLE_INPUT_REG;
      end_if;
      retcode := Check_Request(ptr        := ptr,                     // check if Response is valid
                               uiRegNo    := regno,
                               usFunction := tmpFunc);
      
      if (retcode = 0x00) then                                        // is request valid?
        hpdata := pdata;                                              // set pointer to the first byte of response buffer
        uiRegSrc := 0;                                                // init register counter
        while (uiRegSrc < regno) do                                   // search until number of registers is reached
          
          case ptr^.usType of
            //=======================================================
            // lasal class server
            //=======================================================
            MB_TYPE_SERVER:
              usBytes := ReadServer(ptr:=ptr, pdata:=hpdata);         // read value of server
              hpdata += usBytes;                                      // set pointer to the next free space of response data
              uiRegSrc += ptr^.usReg;                                 // increase number of read registers
              
            //=======================================================
            // data element (variable)
            //=======================================================
            MB_TYPE_VARIABLE: 
              usBytes := ReadVariable(ptr:=ptr, pData:=hpdata);       // read value of variable
              hpdata += usBytes;                                      // set pointer to the next free space of response data
              uiRegSrc += ptr^.usReg;                                 // increase number of read registers
              
            //=======================================================
          end_case;
          ptr += sizeof(_ONE_ENTRY);                                  // set pointer to next entry
        end_while;
      end_if;
    else
      retcode := 0x02;                                                // set error code ... illegal data address
    end_if;
  else
    retcode := 0x03;                                                  // set error code ... illegal data value
  end_if;

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::UINT_to_Reg
  VAR_INPUT
    uiInput 	: DINT;
    pRegister 	: ^_MB_REGISTER;
  END_VAR

  pRegister^.usHighByte := ((uiInput SHR 8) AND 16#00FF)$USINT;       // turn bytes and write into register
  pRegister^.usLowByte  := (uiInput AND 16#00FF)$USINT;

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::Write_Multiple_Registers
	VAR_INPUT
		RegisterType 	: DINT;
		strtaddr 	: UINT;
		regno 	: UINT;
		pdata 	: ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: USINT;
	END_VAR
  VAR
    ptr       : ^_ONE_ENTRY;
    hpdata    : ^void;
    uiRegSrc  : UINT;
    usBytes   : USINT;
  END_VAR

  if (pData = NIL) then                                               // invalid pointer?
    retcode := 0x04;                                                  // set error code ... slave device error
    return;                                                           // exit function because we do not handle with NILpointer
  end_if;

  if ((regno >= 0x0001) & (regno <= 0x007B)) then
    ptr := Search_Parameter(RegisterType, strtaddr);                  // find parameter in entry buffer
    if (ptr <> NIL) then                                              // is pointer valid / parameter found ?
      retcode := Check_Request(ptr := ptr,                            // check if Response is valid
                               uiRegNo := regno,
                               usFunction := 0x10);
      
      if (retcode = 0x00) then                                        // valid request?
        hpdata := pdata;                                              // set pointer to the first value to write
        uiRegSrc := 0;                                                // init register counter
        while (uiRegSrc < regno) do                                   // search until the number of registers is reached
          
          case ptr^.usType of
            
            //=======================================================
            // lasal class server
            //=======================================================
            MB_TYPE_SERVER: 
              usBytes := WriteServer(ptr := ptr, pdata := hpdata);    // write value to server
              hpdata += usBytes;                                      // set pointer to the next value to write
              uiRegSrc += ptr^.usReg;                                 // increase the number of registers
              
            //=======================================================
            // data element (variable)
            //=======================================================
            MB_TYPE_VARIABLE: 
              usBytes := WriteVariable(ptr := ptr, pData := hpdata);  // write value to variable
              hpdata += usBytes;                                      // set pointer to the next value to write
              uiRegSrc += ptr^.usReg;                                 // increase the number of registers
              
            //=======================================================
          end_case;
          ptr += sizeof(_ONE_ENTRY);                                  // set pointer to the next entry in buffer
        end_while;
      end_if;
    else
      retcode := 0x02;                                                // set error code ... illegal data address
    end_if;
  else
    retcode := 0x03;                                                  // set error code ... illegal data value
  end_if;


END_FUNCTION


FUNCTION _ModBusTCPSLAVE::Search_Parameter
	VAR_INPUT
		RegisterType 	: DINT;
		address 	: UINT;
	END_VAR
	VAR_OUTPUT
		ppara 	: ^_ONE_ENTRY;
	END_VAR
  VAR
    i       : UDINT;
    ptr     : ^_ONE_ENTRY;
    myNo    : UDINT;
  END_VAR

#pragma warning(disable: 0074);
  ppara := NIL;                                   // init pointer
#pragma warning(default: 0074);
  
  //----- type HOLDING registers  V.1.34 -----
  if (RegisterType = 0) then
    myNo := vAddrEntriesHolding.udNo;
    ptr  := vAddrEntriesHolding.pEntries;
  end_if;
  //----- type INPUT registers  V.1.34 -----
  if (RegisterType = 1) then
    myNo := vAddrEntriesInput.udNo;
    ptr  := vAddrEntriesInput.pEntries;
  end_if;

  if (myNo > 0) then

    for i:=0 to (myNo -1) do                      // search all entries
      if (ptr^.uiAddress = address) then          // found entry?
        ppara := ptr;                             // retcode = pointer to entry
        exit;                                     // exit here because entry was found
      else                                        // entry not found?
        ptr += sizeof(_ONE_ENTRY);                // set pointer to the next entry
      end_if;
    end_for;
  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL _ModBusTCPSLAVE::Check_Request
  VAR_INPUT
    ptr 	: ^_ONE_ENTRY;
    uiRegNo 	: UINT;
    usFunction 	: USINT;
  END_VAR
  VAR_OUTPUT
    retcode 	: USINT;
  END_VAR
  VAR
    uiRegSrc    : UINT;
    hptr        : ^_ONE_ENTRY;
    i           : UDINT;
  END_VAR

  retcode := NO_ERROR;                                              // reset retcode

  case usFunction of

    //===============================================================
    // MODBUS function : read multiple HOLDING registers
    //===============================================================
    MB_FUNC_RD_MULTIPLE_REG: 
      uiRegSrc := 0;                                                // reset register counter
      hptr := ptr + sizeof(_ONE_ENTRY);
      
      for i:=ptr^.udEntryNo to (vAddrEntriesHolding.udNo) do        // search to the end of all entries
        if (ptr^.usAccess = MB_WRITE_ONLY) then                     // access right not OK ?
          retcode := 0x02;                                          // set MODBUS exeption code 0x02
          exit;                                                     // exit loop, because of MODBUS exeption
        end_if;
        uiRegSrc += ptr^.usReg;                                     // add number of registers from parameter to the counter
        if (uiRegSrc < uiRegNo) then                                
          retcode := 0x02;                                          // set MODBUS exeption code 0x03
          if ((ptr^.uiAddress + ptr^.usReg) <> hptr^.uiAddress) then  // address from next entry not OK?
            exit;                                                   // exit loop because of MODBUS exeption
          end_if;
          hptr += sizeof(_ONE_ENTRY);                               // set pointers to the next entries in memory
          ptr += sizeof(_ONE_ENTRY);
        elsif (uiRegSrc > uiRegNo) then                             // wrong number of registers in request?
          retcode := 0x02;                                          // set MODBUS exeption code 0x03
          exit;                                                     // exit loop because of MODBUS exeption
        else                                                        // Response OK!?
          retcode := 0x00;                                          // set no MODBUS exeption code
          exit;                                                     // exit loop because request is OK
        end_if;
      end_for;

    //===============================================================
    // MODBUS function : read multiple INPUT registers
    //===============================================================
    MB_FUNC_RD_MULTIPLE_INPUT_REG: 
      uiRegSrc := 0;                                                // reset register counter
      hptr := ptr + sizeof(_ONE_ENTRY);
      
      for i:=ptr^.udEntryNo to (vAddrEntriesInput.udNo) do          // search to the end of all entries
        if (ptr^.usAccess = MB_WRITE_ONLY) then                     // access right not OK ?
          retcode := 0x02;                                          // set MODBUS exeption code 0x02
          exit;                                                     // exit loop, because of MODBUS exeption
        end_if;
        uiRegSrc += ptr^.usReg;                                     // add number of registers from parameter to the counter
        if (uiRegSrc < uiRegNo) then                                
          retcode := 0x02;                                          // set MODBUS exeption code 0x03
          if ((ptr^.uiAddress + ptr^.usReg) <> hptr^.uiAddress) then  // address from next entry not OK?
            exit;                                                   // exit loop because of MODBUS exeption
          end_if;
          hptr += sizeof(_ONE_ENTRY);                               // set pointers to the next entries in memory
          ptr += sizeof(_ONE_ENTRY);
        elsif (uiRegSrc > uiRegNo) then                             // wrong number of registers in request?
          retcode := 0x02;                                          // set MODBUS exeption code 0x03
          exit;                                                     // exit loop because of MODBUS exeption
        else                                                        // Response OK!?
          retcode := 0x00;                                          // set no MODBUS exeption code
          exit;                                                     // exit loop because request is OK
        end_if;
      end_for;

    //===============================================================
    // MODBUS function : write multiple HOLDING registers
    //===============================================================
    MB_FUNC_WR_MULTIPLE_REG: 
      uiRegSrc := 0;                                                // reset register counter
      hptr := ptr + sizeof(_ONE_ENTRY);
      
      for i:=ptr^.udEntryNo to (vAddrEntriesHolding.udNo) do        // search to the end of all entries
        if (ptr^.usAccess = MB_READ_ONLY) then                      // access right not OK ?
          retcode := 0x02;                                          // set MODBUS exeption code 0x02
          exit;                                                     // exit loop, because of MODBUS exeption
        end_if;
        uiRegSrc += ptr^.usReg;                                     // add number of registers from parameter to the counter
        if (uiRegSrc < uiRegNo) then
          retcode := 0x02;                                          // set MODBUS exeption code 0x03
          if ((ptr^.uiAddress + ptr^.usReg) <> hptr^.uiAddress) then  // address from next entry not OK?
            exit;                                                   // exit loop because of MODBUS exeption
          end_if;
          hptr += sizeof(_ONE_ENTRY);                               // set pointers to the next entries in memory
          ptr += sizeof(_ONE_ENTRY);
        elsif (uiRegSrc > uiRegNo) then                             // wrong number of registers in request?
          retcode := 0x02;                                          // set MODBUS exeption code 0x03
          exit;                                                     // exit loop because of MODBUS exeption
        else                                                        // Response OK!?
          retcode := 0x00;                                          // set no MODBUS exeption code
          exit;                                                     // exit loop because request is OK
        end_if;
      end_for;

    //===============================================================

  end_case;

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::ReadServer
  VAR_INPUT
    ptr 	: ^_ONE_ENTRY;
    pdata 	: ^void;
  END_VAR
  VAR_OUTPUT
    retcode 	: USINT;
  END_VAR

  retcode := 0;

  case ptr^.dDataType of

    //===============================================================
    // parameter data type is a value
    //===============================================================
    MB_DAT_VAL:
      case ptr^.usReg of   // ckeck no of Registers to read

        //---------------------------------------------------------
        // 16 bit parameter
        //---------------------------------------------------------
        0x01: 
          if (ptr^.ptr <> NIL) then
          
            if (cTurnBytes = 0) then
              pdata^$UINT := RD(pt := ptr^.ptr)$UINT;
            elsif (cTurnBytes = 1) then
              pdata^$UINT := Turn_2_Bytes(iValue := RD(pt := ptr^.ptr)$UINT);
            end_if;
            
            retcode := sizeof(UINT);
          end_if;

        //---------------------------------------------------------
        // 32 bit parameter
        //---------------------------------------------------------
        0x02: 
          if (ptr^.ptr <> NIL) then
            
            if (cTurnBytes = 0) then
              pdata^$UDINT := RD(pt := ptr^.ptr)$UDINT;
            elsif (cTurnBytes = 1) then
              pdata^$UDINT := Turn_4_Bytes(udValue := RD(pt := ptr^.ptr)$UDINT);
            end_if;
            
            retcode := sizeof(UDINT);
          end_if;

        //---------------------------------------------------------

      end_case;    

    //===============================================================

  end_case;

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::ReadVariable
  VAR_INPUT
    ptr 	: ^_ONE_ENTRY;
    pData 	: ^void;
  END_VAR
  VAR_OUTPUT
    retcode 	: USINT;
  END_VAR

  retcode := 0;

  case ptr^.dDataType of

    //===============================================================
    // parameter data type is a value
    //===============================================================
    MB_DAT_VAL: 
      case ptr^.usReg of

        //---------------------------------------------------------
        // 16 bit parameter
        //---------------------------------------------------------
        0x01: 
          if (ptr^.ptr <> NIL) then
            pData^$UINT := Turn_2_Bytes(iValue := ptr^.ptr^$UINT);
            retcode := sizeof(UINT);
          end_if;

        //---------------------------------------------------------
        // 32 bit parameter
        //---------------------------------------------------------
        0x02: 
          if (ptr^.ptr <> NIL) then
            pData^$UDINT := Turn_4_Bytes(udValue := ptr^.ptr^$UDINT);
            retcode := sizeof(UDINT);
          end_if;

        //---------------------------------------------------------

      end_case;

    //===============================================================
    // parameter data type is a ASCII string
    //===============================================================
    MB_DAT_STRING: 
      if (ptr^.ptr <> NIL) then
        _memcpy(ptr1 := pData,
                ptr2 := ptr^.ptr,
                cntr := ptr^.usReg * sizeof(UINT));

        retcode := ptr^.usReg * sizeof(UINT);
      end_if;

    //===============================================================

  end_case;

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::WriteServer
  VAR_INPUT
    ptr 	: ^_ONE_ENTRY;
    pdata 	: ^void;
  END_VAR
  VAR_OUTPUT
    retcode 	: USINT;
  END_VAR

  retcode := 0;

  case ptr^.dDataType of

    //===============================================================
    // value
    //===============================================================
    MB_DAT_VAL: 
      case ptr^.usReg of

        //---------------------------------------------------------
        // 16 bit parameter
        //---------------------------------------------------------
        0x01: 
          if (ptr^.ptr <> NIL) then
            if cTurnBytes = 0 then
              WR(pt := ptr^.ptr, dData := pdata^$UINT);
            elsif cTurnBytes = 1 then
              WR(pt := ptr^.ptr, dData := Turn_2_Bytes(iValue := pdata^$UINT));
            end_if;
            
            retcode := sizeof(UINT);
          end_if;

        //---------------------------------------------------------
        // 32 bit parameter
        //---------------------------------------------------------
        0x02: 
          if (ptr^.ptr <> NIL) then
            if (cTurnBytes = 0) then
              WR(pt := ptr^.ptr, dData := pdata^$DINT);
            elsif (cTurnBytes = 1) then
              WR(pt := ptr^.ptr, dData := Turn_4_Bytes(udValue := pdata^$UDINT)$DINT);
            end_if;
            
            retcode := sizeof(UDINT);
          end_if;

        //---------------------------------------------------------

      end_case;

    //===============================================================

  end_case;

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::WriteVariable
  VAR_INPUT
    ptr 	: ^_ONE_ENTRY;
    pData 	: ^void;
  END_VAR
  VAR_OUTPUT
    retcode 	: USINT;
  END_VAR

  retcode := 0;

  case ptr^.dDataType of

    //===============================================================
    // parameter data type is a value
    //===============================================================
    MB_DAT_VAL: 
      case ptr^.usReg of

        //---------------------------------------------------------
        // 16 bit parameter
        //---------------------------------------------------------
        0x01: 
          if (ptr^.ptr <> NIL) then
            if (cTurnBytes = 0) then
              ptr^.ptr^$UINT := pData^$UINT;
            elsif (cTurnBytes = 1) then
              ptr^.ptr^$UINT := Turn_2_Bytes(iValue := pData^$UINT);
            end_if;
            
            retcode := sizeof(UINT);
          end_if;

        //---------------------------------------------------------
        // 32 bit parameter
        //---------------------------------------------------------
        0x02: 
          if (ptr^.ptr <> NIL) then
            if (cTurnBytes = 0) then
              ptr^.ptr^$UDINT := pData^$UDINT;
            elsif (cTurnBytes = 1) then
              ptr^.ptr^$UDINT := Turn_4_Bytes(udValue := pData^$UDINT);
            end_if;
            
            retcode := sizeof(UDINT);
          end_if;

        //---------------------------------------------------------

      end_case;

    //===============================================================
    // parameter data type is a ASCII string
    //===============================================================
    MB_DAT_STRING: 
      if (ptr^.ptr <> NIL) then
        _memcpy(ptr1 := ptr^.ptr,
                ptr2 := pData,
                cntr := ptr^.usReg * sizeof(UINT));

        retcode := ptr^.usReg * sizeof(UINT);
      end_if;

    //===============================================================

  end_case;

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::Turn_4_Bytes
  VAR_INPUT
    udValue 	: UDINT;
  END_VAR
  VAR_OUTPUT
    udRetVal 	: UDINT;
  END_VAR

  //===============================================================
  //  This function turns the bytes of a 4 byte value
  //
  //  INPUT VALUE : 0x12345678
  //  OUTPUT VALUE: 0x78563412
  //===============================================================

  udRetVal := 0x00000000;
  udRetVal := udRetVal OR ((udValue AND 0x000000FF) SHL 24);
  udRetVal := udRetVal OR ((udValue AND 0x0000FF00) SHL 8);
  udRetVal := udRetVal OR ((udValue AND 0x00FF0000) SHR 8);
  udRetVal := udRetVal OR ((udValue AND 0xFF000000) SHR 24);

END_FUNCTION


FUNCTION _ModBusTCPSLAVE::Turn_2_Bytes
  VAR_INPUT
    iValue 	: UINT;
  END_VAR
  VAR_OUTPUT
    iRetVal 	: UINT;
  END_VAR

  //===============================================================
  //  This function turns the bytes of a 2 byte value
  //
  //  INPUT VALUE : 0x1234
  //  OUTPUT VALUE: 0x3412
  //===============================================================

  iRetVal := 0x0000;
  iRetVal := iRetVal OR ((iValue AND 0x00FF) SHL 8);
  iRetVal := iRetVal OR ((iValue AND 0xFF00) SHR 8);

END_FUNCTION


FUNCTION GLOBAL _ModBusTCPSLAVE::AddParameter
	VAR_INPUT
		uiAddress 	: UINT;
		usRegisterNo 	: USINT;
		usAccess 	: USINT;
		usType 	: USINT;
		usDataTyp 	: USINT;
		ptr 	: ^void;
		RegisterType 	: DINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
	  pEntry      : ^_ONE_ENTRY;
    ptrSvrCh    : ^SvrCh;
  END_VAR

  //----- type HOLDING registers  V.1.34 -----
  if (RegisterType = 0) then
    if ( (vAddrEntriesHolding.pEntries = NIL) | 
         (vAddrEntriesHolding.udNo = to_UDINT(cBufSize)) ) then         
      retcode := MB_ERR_ADD_PARA;                                                     // set error code
      return;                                                                         // exit function, because more actions are crazy
    end_if;
    pEntry := vAddrEntriesHolding.pEntries + vAddrEntriesHolding.udNo * sizeof(_ONE_ENTRY); // set pointer to the next free space in allocated memory
    retcode := MB_PARA_OK;                                                            // init retcode
  end_if;
  //----- type INPUT registers  V.1.34 -----
  if (RegisterType = 1) then
    if ( (vAddrEntriesInput.pEntries = NIL) | 
         (vAddrEntriesInput.udNo = to_UDINT(cBufSizeInputReg)) ) then         
      retcode := MB_ERR_ADD_PARA;                                                     // set error code
      return;                                                                         // exit function, because more actions are crazy
    end_if;
    pEntry := vAddrEntriesInput.pEntries + vAddrEntriesInput.udNo * sizeof(_ONE_ENTRY); // set pointer to the next free space in allocated memory
    retcode := MB_PARA_OK;                                                            // init retcode
  end_if;


  case usType of

    //===================================================================================
    MB_TYPE_SERVER: // parameter type ... server
    //===================================================================================

      if (ptr = NIL) then                                                             // pointer invalid ?                                                           
        retcode := MB_ERR_ADD_PARA;                                                   // set error code
        return;                                                                       // exit function because we do not handle with NILpointer
      else
        _LookUpEmbed_C(ptr$^CHAR, #ptrSvrCh, NIL);                                    // get pointer to server channel
        if (ptrSvrCh <> NIL) then                                                     // is pointer valid ?
          pEntry^.ptr := ptrSvrCh$^DINT;                                              // add pointer to struct
        else                                                                          // invalid pointer
          retcode := MB_ERR_ADD_PARA;                                                 // set error code
          return;                                                                     // exit function because we do not handle with NILpointer
        end_if;
      end_if;

    //===================================================================================
    MB_TYPE_VARIABLE: // parameter type ... variable
    //===================================================================================

      if (ptr <> NIL) then                                                            // is pointer valid ?
        pEntry^.ptr := ptr$^DINT;                                                     // add pointer to struct
      else                                                                            // invalid pointer
        retcode := MB_ERR_ADD_PARA;                                                   // set error code
        return;                                                                       // exit function because we do not handle with NILpointer
      end_if;

    //===================================================================================

  end_case;

  pEntry^.uiAddress := uiAddress;                                                     // add MODBUS address to struct
  pEntry^.usReg     := usRegisterNo;                                                  // add number of MODBUS register to struct 
  pEntry^.usAccess  := usAccess;                                                      // add parameter access rights to struct
  pEntry^.usType    := usType;                                                        // add parameter type to struct
  pEntry^.dDataType := usDataTyp;                                                     // add parameter data type to struct

  //----- type HOLDING registers  V.1.34 -----
  if (RegisterType = 0) then
    vAddrEntriesHolding.udNo += 1;                                                    // increase the number of entries
    pEntry^.udEntryNo := vAddrEntriesHolding.udNo;                                    // set the actual entry number
  
    if (vAddrEntriesHolding.udNo < to_UDINT(cBufSize)) then                           // buffer isn't full
      pEntry += sizeof(_ONE_ENTRY);                                                   // set pointer to the next free space in allocated memory
      INIT_ENTRY(ptr:=pEntry);                                                        // clear the next space in allocated memory
    end_if;
  end_if;
  //----- type INPUT registers  V.1.34 -----
  if (RegisterType = 1) then
    vAddrEntriesInput.udNo += 1;                                                      // increase the number of entries
    pEntry^.udEntryNo := vAddrEntriesInput.udNo;                                      // set the actual entry number
  
    if (vAddrEntriesInput.udNo < to_UDINT(cBufSizeInputReg)) then                    // buffer isn't full
      pEntry += sizeof(_ONE_ENTRY);                                                   // set pointer to the next free space in allocated memory
      INIT_ENTRY(ptr:=pEntry);                                                        // clear the next space in allocated memory
    end_if;
  end_if;

  SortEntries(RegisterType);                                                          // sort and check entries

END_FUNCTION


FUNCTION GLOBAL _ModBusTCPSLAVE::DeleteParameterEntries
	VAR_INPUT
		RegisterType 	: DINT;(* := 0 *)
	END_VAR
  
  //----- type HOLDING registers  V.1.34 -----
  if (RegisterType = 0) then
    //look if there are already entries in the list
    if (vAddrEntriesHolding.udNo > 0) then
      //reset number of entries
      vAddrEntriesHolding.udNo := 0;
    end_if;
  end_if;
  //----- type INPUT registers  V.1.34 -----
  if (RegisterType = 1) then
    //look if there are already entries in the list
    if (vAddrEntriesInput.udNo > 0) then
      //reset number of entries
      vAddrEntriesInput.udNo := 0;
    end_if;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _ModBusTCPSLAVE::AddParameterList
	VAR_INPUT
		pData 	: ^void;
		udEntryCount 	: UDINT;
		RegisterType 	: DINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    pEntry      : ^_ONE_ENTRY;
    pParameter  : ^_ONE_ENTRY;
    i           : UDINT;
  END_VAR

  //----- type HOLDING registers  V.1.34 -----
  if (RegisterType = 0) then
    if ( (vAddrEntriesHolding.pEntries = NIL) | 
         (vAddrEntriesHolding.udNo = to_UDINT(cBufSize)) | 
         ((TO_UDINT(cBufSize)-vAddrEntriesHolding.udNo) < udEntryCount) ) then        //check if there is enough free space for parameter list
      retcode := MB_ERR_ADD_PARA;                                                     // set error code
      return;                                                                         // exit function, because more actions are crazy
    end_if;
    pEntry := vAddrEntriesHolding.pEntries + vAddrEntriesHolding.udNo * sizeof(_ONE_ENTRY); // set pointer to the next free space in allocated memory
    retcode := MB_PARA_OK;                                                            // init retcode
  end_if;
  //----- type INPUT registers  V.1.34 -----
  if (RegisterType = 1) then
    if ( (vAddrEntriesInput.pEntries = NIL) | 
         (vAddrEntriesInput.udNo = to_UDINT(cBufSizeInputReg)) | 
         ((TO_UDINT(cBufSizeInputReg)-vAddrEntriesInput.udNo) < udEntryCount) ) then //check if there is enough free space for parameter list
      retcode := MB_ERR_ADD_PARA;                                                     // set error code
      return;                                                                         // exit function, because more actions are crazy
    end_if;
    pEntry := vAddrEntriesInput.pEntries + vAddrEntriesInput.udNo * sizeof(_ONE_ENTRY); // set pointer to the next free space in allocated memory
    retcode := MB_PARA_OK;                                                            // init retcode
  end_if;

  
  pParameter := pData$^_ONE_ENTRY;                                                    // point to first entry of parameter list
  
  for i:=0 to (udEntryCount-1) do
  
    case pParameter^.usType of

      //=================================================================================
      MB_TYPE_SERVER: // parameter type ... server
      //=================================================================================
        if (pParameter^.ptr <> NIL) then                                                // is pointer valid ?  
          pEntry^.ptr := pParameter^.ptr;                                               // add pointer to struct
        else
          retcode := MB_ERR_ADD_PARA;                                                   // set error code
          return;                                                                       // exit function because we do not handle with NILpointer
        end_if;

      //=================================================================================
      MB_TYPE_VARIABLE: // parameter type ... variable
      //=================================================================================
        if (pParameter^.ptr <> NIL) then                                                // is pointer valid ?
          pEntry^.ptr := pParameter^.ptr;                                               // add pointer to struct
        else                                                                            // invalid pointer
          retcode := MB_ERR_ADD_PARA;                                                   // set error code
          return;                                                                       // exit function because we do not handle with NILpointer
        end_if;

      //=================================================================================

    end_case;

    pEntry^.uiAddress := pParameter^.uiAddress;                                       // add MODBUS address to struct
    pEntry^.usReg     := pParameter^.usReg;                                           // add number of MODBUS register to struct 
    pEntry^.usAccess  := pParameter^.usAccess;                                        // add parameter access rights to struct
    pEntry^.usType    := pParameter^.usType;                                          // add parameter type to struct
    pEntry^.dDataType := pParameter^.dDataType;                                       // add parameter data type to struct

    //----- type HOLDING registers  V.1.34 -----
    if (RegisterType = 0) then
      vAddrEntriesHolding.udNo += 1;                                                  // increase the number of entries
      pEntry^.udEntryNo := vAddrEntriesHolding.udNo;                                  // set the actual entry number
    end_if;
    //----- type INPUT registers  V.1.34 -----
    if (RegisterType = 1) then
      vAddrEntriesInput.udNo += 1;                                                    // increase the number of entries
      pEntry^.udEntryNo := vAddrEntriesInput.udNo;                                    // set the actual entry number
    end_if;

    pParameter += sizeof(_ONE_ENTRY);                                                 // point to next parameter
    pEntry     += sizeof(_ONE_ENTRY);                                                 // point to next free entry
  
  end_for;
  
  //----- type HOLDING registers  V.1.34 -----
  if (RegisterType = 0) then
    if (vAddrEntriesHolding.udNo < to_UDINT(cBufSize)) then                           // buffer isn't full
      pEntry += sizeof(_ONE_ENTRY);                                                   // set pointer to the next free space in allocated memory
      INIT_ENTRY(ptr:=pEntry);                                                        // clear the next space in allocated memory
    end_if;
  end_if;
  //----- type INPUT registers  V.1.34 -----
  if (RegisterType = 1) then
    if (vAddrEntriesInput.udNo < to_UDINT(cBufSizeInputReg)) then                     // buffer isn't full
      pEntry += sizeof(_ONE_ENTRY);                                                   // set pointer to the next free space in allocated memory
      INIT_ENTRY(ptr:=pEntry);                                                        // clear the next space in allocated memory
    end_if;
  end_if;

  SortEntries(RegisterType); 
  
END_FUNCTION

FUNCTION VIRTUAL _ModBusTCPSLAVE::ExceptionLogging
VAR_INPUT
  pRequest 	      : ^_REQUEST;
  ExceptionCode 	: USINT;
END_VAR
VAR
	szLogEntry      : ARRAY [0..255] OF CHAR;
  dValue          : DINT;
  szValue         : ARRAY [0..15] OF CHAR;
  szHelp          : ARRAY [0..15] OF CHAR;
  udStrLen        : UDINT;
  i               : USINT;
END_VAR

  // -----------------------------------------------------------------
  // - ADD FUNCTION CODE TO LOG ENTRY
  // -----------------------------------------------------------------
  coSigCLib.StrCpy(#szLogEntry[0], "Modbus Slave Exception Response, Function=");
  dValue := to_DINT(pRequest^.usFunction);
  coSigCLib.IToA(dValue, #szValue[0], 10);
  coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);
  // -----------------------------------------------------------------
  // - ADD EXCEPTION CODE TO LOG ENTRY
  // -----------------------------------------------------------------
  coSigCLib.StrCat(#szLogEntry[0], ", Exception Code=");
  dValue := to_DINT(ExceptionCode);
  coSigCLib.IToA(dValue, #szValue[0], 10);
  coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);
  // -----------------------------------------------------------------
  // - ADD OBJECT ADDRESS TO LOG ENTRY
  // -----------------------------------------------------------------
  coSigCLib.StrCat(#szLogEntry[0], ", this=");
  coSigCLib.IToA(this$DINT, #szValue[0], 0x10);
  udStrLen := coSigCLib.StrLen(#szValue[0]);

  i := 2;
  szHelp[0] := '0';
  szHelp[1] := 'x';
  szHelp[2] := 0x00;

  while udStrLen < 0x08 do
    szHelp[i]   := '0';
    szHelp[i+1] := 0x00;
    udStrLen    += 1;
    i           += 1;
  end_while;

  coSigCLib.StrCat(#szHelp[0], #szValue[0]);
  coSigCLib.StrCat(#szLogEntry[0], #szHelp[0]);

  coSysMsg.ULPrintfln0(#szLogEntry[0]);


  ExceptionLoggingDetail(pRequest);

END_FUNCTION

FUNCTION VIRTUAL _ModBusTCPSLAVE::ExceptionLoggingDetail
VAR_INPUT
  pRequest 	: ^_REQUEST;
END_VAR
VAR
	szLogEntry    : ARRAY [0..255] OF CHAR;
  szValue       : ARRAY [0..15] OF CHAR;
  uiValue       : UINT;
END_VAR

  case pRequest^.usFunction of

    (*=======================================================================*)
    MB_FUNC_RD_MULTIPLE_REG:
    (*=======================================================================*)
      coSigCLib.StrCpy(#szLogEntry[0], "---Detailed Information: StartAddress=");
      if (cTurnBytes = 0) then
        uiValue := pRequest^.aData[0]$UINT;
      else
        uiValue := Turn_2_Bytes(pRequest^.aData[0]$UINT);
      end_if;
      coSigCLib.IToA(to_DINT(uiValue), #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);
      coSigCLib.StrCat(#szLogEntry[0], ", RegisterCnt=");
      if (cTurnBytes = 0) then
        uiValue := pRequest^.aData[2]$UINT;
      else
        uiValue := Turn_2_Bytes(pRequest^.aData[2]$UINT);
      end_if;
      coSigCLib.IToA(to_DINT(uiValue), #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);
      coSigCLib.StrCat(#szLogEntry[0], ", StartAddrOffset=");
      coSigCLib.IToA(StartAddrOffset, #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);
      coSigCLib.StrCat(#szLogEntry[0], ", UseOffset=");
      coSigCLib.IToA(UseOffset, #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);

      coSysMsg.ULPrintfln0(#szLogEntry[0]);

    (*=======================================================================*)
    MB_FUNC_RD_MULTIPLE_INPUT_REG:
    (*=======================================================================*)
      coSigCLib.StrCpy(#szLogEntry[0], "---Detailed Information: StartAddress=");
      if (cTurnBytes = 0) then
        uiValue := pRequest^.aData[0]$UINT;
      else
        uiValue := Turn_2_Bytes(pRequest^.aData[0]$UINT);
      end_if;
      coSigCLib.IToA(to_DINT(uiValue), #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);
      coSigCLib.StrCat(#szLogEntry[0], ", RegisterCnt=");
      if (cTurnBytes = 0) then
        uiValue := pRequest^.aData[2]$UINT;
      else
        uiValue := Turn_2_Bytes(pRequest^.aData[2]$UINT);
      end_if;
      coSigCLib.IToA(to_DINT(uiValue), #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);
      coSigCLib.StrCat(#szLogEntry[0], ", StartAddrOffsInputReg=");
      coSigCLib.IToA(StartAddrOffsInputReg, #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);
      coSigCLib.StrCat(#szLogEntry[0], ", UseOffsInputReg=");
      coSigCLib.IToA(UseOffsInputReg, #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);

      coSysMsg.ULPrintfln0(#szLogEntry[0]);

    (*=======================================================================*)
    MB_FUNC_WR_MULTIPLE_REG:
    (*=======================================================================*)
      coSigCLib.StrCpy(#szLogEntry[0], "---Detailed Information: StartAddress=");
      if (cTurnBytes = 0) then
        uiValue := pRequest^.aData[0]$UINT;
      else
        uiValue := Turn_2_Bytes(pRequest^.aData[0]$UINT);
      end_if;
      coSigCLib.IToA(to_DINT(uiValue), #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);
      coSigCLib.StrCat(#szLogEntry[0], ", RegisterCnt=");
      if (cTurnBytes = 0) then
        uiValue := pRequest^.aData[2]$UINT;
      else
        uiValue := Turn_2_Bytes(pRequest^.aData[2]$UINT);
      end_if;
      coSigCLib.IToA(to_DINT(uiValue), #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);
      coSigCLib.StrCat(#szLogEntry[0], ", StartAddrOffset=");
      coSigCLib.IToA(StartAddrOffset, #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);
      coSigCLib.StrCat(#szLogEntry[0], ", UseOffset=");
      coSigCLib.IToA(UseOffset, #szValue[0], 10);
      coSigCLib.StrCat(#szLogEntry[0], #szValue[0]);

      coSysMsg.ULPrintfln0(#szLogEntry[0]);

  end_case;

END_FUNCTION
