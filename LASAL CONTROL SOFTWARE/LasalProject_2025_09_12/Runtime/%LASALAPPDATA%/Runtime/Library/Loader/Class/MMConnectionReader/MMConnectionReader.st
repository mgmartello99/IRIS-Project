//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "MMConnectionReader"
	Revision           = "0.0"
	GUID               = "{24656200-ADC8-40C9-A5D0-08383C30C233}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FimLuc"/>
		<Dokumentation Revision="0.0" Date="2015-10-07" Author="FimLuc" Company="Sigmatek" Description="erstell"/>
	</RevDoku>
	<Network Name="MMConnectionReader">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{135B3FFC-5D31-4747-944A-3141D951C30D}"
				Class      = "ObjectReader"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Server0"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using ObjectReader

MMConnectionReader : CLASS
: ObjectReader
  //Servers:
  //Clients:
  //Variables:
		pObjRd 	: ^ObjectReader;
  //Functions:
	
	FUNCTION GLOBAL ReadConnections
		VAR_INPUT
			pObjRd 	: ^ObjectReader;
		END_VAR;
	
	FUNCTION SetConn
		VAR_INPUT
			pClt 	: ^CltCh;
			iCltNr 	: UDINT;
			pThis 	: ^VirtualBase;
		END_VAR;
	
	FUNCTION ReadConnSmall;
	
	FUNCTION ReadConnLarge;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MMConnectionReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MMCONNECTIONREADER
0$UINT, 0$UINT, (SIZEOF(::MMConnectionReader))$UINT, 
0$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2036428478), "MMConnectionReader", //Class
TO_UDINT(1461090386), "ObjectReader", 0$UINT, 1$UINT, //Baseclass
//Servers:
//Clients:
END_FUNCTION


#define USER_CNT_MMConnectionReader 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MMConnectionReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MMConnectionReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code	:= ObjectReader::@STD();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include <RTOS_PrivHeader.h>

#pragma using MMServer

// forward declaration
FUNCTION GLOBAL _LookUpObjLex
VAR_INPUT
	pLexem     : ^CLexem;
END_VAR
VAR_OUTPUT
	ret				: ^SvrCh;
END_VAR;

(*
  liest die verbindungstabelle des on's ein
*)
FUNCTION GLOBAL MMConnectionReader::ReadConnections
	VAR_INPUT
		pObjRd 	: ^ObjectReader;
	END_VAR
  
  this^.pObjRd	:= pObjRd;
  
  ReadConnSmall();
  ReadConnLarge();

END_FUNCTION 
(*
  setzt die verbindung
*)
FUNCTION MMConnectionReader::SetConn
	VAR_INPUT
		pClt 	: ^CltCh;
    iCltNr : UDINT;
    pThis	: ^VirtualBase;
	END_VAR
  VAR
    uiTry   : UINT;
    pSvr    : ^void;
    lexem   : ^CLexem;
    cCltNr : ARRAY[ 0..8 ] OF CHAR;
  END_VAR
  
  uiTry := pObjRd^.GetUInt();  
  
  lexem := pObjRd^.ReadLexem();
  pSvr := _LookUpObjLex(lexem);

  IF (pSvr = NIL) THEN
       // eventuell hat das initialisieren der MMConnectionHandler zu lange gedauert, 
       // sodass das MMServer-Object nocht nicht angelegt worden ist
        _itoa( iCltNr, #cCltNr[ 0 ] );
       IF(pThis <> NIL) THEN
          TRACE2_ERR("Remote object '{0}' not found. Check Stations.txt. Could not connect to object '{1}' at client {2}", #lexem^.Text[0], LSL_GetObjName(pThis), #cCltNr[ 0 ]);
       ELSE
          TRACE1_ERR("Remote object '{0}' not found. Check Stations.txt. Could not enter connection to '{1}'", #lexem^.Text[0], #cCltNr[ 0 ]);
       END_IF;
      RETURN; 
  END_IF;

  IF (uiTry <> C_TRY) THEN
    pSvr$^MMServer^.m_flStatus := (pSvr$^MMServer^.m_flStatus OR MM_REQUIRED);
  END_IF;

  pClt^.pCh  := pSvr$^SvrCh;
  pClt^.pCmd := pSvr$^VirtualBase;
  
  
END_FUNCTION


FUNCTION MMConnectionReader::ReadConnSmall
VAR
  nConCnt	: UDINT;
  pClt	: ^CltCh;
  iCltNr  : UDINT;
  cCltNr : ARRAY[ 0..8 ] OF CHAR;
END_VAR
  
	nConCnt	:= pObjRd^.GetCount();

	IF nConCnt = 0 THEN
		RETURN;
	END_IF;

  iCltNr := 0;

	WHILE (nConCnt > 0) DO				// alle angegebenen Verbindungspaare einlesen
    iCltNr += 1;
    
    pClt	:= (pObjRd^.GetObjectOff()) $ ^CltCh;

    IF (pClt = NIL) THEN
      _itoa( iCltNr, #cCltNr[ 0 ] );
      TRACE0_ERR("channel '{0}' not found.", #cCltNr[ 0 ]);
			RETURN;
		END_IF;

    SetConn(pClt, iCltNr, NIL);
    
		nConCnt	-= 1;
	END_WHILE;   


END_FUNCTION


FUNCTION MMConnectionReader::ReadConnLarge
VAR
  nConCnt	: UDINT;
  pClt	: ^CltCh;
  pThis	: ^VirtualBase;
  iCltNr  : UDINT;
  cCltNr : ARRAY[ 0..8 ] OF CHAR;
END_VAR
  
	nConCnt	:= pObjRd^.GetCount();

	IF nConCnt = 0 THEN
		RETURN;
	END_IF;

  iCltNr := 0;

	WHILE (nConCnt > 0) DO				// alle angegebenen Verbindungspaare einlesen
    iCltNr += 1;
		pThis	:= pObjRd^.GetObjectNo();
		pClt	:= pObjRd^.GetChPtr(pThis);
    IF (pClt = NIL) THEN
      _itoa( iCltNr, #cCltNr[ 0 ] );
      TRACE1_ERR("Channel '{0}' of Object '{1}' not found.", #cCltNr[ 0 ], LSL_GetObjName(pThis));
			RETURN;
		END_IF;

    SetConn(pClt, iCltNr, pThis);
    
		nConCnt	-= 1;
	END_WHILE;

END_FUNCTION
