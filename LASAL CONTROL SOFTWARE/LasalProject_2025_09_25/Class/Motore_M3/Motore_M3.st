//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Motore_M3"
	Revision           = "0.0"
	GUID               = "{5A70A65A-2FA7-4BE5-A805-8C0776D921E6}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "100 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(720,180)">
	<Channels>
		<Server Name="ClassSvr" GUID="{E9A7E124-C050-4078-9DA9-488890A180F9}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ErrorState" GUID="{5904DA8F-3EFE-478C-9B6C-C80442D6A59A}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="M3_Correction_Step" GUID="{1AB2AE57-7B1A-41DC-9816-6210C5C2D8E4}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="MotoreM3Step" GUID="{60FA5603-D7CD-407D-A3EE-AB863CD9F635}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="s_M3_Coupled" GUID="{EE462076-8286-4D38-B9D7-016EF1D6CEC7}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_M3_Homed" GUID="{CBAAE7FD-DFEA-4EF7-A9E1-05EE93EC416C}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="c_MaxCurrent" Required="true" Internal="false"/>
		<Client Name="Comando_M3" Required="true" Internal="false"/>
		<Client Name="M3_LS_1" Required="false" Internal="false"/>
		<Client Name="M3_LS_2" Required="false" Internal="false"/>
		<Client Name="SetPositionController" Required="true" Internal="false"/>
	</Channels>
	<Separators>
		<Clients>
			<SepChn Position="1"/>
			<SepChn Position="4"/>
		</Clients>
	</Separators>
</Class>
*)
Motore_M3 : CLASS
	TYPE
	  t_sequence_Cmd_motore_M3 :  //! <Type Public="true" Name="t_sequence_Cmd_motore_M3"/>
	  (
	    Cmd_motore_M3_idle,
	    Cmd_motore_M3_homing,
	    Cmd_motore_M3_phasing,
	    Cmd_motore_M3_movement,
	    Cmd_motore_M3_reset,
	    Cmd_motore_M3_stop,
	    Cmd_motore_M3_stopped,
	    Cmd_motore_M3_Error
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	MotoreM3Step 	: SvrCh_t_sequence_Cmd_motore_M3_PTofCls_Motore_M3;
	ErrorState 	: SvrCh__LMCAXIS_ERROR;
	M3_Correction_Step 	: SvrCh_DINT;
	s_M3_Homed 	: SvrCh_DINT;
	s_M3_Coupled 	: SvrCh_DINT;
  //Clients:
	Comando_M3 	: CltChCmd__LMCAxis;
	M3_LS_1 	: CltCh_DINT;
	M3_LS_2 	: CltCh_DINT;
	c_MaxCurrent 	: CltCh_DINT;
	SetPositionController 	: CltCh_DINT;
  //Variables:
		ActCommand 	: t_sequence_Cmd_motore_M3;
		M3_homed 	: BOOL;
		MotoreM3_Motion_Type 	: DINT;
		M3_coupled 	: DINT;
		v_ErrorState 	: DINT;
		HomingStep 	: DINT;
		MovementStep 	: DINT;
		v_StartHomingCase 	: DINT;
		v_StartMovementCase 	: DINT;
		v_M3_LS_1 	: DINT;
		v_M3_LS_2 	: DINT;
		v_M3_Moving_Step 	: DINT;
		v_M3_Correction_Step 	: DINT;
		v_ACK_M3_Mov 	: DINT;
		v_RecoupledDone 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetSequenceState
		VAR_INPUT
			Cmd_motore 	: t_sequence_Cmd_motore_M3;
			Motion_Type 	: DINT;
			StartCase 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetHomedState
		VAR_OUTPUT
			Homed 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetCoupledState
		VAR_OUTPUT
			Coupled 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetErrorState
		VAR_OUTPUT
			ErrorState 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetMovDone
		VAR_OUTPUT
			OutParam 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetRecoupledDone
		VAR_OUTPUT
			OutParam 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL s_M3_Homed::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL s_M3_Coupled::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _LMCAxis


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Motore_M3::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_MOTORE_M3
0$UINT, 0$UINT, (SIZEOF(::Motore_M3))$UINT, 
6$UINT, 5$UINT, 0$UINT, 
TO_UDINT(1661163733), "Motore_M3", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Motore_M3.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::Motore_M3.MotoreM3Step.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(560123561), "MotoreM3Step", 
(::Motore_M3.ErrorState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2975757027), "ErrorState", 
(::Motore_M3.M3_Correction_Step.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3575579009), "M3_Correction_Step", 
(::Motore_M3.s_M3_Homed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3850400498), "s_M3_Homed", 
(::Motore_M3.s_M3_Coupled.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(514073653), "s_M3_Coupled", 
//Clients:
(::Motore_M3.Comando_M3.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(24729055), "Comando_M3", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 114$UINT, 
(::Motore_M3.M3_LS_1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1406717971), "M3_LS_1", 
(::Motore_M3.M3_LS_2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3402727849), "M3_LS_2", 
(::Motore_M3.c_MaxCurrent.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2379934917), "c_MaxCurrent", 
(::Motore_M3.SetPositionController.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(405540383), "SetPositionController", 
END_FUNCTION


#define USER_CNT_Motore_M3 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Motore_M3] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Motore_M3::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Motore_M3, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	M3_Correction_Step.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF M3_Correction_Step.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_M3_Homed.pMeth			:= StoreMethod( #s_M3_Homed::Read(), #M_WR_DIRECT() );
	IF s_M3_Homed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_M3_Coupled.pMeth			:= StoreMethod( #s_M3_Coupled::Read(), #M_WR_DIRECT() );
	IF s_M3_Coupled.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL Motore_M3::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  v_M3_LS_1:=M3_LS_1.Read();
  v_M3_LS_2:=M3_LS_2.Read();

  v_M3_Correction_Step:=10000*M3_Correction_Step.Read();

  s_M3_Coupled.Write(input:=M3_coupled);
  s_M3_Homed.Write(input:=M3_homed);
  
  case MotoreM3Step of
  
//===========================================================================================
  
    Cmd_motore_M3_idle:

    if Comando_M3.AxisError.HwError then
      v_ErrorState:=1;   
      MotoreM3Step:=Cmd_motore_M3_Error;
    end_if;
    v_ACK_M3_Mov:=0;
//===========================================================================================

    Cmd_motore_M3_homing:

    if Comando_M3.AxisError.HwError then
      v_ErrorState:=1;   
      HomingStep:=0;
      MotoreM3Step:=Cmd_motore_M3_Error;
    end_if;
    
    
    case HomingStep of
    0://idle
      HomingStep:=v_StartHomingCase;
      M3_homed:=FALSE;
      
    10:
      c_MaxCurrent.Write(input:=MOTORMAXCURRENT);
      if (Comando_M3.AxisStatus.PowerOn=0) & (Comando_M3.AxisStatus.ReadyToPowerOn) then
        Comando_M3.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY); //può ruotare in entrambi i versi
      elsif Comando_M3.AxisStatus.PowerOn then
        HomingStep:=12;
      end_if;
    
    12:
      if v_M3_LS_2 then
        Comando_M3.MoveRelative(Position:=-200000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=V_M3, Accel:=A_M3, Decel:=A_M3, Jerk:=J_M3);
        HomingStep:=13;
      else
        HomingStep:=20;
      end_if;

    13:
      if Comando_M3.AxisStatus.InPosition then
        HomingStep:=20;
      end_if;

    20:
      Comando_M3.MoveEndless(Speed:=V_M3, Accel:=A_M3, Jerk:=J_M3);
      HomingStep:=30;  
    
    30:
    if v_M3_LS_2 then //quando tocca LS
      Comando_M3.StopMove(Decel:=A_M3, Jerk:=J_M3);
      HomingStep:=40;
    end_if;

    //NON SPENGO PERCHE' DEVE RIMANERE IN POSIZIONE  
    
    40://Controllo che il motore si sia fermato
    
      if Comando_M3.AxisStatus.Standstill then
        SetPositionController.Write(input:=0);
        c_MaxCurrent.Write(input:=0.1*MOTORMAXCURRENT);
        M3_homed:=TRUE;
        M3_coupled:=0;
        HomingStep:=0;
        v_RecoupledDone:=0;
        MotoreM3Step:=Cmd_motore_M3_idle;
        v_StartHomingCase:=0;
      end_if;
      

    end_case;

//==============================================================================    
    
    Cmd_motore_M3_movement:

    //I MOVIMENTI CHE PUO' FARE SONO CHE LO PORTA IN ACCOPPIATO/DISACCOPPIATO | 0: DISACCOPPIATO->ACCOPPIATO | 1: ACCOPPIATO->DISACCOPPIATO

    if Comando_M3.AxisError.HwError then
      v_ErrorState:=1;   
      MovementStep:=0;
      MotoreM3Step:=Cmd_motore_M3_Error;
    end_if;
  
    if MotoreM3_Motion_Type=0 then

      if v_M3_LS_2 & M3_coupled=2 then // condizione di M3_Coupled perchè altrimenti quando viene attivato il LS questa condizione viene attivata e il case interno non viene terminato
        M3_coupled:=2;  
      elsif M3_coupled=0 | M3_coupled=1 then
      
        
        case MovementStep of
      
          0: //IDLE
          MovementStep:=v_StartMovementCase;
          
        
          10:
          M3_coupled:=1;//in esecuzione
          c_MaxCurrent.Write(input:=MOTORMAXCURRENT);
          if (Comando_M3.AxisStatus.PowerOn=0) & (Comando_M3.AxisStatus.ReadyToPowerOn) then
            Comando_M3.PowerOn(Mode:=LMCAXIS_MOVE_ANY_WAY);
          elsif Comando_M3.AxisStatus.PowerOn then
             MovementStep:=20;
          end_if;
        
          20:
           Comando_M3.MoveEndless(Speed:=-0.7*V_M3, Accel:=-0.7*A_M3, Jerk:=-0.7*J_M3);
           MovementStep:=30;

          30:
          if v_M3_LS_1 | Comando_M3.AxisStatus.InPosition then
            Comando_M3.StopMove(Decel:=-A_M3, Jerk:=-J_M3);
            MovementStep:=40;
          end_if;
          
            
          40:
          if Comando_M3.AxisStatus.Standstill then
            c_MaxCurrent.Write(input:=0.5*MOTORMAXCURRENT);
            M3_coupled:=2;
            s_M3_Coupled.Write(input:=M3_coupled);
            MotoreM3Step:=Cmd_motore_M3_idle;
            MovementStep:=0;
            v_StartMovementCase:=0;
            
          end_if;

        end_case;
      
      end_if;
    
    elsif MotoreM3_Motion_Type=1 then
    //MOVIMENTO 1: ACCOPPIATO->DISACCOPPIATO
    
      if v_M3_LS_1 & M3_coupled=0 then
        //Motore si trova già in posizione di accoppiamento
        M3_coupled:=0;  
      
      elsif M3_coupled=2 | M3_coupled=1 then
        
        case MovementStep of
      
        0: //IDLE
        MovementStep:=v_StartMovementCase;
        
        
        10: //case per accendere il motore nel caso in cui sia spento
          M3_coupled:=1;
          c_MaxCurrent.Write(input:=MOTORMAXCURRENT);
          if (Comando_M3.AxisStatus.PowerOn=0) & (Comando_M3.AxisStatus.ReadyToPowerOn) then
              Comando_M3.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
          elsif Comando_M3.AxisStatus.PowerOn then      
            MovementStep:=20;
          end_if;
        
        20:
            if v_M3_LS_2=0 then
              Comando_M3.MoveEndless(Speed:=V_M3, Accel:=A_M3, Jerk:=J_M3);
              MovementStep:=30;
            end_if;
        30:
        
          if v_M3_LS_2 then
            Comando_M3.StopMove(Decel:=A_M3, Jerk:=J_M3);
            MovementStep:=40;
          end_if;
          
          
        40:
          if Comando_M3.AxisStatus.Standstill then
            c_MaxCurrent.Write(input:=0.1*MOTORMAXCURRENT);
            M3_coupled:=0;
            s_M3_Coupled.Write(input:=M3_coupled);
            MovementStep:=0;
            v_StartMovementCase:=0;
            MotoreM3Step:=Cmd_motore_M3_idle;
          end_if;
          
          
        end_case;
      
      end_if;
    elsif MotoreM3_Motion_Type=2 then
    case MovementStep of
      
        0: //IDLE
        MovementStep:=v_StartMovementCase;
        
        10: //POWER ON
          c_MaxCurrent.Write(input:=MOTORMAXCURRENT);
          if (Comando_M3.AxisStatus.PowerOn=0) & (Comando_M3.AxisStatus.ReadyToPowerOn) then
              Comando_M3.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
          elsif Comando_M3.AxisStatus.PowerOn then
            MovementStep:=20;
          end_if;
        
        20:
          Comando_M3.MoveRelative(Position:=P_NoStuck, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=0.5*V_M3, Accel:=0.5*A_M3, Decel:=0.5*A_M3, Jerk:=0.5*J_M3);
          MovementStep:=30;

        30:
          if Comando_M3.AxisStatus.Standstill then
            Comando_M3.MoveRelative(Position:=-P_NoStuck, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=-0.5*V_M3, Accel:=-0.5*A_M3, Decel:=-0.5*A_M3, Jerk:=-0.5*J_M3);
            v_ACK_M3_Mov:=1;
            MovementStep:=40;
          end_if;

        40:
          if Comando_M3.AxisStatus.Standstill then
            c_MaxCurrent.Write(input:=0.5*MOTORMAXCURRENT);
            MovementStep:=0;
            v_StartMovementCase:=0;
            MotoreM3Step:=Cmd_motore_M3_idle;
          end_if;
          
        end_case;
    else
      //errore
      MotoreM3Step:=Cmd_motore_M3_reset;
    
    end_if;
//==============================================================================

    Cmd_motore_M3_Error:
    
      ErrorState:=Comando_M3.AxisError; //AGGIORNAMENTO SERVER
      MotoreM3Step:=Cmd_motore_M3_stop;
//===========================================================================================      
    Cmd_motore_M3_stop:
      if Comando_M3.AxisStatus.Standstill & Comando_M3.AxisStatus.PowerOn=0 then
        MotoreM3Step:=Cmd_motore_M3_stopped;
      else
        Comando_M3.QuickStop(Decel:=1000000);//se asse in errore non esegue neppure l'operazione perchè spento (e in errore)
        Comando_M3.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
      end_if;
      
//=========================================================================================== 

    Cmd_motore_M3_stopped:
    //ATTESA RESET
//===========================================================================================

    Cmd_motore_M3_reset:

      Comando_M3.QuitError();
      M3_homed:=FALSE;
      v_ErrorState:=0; 
      if Comando_M3.AxisStatus.FiltRdy then
        MotoreM3Step:=Cmd_motore_M3_idle;
      end_if;

      M3_coupled:=0;
      MotoreM3_Motion_Type:=0;
      HomingStep:=0;
      MovementStep:=0;
      v_StartHomingCase:=0;
      v_StartMovementCase:=0;
      v_M3_Correction_Step:=M3_Correction_Step.Read();
      v_M3_LS_1:=0;
      v_M3_LS_2:=0;
      v_RecoupledDone:=0;
      v_ErrorState:=0;
//===========================================================================================  
  end_case;

	state := READY;
END_FUNCTION


FUNCTION GLOBAL Motore_M3::SetSequenceState
	VAR_INPUT
		Cmd_motore 	: t_sequence_Cmd_motore_M3;
		Motion_Type 	: DINT;
		StartCase 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  if Cmd_motore=Cmd_motore_M3_homing then
    v_StartHomingCase:=StartCase;
  elsif Cmd_motore=Cmd_motore_M3_movement then
    v_StartMovementCase:=StartCase;
  end_if;
  
  MotoreM3Step:=Cmd_motore;
  MotoreM3_Motion_Type:=Motion_Type;
  
  retcode:=true;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M3::Init
M3_homed:=FALSE;
M3_coupled:=0;
MotoreM3_Motion_Type:=0;

HomingStep:=0;
MovementStep:=0;

v_StartHomingCase:=0;
v_StartMovementCase:=0;

v_M3_Correction_Step:=M3_Correction_Step.Read();

v_M3_LS_1:=0;
v_M3_LS_2:=0;

v_RecoupledDone:=0;

v_ErrorState:=0;

END_FUNCTION


FUNCTION GLOBAL Motore_M3::GetHomedState
	VAR_OUTPUT
		Homed 	: BOOL;
	END_VAR
  
  Homed:=M3_homed;
END_FUNCTION


FUNCTION GLOBAL Motore_M3::GetCoupledState
	VAR_OUTPUT
		Coupled 	: DINT;
	END_VAR
  Coupled:=M3_coupled;
END_FUNCTION


FUNCTION GLOBAL Motore_M3::GetErrorState
	VAR_OUTPUT
		ErrorState 	: DINT;
	END_VAR

ErrorState:=v_ErrorState;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M3::s_M3_Homed::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	output := s_M3_Homed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M3::s_M3_Coupled::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	output := s_M3_Coupled;

END_FUNCTION


FUNCTION GLOBAL Motore_M3::GetMovDone
	VAR_OUTPUT
		OutParam 	: DINT;
	END_VAR
  OutParam:=v_ACK_M3_Mov;
END_FUNCTION


FUNCTION GLOBAL Motore_M3::GetRecoupledDone
	VAR_OUTPUT
		OutParam 	: DINT;
	END_VAR
OutParam:=v_RecoupledDone;
END_FUNCTION
