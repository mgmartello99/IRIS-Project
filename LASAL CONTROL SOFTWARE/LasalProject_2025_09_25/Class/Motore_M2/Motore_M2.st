//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Motore_M2"
	Revision           = "0.0"
	GUID               = "{CAA535AD-9E80-4541-82A9-CECF3E412031}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "100 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(720,180)">
	<Channels>
		<Server Name="ClassSvr" GUID="{907023D1-C017-4266-9B7C-56722491E150}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ErrorState" GUID="{998814D8-B9D2-45F6-8458-6B83B27E4CA8}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="MotoreM2Step" GUID="{7FF0C031-EC0E-4AC8-8140-DC46BFAFDCD4}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="s_1_3_pelletMode" GUID="{D2D400A7-40C3-419D-80AF-2711B852BBED}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_M2_Homed" GUID="{7E056185-F249-4865-9F36-B67424C5C014}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_pelletInIrisCharge" GUID="{04AA21D0-2A66-479A-8421-1100C260C687}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_tablet_InCharging" GUID="{62AA6F06-DF26-4A60-94EA-460F07C706D5}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="Comando_M2" Required="true" Internal="false"/>
		<Client Name="M2_LS" Required="false" Internal="false"/>
		<Client Name="SetPosition_Controller" Required="true" Internal="false"/>
	</Channels>
	<Separators>
		<Clients>
			<SepChn Position="1"/>
		</Clients>
	</Separators>
</Class>
*)
Motore_M2 : CLASS
	TYPE
	  t_sequence_Cmd_motore_M2 :  //! <Type Public="true" Name="t_sequence_Cmd_motore_M2"/>
	  (
	    Cmd_motore_M2_idle,
	    Cmd_motore_M2_homing,
	    Cmd_motore_M2_phasing,
	    Cmd_motore_M2_movement,
	    Cmd_motore_M2_reset,
	    Cmd_motore_M2_stop,
	    Cmd_motore_M2_stopped,
	    Cmd_motore_M2_Error
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	MotoreM2Step 	: SvrCh_t_sequence_Cmd_motore_M2_PTofCls_Motore_M2;
	ErrorState 	: SvrCh__LMCAXIS_ERROR;
	s_M2_Homed 	: SvrCh_DINT;
	s_tablet_InCharging 	: SvrCh_DINT;
	s_1_3_pelletMode 	: SvrCh_DINT;
	s_pelletInIrisCharge 	: SvrCh_DINT;
  //Clients:
	Comando_M2 	: CltChCmd__LMCAxis;
	M2_LS 	: CltCh_DINT;
	SetPosition_Controller 	: CltCh_DINT;
  //Variables:
		ActCommand 	: t_sequence_Cmd_motore_M2;
		M2_homed 	: BOOL;
		Movement_step 	: DINT;
		M5_InPos 	: DINT;
		V_CONTATORE_TARGET_CARICATI 	: DINT;
		v_target_in_charge_slider 	: DINT;
		v_ErrorState 	: DINT;
		v_StartHomingCase 	: DINT;
		v_StartMovementCase 	: DINT;
		HomingStep 	: DINT;
		v_M2_LS 	: DINT;
		v_ACK_M1_No_Stuck_Mov 	: DINT;
		v_Req_No_Stuck_Mov_M1 	: DINT;
		v_AlternatingHoming 	: DINT;
		v_InCharging 	: DINT;
		v_PelletAvailable 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetSequenceState
		VAR_INPUT
			Cmd_motore 	: t_sequence_Cmd_motore_M2;
			StartCase 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetHomedState
		VAR_OUTPUT
			Homed 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL ReadM5PositionState
		VAR_INPUT
			Param 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetTargetInSlider
		VAR_OUTPUT
			Status 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetErrorState
		VAR_OUTPUT
			ErrorState 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL Req_M1_Mov
		VAR_OUTPUT
			OutParam 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ACK_M1_Mov
		VAR_INPUT
			Param 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetPelletAvailable
		VAR_INPUT
			Param 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL s_M2_Homed::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _LMCAxis


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Motore_M2::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_MOTORE_M2
0$UINT, 0$UINT, (SIZEOF(::Motore_M2))$UINT, 
7$UINT, 3$UINT, 0$UINT, 
TO_UDINT(335833155), "Motore_M2", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Motore_M2.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::Motore_M2.MotoreM2Step.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(469952281), "MotoreM2Step", 
(::Motore_M2.ErrorState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2975757027), "ErrorState", 
(::Motore_M2.s_M2_Homed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1140291910), "s_M2_Homed", 
(::Motore_M2.s_tablet_InCharging.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1559250238), "s_tablet_InCharging", 
(::Motore_M2.s_1_3_pelletMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2239501700), "s_1_3_pelletMode", 
(::Motore_M2.s_pelletInIrisCharge.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2020284583), "s_pelletInIrisCharge", 
//Clients:
(::Motore_M2.Comando_M2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1987994953), "Comando_M2", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 114$UINT, 
(::Motore_M2.M2_LS.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4113379845), "M2_LS", 
(::Motore_M2.SetPosition_Controller.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(265130042), "SetPosition_Controller", 
END_FUNCTION


#define USER_CNT_Motore_M2 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Motore_M2] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Motore_M2::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Motore_M2, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_M2_Homed.pMeth			:= StoreMethod( #s_M2_Homed::Read(), #M_WR_DIRECT() );
	IF s_M2_Homed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_tablet_InCharging.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF s_tablet_InCharging.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_1_3_pelletMode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF s_1_3_pelletMode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_pelletInIrisCharge.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF s_pelletInIrisCharge.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL Motore_M2::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

//M2: CHARGE BUFFER

  v_M2_LS:=M2_LS.Read();
  
  s_M2_Homed.Write(input:=M2_homed);
  
  case MotoreM2Step of
//===========================================================================================
  
    Cmd_motore_M2_idle:

    if Comando_M2.AxisError.HwError then
      v_ErrorState:=1;   
      MotoreM2Step:=Cmd_motore_M2_Error;
    end_if;
//===========================================================================================
  
    Cmd_motore_M2_homing:

    // Si può pensare che la posizione di homing sia proprio quella di carica target poichè coincide con il tocco del LS
    
    if Comando_M2.AxisError.HwError then
      v_ErrorState:=1;   
      HomingStep:=0;
      MotoreM2Step:=Cmd_motore_M2_Error;
    end_if;
    
    case HomingStep of
    
    0://idle
      HomingStep:=v_StartHomingCase;
      
    5:
      if v_M2_LS then //Motore già in posizione.
        HomingStep:=50;
      else     
        HomingStep:=10;
      end_if;

      
    10://POER ON  
    
      if (Comando_M2.AxisStatus.PowerOn=0) & (Comando_M2.AxisStatus.ReadyToPowerOn) then
        Comando_M2.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
      elsif Comando_M2.AxisStatus.PowerOn then
        HomingStep:=20;
      end_if;
      
    20:
      Comando_M2.MoveEndless(Speed:=V_M2, Accel:=A_M2, Jerk:=J_M2);
      HomingStep:=30;
    
    30:
    if v_M2_LS then //quando tocca LS
      Comando_M2.StopMove(Decel:=A_M2, Jerk:=J_M2);
      HomingStep:=40;
    end_if;
 
    
    40://Controllo che il motore si sia fermato
    
      if Comando_M2.AxisStatus.Standstill then
          Comando_M2.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
          HomingStep:=50;
      end_if;
      
    50: 
       if Comando_M2.AxisStatus.PowerOn=0 then
          M2_homed:=TRUE;
          SetPosition_Controller.Write(input:=0);
          MotoreM2Step:=Cmd_motore_M2_idle;
          v_StartHomingCase:=0;
       end_if;
        
    end_case;
       
//===========================================================================================
   
Cmd_motore_M2_movement:

    
    if Comando_M2.AxisError.HwError then
      v_ErrorState:=1;   
      Movement_step:=0;
      MotoreM2Step:=Cmd_motore_M2_Error;
    end_if;
    
    case Movement_step of
      
      0: //IDLE, ATTESA COMANDI| Il motore è già nella posizione di carica->tocca il LS
        Movement_step:=v_StartMovementCase;
		
      10://M2 si trova nella posizione corretta di caricamento DEVE RUOTARE NEL VERSO CORRETTO PER SCARICARE TARGET, compirà 1 giro completo (quasi)
         if (Comando_M2.AxisStatus.PowerOn=0) & (Comando_M2.AxisStatus.ReadyToPowerOn) then
            Comando_M2.PowerOn(Mode:=LMCAXIS_MOVE_ANY_WAY);
         elsif Comando_M2.AxisStatus.PowerOn then
            if v_AlternatingHoming=1 then
              Movement_step:=20;
            elsif v_AlternatingHoming=-1 then
              Movement_step:=200;
            end_if;
          end_if;
      
      20:
        Comando_M2.MoveRelative(Position:=300000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=V_M2, Accel:=A_M2, Decel:=A_M2, Jerk:=J_M2);
        Movement_step:=30;
		
      30:
        if Comando_M2.AxisStatus.InPosition & Comando_M2.AxisStatus.Standstill then
          Comando_M2.MoveAbsolute(Position:= 2300000, Speed:=V_M2, Accel:=A_M2, Decel:=A_M2, Jerk:=J_M2);
          s_pelletInIrisCharge.Write(input:=1);
          v_InCharging+=1;
          s_tablet_InCharging.Write(input:=v_InCharging);
          Movement_step:=40;
        end_if;
          
      40:
        if M2_LS.Read() | Comando_M2.AxisStatus.InPosition then
          v_target_in_charge_slider:=1;
          Comando_M2.StopMove(Decel:= A_M2, Jerk:= J_M2);
          Movement_step:=50;
        end_if;

      50:
        if M5_InPos then
            V_CONTATORE_TARGET_CARICATI+=1;
            v_Req_No_Stuck_Mov_M1:=1;
            v_target_in_charge_slider:=0;
            Movement_step:=60;
        end_if;

      60://implementazione del movimento sù e giù dello scivolo per evitare lo stuck di un pellet
        if v_ACK_M1_No_Stuck_Mov then
          v_Req_No_Stuck_Mov_M1:=0;
          v_ACK_M1_No_Stuck_Mov:=0;
          v_InCharging+=1;
          s_pelletInIrisCharge.Write(input:=2);
          s_tablet_InCharging.Write(input:=v_InCharging);
            if s_1_3_pelletMode.Read()=1 then //1 pellet
            Movement_step:=180;
          elsif s_1_3_pelletMode.Read()=0 then
            Movement_step:=70;
          end_if;
        end_if;

       70:
         Comando_M2.MoveRelative(Position:=- 300000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=- V_M2, Accel:=- A_M2, Decel:=- A_M2, Jerk:=- J_M2);
         Movement_step:=80;
      
       80:
         if Comando_M2.AxisStatus.InPosition & Comando_M2.AxisStatus.Standstill then
            Comando_M2.MoveEndless(Speed:=- V_M2, Accel:=- A_M2, Jerk:=- J_M2);
            s_pelletInIrisCharge.Write(input:=3);
            v_InCharging+=1;
            s_tablet_InCharging.Write(input:=v_InCharging);
            Movement_step:=84;
         end_if;
          
       84:
         if M2_LS.Read() then
            Comando_M2.StopMove(Decel:=- A_M2, Jerk:=- J_M2);
            Movement_step:=85;
         end_if;
      
        85:
          Comando_M2.MoveRelative(Position:=- 50000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=- V_M2, Accel:=- A_M2, Decel:=- A_M2, Jerk:=- J_M2);
          Movement_step:=90;
      
        90:
          if Comando_M2.AxisStatus.InPosition & Comando_M2.AxisStatus.Standstill then
              v_target_in_charge_slider:=1;
              Comando_M2.StopMove(Decel:=-A_M2, Jerk:=-J_M2);
              Movement_step:=100;
          end_if;

        100:
           if M5_InPos then
              V_CONTATORE_TARGET_CARICATI+=1;
              v_Req_No_Stuck_Mov_M1:=1;
              v_target_in_charge_slider:=0;
              Movement_step:=110;
           end_if;


        110://implementazione del movimento sù e giù dello scivolo per evitare lo stuck di un pellet
        
          if v_ACK_M1_No_Stuck_Mov then
            v_Req_No_Stuck_Mov_M1:=0;
            v_ACK_M1_No_Stuck_Mov:=0;
            s_pelletInIrisCharge.Write(input:=4);
            v_InCharging+=1;
            s_tablet_InCharging.Write(input:=v_InCharging);
            Movement_step:=120;
          end_if;
     
       120:
          Comando_M2.MoveRelative(Position:= 500000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:= V_M2, Accel:= A_M2, Decel:= A_M2, Jerk:= J_M2);
          Movement_step:=130;
		
       130:
          if Comando_M2.AxisStatus.InPosition & Comando_M2.AxisStatus.Standstill then
              Comando_M2.MoveEndless(Speed:= V_M2, Accel:= A_M2, Jerk:= J_M2);
              s_pelletInIrisCharge.Write(input:=5);
              v_InCharging+=1;
              s_tablet_InCharging.Write(input:=v_InCharging);
              Movement_step:=140;
          end_if;
          
        140:
           if M2_LS.Read() then
              v_target_in_charge_slider:=1;
              Comando_M2.StopMove(Decel:= A_M2, Jerk:= J_M2);
              Movement_step:=150;
          end_if;
      
        145:
            Comando_M2.MoveRelative(Position:= 500000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:= V_M2, Accel:= A_M2, Decel:= A_M2, Jerk:= J_M2);
            Movement_step:=150;
        
        150:
           if M5_InPos then
              V_CONTATORE_TARGET_CARICATI+=1;
              v_Req_No_Stuck_Mov_M1:=1;
              v_target_in_charge_slider:=0;
              Movement_step:=160;
           end_if;


        160://implementazione del movimento sù e giù dello scivolo per evitare lo stuck di un pellet
          if v_ACK_M1_No_Stuck_Mov then
            v_Req_No_Stuck_Mov_M1:=0;
            v_ACK_M1_No_Stuck_Mov:=0;
            s_pelletInIrisCharge.Write(input:=6);
            v_InCharging+=1;
            s_tablet_InCharging.Write(input:=v_InCharging);
            Movement_step:=180;
          end_if;

        180:
          Comando_M2.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
          Movement_step:=190;
		
        190:   
          if Comando_M2.AxisStatus.PowerOn=0 then
            v_AlternatingHoming:=-1*v_AlternatingHoming;
            v_StartMovementCase:=0;
            Movement_step:=0;
            MotoreM2Step:=Cmd_motore_M2_idle;
          end_if;
        
        
        200:
            Comando_M2.MoveRelative(Position:=-300000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=-V_M2, Accel:=-A_M2, Decel:=-A_M2, Jerk:=-J_M2);
            Movement_step:=210;
      
        210:
            if Comando_M2.AxisStatus.InPosition & Comando_M2.AxisStatus.Standstill then
              Comando_M2.MoveEndless(Speed:=-V_M2, Accel:=-A_M2, Jerk:=-J_M2);
              s_pelletInIrisCharge.Write(input:=1);
              v_InCharging+=1;
              s_tablet_InCharging.Write(input:=v_InCharging);
              Movement_step:=220;
            end_if;
          
        220:
            if M2_LS.Read() | Comando_M2.AxisStatus.InPosition then
              v_target_in_charge_slider:=1;
              Comando_M2.StopMove(Decel:= -A_M2, Jerk:=-J_M2);
              Movement_step:=230;
            end_if;

        230:
            if M5_InPos then
              V_CONTATORE_TARGET_CARICATI+=1;
              v_Req_No_Stuck_Mov_M1:=1;
              v_target_in_charge_slider:=0;
              Movement_step:=235;
            end_if;

        235://implementazione del movimento sù e giù dello scivolo per evitare lo stuck di un pellet
        
            if v_ACK_M1_No_Stuck_Mov then
               v_Req_No_Stuck_Mov_M1:=0;
               v_ACK_M1_No_Stuck_Mov:=0;
               s_pelletInIrisCharge.Write(input:=2);
               v_InCharging+=1;
               s_tablet_InCharging.Write(input:=v_InCharging);
               if s_1_3_pelletMode.Read()=1 then //1 pellet
                  Movement_step:=340;
               elsif s_1_3_pelletMode.Read()=0 then
                  Movement_step:=240;
               end_if;
               
             end_if;
      
        240:
          Comando_M2.MoveRelative(Position:=300000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=V_M2, Accel:=A_M2, Decel:=A_M2, Jerk:=J_M2);
          Movement_step:=250;
          
        250:
          if Comando_M2.AxisStatus.InPosition & Comando_M2.AxisStatus.Standstill then
            Comando_M2.MoveEndless(Speed:=V_M2, Accel:=A_M2, Jerk:=J_M2);
            s_pelletInIrisCharge.Write(input:=3);
            v_InCharging+=1;
            s_tablet_InCharging.Write(input:=v_InCharging);
            Movement_step:=260;
          end_if;
            
        260:
           if M2_LS.Read() then
            v_target_in_charge_slider:=1;
            Comando_M2.StopMove(Decel:=A_M2, Jerk:=J_M2);
            Movement_step:=270;
           end_if;


        270:
           if M5_InPos then
             V_CONTATORE_TARGET_CARICATI+=1;
             v_Req_No_Stuck_Mov_M1:=1;
             v_target_in_charge_slider:=0;
             Movement_step:=280;
           end_if;


        280://implementazione del movimento sù e giù dello scivolo per evitare lo stuck di un pellet
        
          if v_ACK_M1_No_Stuck_Mov then
             v_Req_No_Stuck_Mov_M1:=0;
             v_ACK_M1_No_Stuck_Mov:=0;
             s_pelletInIrisCharge.Write(input:=4);
             v_InCharging+=1;
             s_tablet_InCharging.Write(input:=v_InCharging);
             Movement_step:=290;
          end_if;
       
      
        290:
          Comando_M2.MoveRelative(Position:=-300000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=-V_M2, Accel:=-A_M2, Decel:=-A_M2, Jerk:=-J_M2);
          Movement_step:=300;
        
        300:
          if Comando_M2.AxisStatus.InPosition & Comando_M2.AxisStatus.Standstill then
            Comando_M2.MoveEndless(Speed:=-V_M2, Accel:=-A_M2, Jerk:=-J_M2);
            s_pelletInIrisCharge.Write(input:=5);
            v_InCharging+=1;
            s_tablet_InCharging.Write(input:=v_InCharging);
            Movement_step:=310;
          end_if;
          
        310:
          if M2_LS.Read() then
            v_target_in_charge_slider:=1;
            Comando_M2.StopMove(Decel:=-A_M2, Jerk:=-J_M2);
            Movement_step:=320;
          end_if;
          
        320:
          if M5_InPos then
            V_CONTATORE_TARGET_CARICATI+=1;
            v_Req_No_Stuck_Mov_M1:=1;
            v_target_in_charge_slider:=0;
            Movement_step:=330;
          end_if;
          
        330://implementazione del movimento sù e giù dello scivolo per evitare lo stuck di un pellet
          if v_ACK_M1_No_Stuck_Mov then
             v_Req_No_Stuck_Mov_M1:=0;
             v_ACK_M1_No_Stuck_Mov:=0;
             s_pelletInIrisCharge.Write(input:=6);
             v_InCharging+=1;
             s_tablet_InCharging.Write(input:=v_InCharging);
             Movement_step:=340;
          end_if;

        340:
          Comando_M2.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
          Movement_step:=190;


    end_case;

//===========================================================================================

    Cmd_motore_M2_Error:
    
      ErrorState:=Comando_M2.AxisError; //AGGIORNAMENTO SERVER
      MotoreM2Step:=Cmd_motore_M2_stop;
//===========================================================================================
      
    Cmd_motore_M2_stop:

      
      if Comando_M2.AxisStatus.Standstill & Comando_M2.AxisStatus.PowerOn=0 then
        MotoreM2Step:=Cmd_motore_M2_stopped;
      else
        Comando_M2.QuickStop(Decel:=1000000);//se asse in errore non esegue neppure l'operazione perchè spento (e in errore)
        Comando_M2.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
      end_if;
//===========================================================================================
      
    Cmd_motore_M2_stopped:
    //ATTESA RESET
//===========================================================================================

    Cmd_motore_M2_reset:

      Comando_M2.QuitError();
      M2_homed:=FALSE;
      v_ErrorState:=0; 
      if Comando_M2.AxisStatus.FiltRdy then
        MotoreM2Step:=Cmd_motore_M2_idle;
      end_if;

      Movement_step:=0;
      M5_InPos:=0;
      v_M2_LS:=0;
      v_ACK_M1_No_Stuck_Mov:=0;
      v_target_in_charge_slider:=0;
      v_StartHomingCase:=0;
      v_StartMovementCase:=0;
      HomingStep:=0;
      v_ErrorState:=0;
      s_pelletInIrisCharge.Write(input:=0);
      //s_1_3_pelletMode.Write(input:=0);
      
      if v_PelletAvailable<=V_CONTATORE_TARGET_CARICATI then
        s_tablet_InCharging.Write(input:=0);
        v_InCharging:=0;
        V_CONTATORE_TARGET_CARICATI:=0;
      end_if;
      
      
//===========================================================================================  
  end_case;

	state := READY;
END_FUNCTION


FUNCTION GLOBAL Motore_M2::SetSequenceState
	VAR_INPUT
		Cmd_motore 	: t_sequence_Cmd_motore_M2;
		StartCase 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  if Cmd_motore=Cmd_motore_M2_homing then
    v_StartHomingCase:=StartCase;
  elsif Cmd_motore=Cmd_motore_M2_movement then
    v_StartMovementCase:=StartCase;
  end_if;

  


  MotoreM2Step:=Cmd_motore;
  retcode:=true;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M2::Init
M2_homed:=FALSE;
Movement_step:=0;
M5_InPos:=0;
v_M2_LS:=0;

v_ACK_M1_No_Stuck_Mov:=0;

V_CONTATORE_TARGET_CARICATI:=0;
v_target_in_charge_slider:=0;


v_StartHomingCase:=0;
v_StartMovementCase:=0;

HomingStep:=0;

v_ErrorState:=0;

v_AlternatingHoming:=1;

v_InCharging:=0;

v_PelletAvailable:=0;

END_FUNCTION


FUNCTION GLOBAL Motore_M2::GetHomedState
	VAR_OUTPUT
		Homed 	: BOOL;
	END_VAR
  
  Homed:=M2_homed;
END_FUNCTION


FUNCTION GLOBAL Motore_M2::ReadM5PositionState
	VAR_INPUT
		Param 	: DINT;
	END_VAR

  M5_InPos:=Param;
END_FUNCTION


FUNCTION GLOBAL Motore_M2::GetTargetInSlider
	VAR_OUTPUT
		Status 	: DINT;
	END_VAR
  
//v_target_in_charge_slider:=Status;
Status:=v_target_in_charge_slider;

END_FUNCTION


FUNCTION GLOBAL Motore_M2::GetErrorState
	VAR_OUTPUT
		ErrorState 	: DINT;
	END_VAR

  ErrorState:=v_ErrorState;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M2::s_M2_Homed::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	output := s_M2_Homed;

END_FUNCTION


FUNCTION GLOBAL Motore_M2::Req_M1_Mov
	VAR_OUTPUT
		OutParam 	: DINT;
	END_VAR
  OutParam:=v_Req_No_Stuck_Mov_M1;
END_FUNCTION


FUNCTION GLOBAL Motore_M2::ACK_M1_Mov
	VAR_INPUT
		Param 	: DINT;
	END_VAR
  v_ACK_M1_No_Stuck_Mov:=Param;
END_FUNCTION


FUNCTION GLOBAL Motore_M2::GetPelletAvailable
	VAR_INPUT
		Param 	: DINT;
	END_VAR
v_PelletAvailable:=Param;
END_FUNCTION
