//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "MMBuffer"
	Revision           = "0.0"
	GUID               = "{EAD69980-E97A-44EA-856A-EA6BDB5E74EC}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "storage of data with arbitrary length ">
	<Channels>
		<Server Name="m_udLength" GUID="{262DC349-C7B7-413E-9E83-4FBB66D306D9}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FimLuc"/>
		<Dokumentation Revision="0.0" Date="2015-10-07" Author="FimLuc" Company="Sigmatek" Description="Kopie von MerkerEx"/>
	</RevDoku>
</Class>
*)
MMBuffer : CLASS
  //Servers:
	m_udLength 	: SvrChCmd_UDINT;
  //Clients:
  //Variables:
		m_pData 	: ^USINT;			//! <Variable Comment="pointer to data of variable length" Name="m_pData"/>
		m_udAllocated 	: UDINT;			//! <Variable Comment="size of allocated block of memory" Name="m_udAllocated"/>
		MuxHdl 	: ^void;
		m_pChgBytes 	: ^USINT;
  //Functions:
				//! <Function Comment=" 22.06.2004 in New_inst auch EXCHANGE_DATA_PTR dazugebaut weil Billion nicht &#13;&#10; ramex sondern MMuffer für die IPRs benutzt!! &#13;&#10; the constructor allocates memory, if the m_udLength&#13;&#10; data element is set, otherwise it just returns OK&#13;&#10;Wenn das Datenelement m_udLength initialisiert worden ist,&#13;&#10;dann wird Speicher angefordert, sonst einfach C_OK zurück-&#13;&#10;geliefert.&#13;&#10;" Name="MMBuffer"/>
	FUNCTION MMBuffer
		VAR_OUTPUT
			ret_code 	: ConfStates;			//! <Variable Comment="Zeiger auf den internen Datenpuffer" Name="MMBuffer.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Use this function to change the size of the data buffer&#13;&#10;Diese Funktion kann die Größe des Datenpuffers ändern.&#13;&#10;" Name="SetSize"/>
	FUNCTION VIRTUAL GLOBAL SetSize
		VAR_INPUT
			udSize 	: UDINT;			//! <Variable Comment="needing this size of memory" Name="SetSize.udSize"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment=" Use this function to change a part of the data buffer.&#13;&#10; Call SetSize before, to make sure, the internal data buffer is&#13;&#10; sufficiently big.&#13;&#10;Mit dieser Funktion kann ein Teil des internen Datenpuffers&#13;&#10;beschrieben werden. Um sicherzustellen, daß ausreichend Speicher&#13;&#10;zur Verfügung steht, muß vorher ggf. SetSize() aufgerufen werden.&#13;&#10;" Name="SetDataAt"/>
	FUNCTION VIRTUAL GLOBAL SetDataAt
		VAR_INPUT
			pData 	: ^USINT;			//! <Variable Comment="pointer to a new block of memory" Name="SetDataAt.pData"/>
			udSize 	: UDINT;			//! <Variable Comment=" Anzahl der zu kopierenden Bytes" Name="SetDataAt.udSize"/>
			udAt 	: UDINT;			//! <Variable Comment=" start copy at this offset in the internal buffer" Name="SetDataAt.udAt"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment=" Call this function, to get back a certain part from&#13;&#10; the stored data&#13;&#10; Mit dieser Funktion kann ein bestimmter Teil des internen Daten-&#13;&#10;puffers zurückgelesen werden.&#13;&#10;" Name="GetDataAt"/>
	FUNCTION VIRTUAL GLOBAL GetDataAt
		VAR_INPUT
			pData 	: ^USINT;			//! <Variable Comment=" Zeiger auf einen ausreichend großen Ziel-Datenpuffer" Name="GetDataAt.pData"/>
			udSize 	: UDINT;
			udAt 	: UDINT;			//! <Variable Comment=" Start-Offset für den Kopiervorgang" Name="GetDataAt.udAt"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment=" Mit dieser Funktion kann der gesamte interne Datenpuffer des&#13;&#10; Objekts gesetzt werden. Die Funktion erwartet sich einen Zeiger auf&#13;&#10; einen Datenpuffer mit der Größe des internen Puffers. Exakt diese&#13;&#10; Datenmenge wird dann nämlich auf den internen Puffer umkopiert.&#13;&#10; this is the function that enables the user to&#13;&#10; set all the data of the data buffer. The function expects a&#13;&#10; pointer to a data buffer with at least the size&#13;&#10; of the internal data buffer, exactly the size of the internal&#13;&#10; buffer is copied from the source&#13;&#10;" Name="SetData"/>
	FUNCTION VIRTUAL GLOBAL SetData
		VAR_INPUT
			pData 	: ^USINT;
		END_VAR;
				//! <Function Comment="returns the size of the internal data buffer in bytes&#13;&#10;Liefert die Größe des internen Datenpuffers.&#13;&#10;" Name="GetSize"/>
	FUNCTION GLOBAL GetSize
		VAR_OUTPUT
			udSize 	: UDINT;
		END_VAR;
				//! <Function Comment=" Call this function to get all the data back from&#13;&#10; the internal buffer.&#13;&#10;  Diese Funktion kopiert den Inhalt des internen Datenpuffers auf&#13;&#10; den bereitgestellten Puffer um.&#13;&#10;" Name="GetData"/>
	FUNCTION GLOBAL GetData
		VAR_INPUT
			pData 	: ^USINT;
		END_VAR;
				//! <Function Comment="The function returns the pointer to the internal data buffer of the MMuffer object. The&#13;&#10;results of this function may vary between different calls to this function due to calls&#13;&#10;to the SetSize function inbetween.&#13;&#10;Therefore it&apos;s not recommanded to access the internal data buffer by means of this&#13;&#10;function!&#13;&#10;Die Funktion liefert einen Zeiger auf den internen Datenpuffer des MMuffer-&#13;&#10;Objekts zurück. Wenn zwischen einzelnen Aufrufen dieser Funktion die&#13;&#10;Funktion SetSize aufgerufen wird, dann kann sich dieser Zeiger verändern.&#13;&#10;Daher wird der Zugriff auf diesen Puffer nicht empfohlen!&#13;&#10;" Name="GetDataPtr"/>
	FUNCTION GLOBAL GetDataPtr
		VAR_OUTPUT
			pData 	: ^USINT;			//! <Variable Comment="pointer to internal data buffer" Name="GetDataPtr.pData"/>
		END_VAR;
				//! <Function Comment="Use this function to assign a new block of memory to the&#13;&#10;MMuffer - object. m_udLength has to be changed simultaniously.&#13;&#10;" Name="SetDataPtr"/>
	FUNCTION GLOBAL SetDataPtr
		VAR_INPUT
			pData 	: ^void;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;function does the memory allocation&#13;&#10;" Name="Alloc"/>
	FUNCTION VIRTUAL GLOBAL Alloc
		VAR_INPUT
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pCode 	: ^void;			//! <Variable Comment="pointer to allocated block" Name="Alloc.pCode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;checks for udGrowBy and calculates the size of memory&#13;&#10;which is actually to allocate&#13;&#10;" Name="GetNewBlockSize"/>
	FUNCTION GetNewBlockSize
		VAR_INPUT
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bAlloc 	: BOOL;			//! <Variable Comment="is it necessary to alloc a new block?" Name="GetNewBlockSize.bAlloc"/>
		END_VAR;
	
	FUNCTION GLOBAL LockOn;
	
	FUNCTION GLOBAL LockOff;
	
	FUNCTION SetSizeCTor
		VAR_INPUT
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL GetDataAtWithChgBytes
		VAR_INPUT
			pData 	: ^USINT;
			udSize 	: UDINT;
			udAt 	: UDINT;
			pChgBytes 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL m_udLength::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MMBuffer::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MMBUFFER
0$UINT, 0$UINT, (SIZEOF(::MMBuffer))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2181466683), "MMBuffer", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::MMBuffer.m_udLength.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3370139294), "m_udLength", 
//Clients:
END_FUNCTION


#define USER_CNT_MMBuffer 5

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MMBuffer] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MMBuffer::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_MMBuffer, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Read		:= #Read();
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #SetSize();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #SetDataAt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetDataAt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #SetData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #Alloc();

#pragma warning (default : 74)
	m_udLength.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF m_udLength.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= MMBuffer();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include <RTOS_MemIntern.h>
#include <lsl_st_mt.h>
#include <rtos_privheader.h>

VAR_EXTERNAL
  mt_api   : ^LSL_MT_TYPE; // multitask interface
END_VAR

FUNCTION MMBuffer::MMBuffer
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  MuxHdl        := NIL;
	ret_code := SetSizeCTor(m_udLength);

END_FUNCTION
FUNCTION GLOBAL MMBuffer::LockOn
  
  if(MuxHdl <> NIL) then
    OS_MT_WAIT(MuxHdl); 
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL MMBuffer::LockOff
  
  if(MuxHdl <> NIL) then
    OS_MT_SIGNAL(MuxHdl); 
  end_if;
  
END_FUNCTION

FUNCTION HexChar
  VAR_INPUT
    hxindex : USINT;
  END_VAR
  VAR_OUTPUT
    retcode : USINT;
  END_VAR
  VAR
  	ph : ^USINT;
  END_VAR
  
  ph      := "0123456789ABCDEF";
  ph      += hxindex and 16#0F;
  retcode := ph^;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMBuffer::Init
  VAR
  	label : array[0..16] of usint;
    tmp : udint;
  END_VAR
  
  IF((mt_api <> NIL) & (MuxHdl = 0)) THEN
  
    tmp$^MMBuffer := this;  
    label[0]$udint := 16#5F4d4d4d; // MMM_ 
    label[4]       := HexChar(to_usint(tmp shr 28));
    label[5]       := HexChar(to_usint(tmp shr 24));
    label[6]       := HexChar(to_usint(tmp shr 20));
    label[7]       := HexChar(to_usint(tmp shr 16));
    label[8]       := HexChar(to_usint(tmp shr 12));
    label[9]       := HexChar(to_usint(tmp shr  8));
    label[10]      := HexChar(to_usint(tmp shr  4));
    label[11]      := HexChar(to_usint(tmp       ));
    label[12]      := 0;

    MuxHdl := OS_MT_CREATESEMAPHORE(MTSEMATYPE_MUTEX, 
                                    1,    // initvalue
                                    0,    // flags: 0 means create unconitionally
                                    #label[0] 
                                    );
  END_IF;

END_FUNCTION
FUNCTION MMBuffer::SetSizeCTor
	VAR_INPUT
		udSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ConfStates;
	END_VAR
VAR
	pData			: ^USINT;
	udOldLen		: UDINT;
	pChgBytes		: ^USINT;
END_VAR

  retcode := C_OK;
  if(m_pData = nil) then
    m_udLength := 0;
  end_if;

  if GetNewBlockSize(udSize) then // ok if length didn't change
    udOldLen := m_udLength;
    pData    := Alloc(m_udAllocated)$^USINT;
    pChgBytes := _alloc_resize(m_udAllocated)$^USINT;
    if(udSize & (pData = nil | pChgBytes = nil)) then
      if pData <> nil then
        _free(pData);
      end_if;
      if pChgBytes <> nil then
        _free(pChgBytes);
      end_if;
      retcode := C_OUTOF_NEAR;
      return;
    end_if;
    
    _memset(pData, 0, udSize);
    m_pData    := pData;
    m_udLength := udSize;
    _memset(pChgBytes, 0, m_udAllocated);
    m_pChgBytes := pChgBytes;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMBuffer::SetSize
	VAR_INPUT
		udSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
    ptr, freeptr, tempptr : ^void;
    chgbytes_ptr, chgbytes_freeptr : ^void;
    len, siz : udint;
  END_VAR

  ret_code := C_OK;
  freeptr  := nil;
  chgbytes_freeptr := nil;

  LockOn(); // *****************************************
  ptr := m_pData;
  chgbytes_ptr := m_pChgBytes;
  len := m_udLength;
  
  if(ptr = nil) then
    len := 0; // force length to 0
  end_if;
  
  if(udSize <> len) then
      // do not force any call of function free --> runtime watchdog will occur because free can take a while
      // note: realloc is using function free as well
      freeptr := ptr;
      ptr     := nil;
      chgbytes_freeptr := chgbytes_ptr;
      chgbytes_ptr     := nil;
      if(udSize <> 0) then
        ptr := _alloc_resize(udSize); // alloc new block
        chgbytes_ptr := _alloc_resize(udSize); // alloc new block
        if(ptr = nil | chgbytes_ptr = nil) then
        
          ret_code := C_OUTOF_NEAR; // error: too less memory
          
          tempptr := ptr;
          ptr     := freeptr; // ptr auf den ursprünglichen Wert setzen
          if(tempptr = nil) then
            freeptr  := nil;
          else
            freeptr := tempptr; // bewirkt ein free des allokierten, aber nicht benötigten Speichers
          end_if;
          
          tempptr := chgbytes_ptr;
          chgbytes_ptr := chgbytes_freeptr; // chgbytes_ptr auf den ursprünglichen Wert setzen
          if(chgbytes_ptr = nil) then
            chgbytes_freeptr  := nil;
          else
            chgbytes_freeptr := tempptr; // bewirkt ein free des allokierten, aber nicht benötigten Speichers
          end_if;
          
        else 
        
          if(freeptr <> nil) then // copy data ?
            siz := len;
            if(siz > udSize) then
              siz := udSize;
            end_if;
            _memcpy(ptr, freeptr, siz); // copy data
            _memcpy(chgbytes_ptr, chgbytes_freeptr, siz); // copy chgbytes
          end_if;
          if(len < udSize) then
            _memset(ptr+len, 0, udSize-len); // initialize new part
            _memset(chgbytes_ptr+len, 0, udSize-len); // initialize new part
          end_if;
          
        end_if;
      end_if;
  end_if;

  if (ret_code = C_OK) then
    m_pData    := ptr$^usint;
    m_pChgBytes := chgbytes_ptr$^usint;
    m_udLength := udSize;

  end_if;

  LockOff(); // ********************************************
  
  if(freeptr <> nil) then
    _free(freeptr); // free memory without lock
  end_if;
  if(chgbytes_freeptr <> nil) then
    _free(chgbytes_freeptr); // free memory without lock
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL MMBuffer::GetSize
	VAR_OUTPUT
		udSize 	: UDINT;
	END_VAR

	udSize := m_udLength;

END_FUNCTION

FUNCTION GLOBAL MMBuffer::GetData
	VAR_INPUT
		pData 	: ^USINT;
	END_VAR

  GetDataAt(pData, m_udLength, 0);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMBuffer::GetDataAt
	VAR_INPUT
		pData 	: ^USINT;
		udSize 	: UDINT;
		udAt 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  LockOn(); // *****************************************
	if(m_pData <> nil) & (m_udLength >= udAt+udSize) then
    _memcpy(pData, m_pData+udAt, udSize);
    ret_code := C_OK;
  else
    ret_code := C_OUTOF_NEAR;
  end_if;
  LockOff(); // ********************************************

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMBuffer::SetDataAt
	VAR_INPUT
		pData 	: ^USINT;
		udSize 	: UDINT;
		udAt 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;
  
  LockOn(); // *****************************************
  if(udSize+udAt > m_udLength) then	
    ret_code := C_OUTOF_NEAR;
  else
    _memcpy(m_pData+udAt, pData, udSize);
    // Dort wo was geschrieben wurde, wird in m_pChgBytes ein 1er reingeschrieben, 
    // damit man weiß, was ur Gegenstation gesendet werden muss.
    _memset(m_pChgBytes+udAt, 1, udSize);
	end_if;
  LockOff(); // ********************************************

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMBuffer::SetData
	VAR_INPUT
		pData 	: ^USINT;
	END_VAR
  
	SetDataAt(pData, m_udLength, 0);

END_FUNCTION

FUNCTION GLOBAL MMBuffer::SetDataPtr
	VAR_INPUT
		pData 	: ^void;
	END_VAR

 m_pData := pData$^usint;

END_FUNCTION

FUNCTION GLOBAL MMBuffer::GetDataPtr
	VAR_OUTPUT
		pData 	: ^USINT;
	END_VAR

  pData := m_pData;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMBuffer::m_udLength::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

  output := m_udLength;

END_FUNCTION
FUNCTION MMBuffer::GetNewBlockSize
	VAR_INPUT
		udSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bAlloc 	: BOOL;
	END_VAR

  bAlloc := false;
  if(udSize <> m_udLength) then
    if(udSize <> 0) then
      m_udAllocated := udSize;
      bAlloc := true;
      return;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MMBuffer::Alloc
	VAR_INPUT
		udSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pCode 	: ^void;
	END_VAR
  VAR
  	ptr : ^usint;
  END_VAR

  ptr   := m_pData;
  pCode := nil;

  if(ptr <> nil) then
    if(udSize = 0) then
      _free(ptr);
    else
      pCode := _realloc(ptr, udSize);
    end_if;
  else
    pCode := _alloc_resize(udSize);
  end_if;

END_FUNCTION

FUNCTION GLOBAL MMBuffer::GetDataAtWithChgBytes
	VAR_INPUT
		pData 	: ^USINT;
		udSize 	: UDINT;
		udAt 	: UDINT;
		pChgBytes 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  LockOn(); // *****************************************
	if(m_pData <> nil) & (m_udLength >= udAt+udSize) then
    _memcpy(pData, m_pData+udAt, udSize);
    if(pChgBytes <> nil) then
      _memcpy(pChgBytes, m_pChgBytes+udAt, udSize);
      // Die Info was geschrieben wurde ist dem Aufrufer übergeben worden. 
      // Der Aufrufer ist jetzt dafür verantwortlich, dass das gesendet wird. 
      // Die Änderungsinfo kann daher jetzt wieder zurückgesetzt werden.
      _memset(m_pChgBytes+udAt, 0, udSize);
    end_if;
    ret_code := C_OK;
  else
    ret_code := C_OUTOF_NEAR;
  end_if;
  LockOff(); // ********************************************

END_FUNCTION
