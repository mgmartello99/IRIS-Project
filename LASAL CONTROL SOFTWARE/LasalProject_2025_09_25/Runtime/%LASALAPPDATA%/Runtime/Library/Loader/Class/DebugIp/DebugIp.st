//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#include "RTOS_IprIntern.h"
#pragma using BaseIp
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "DebugIp"
	Revision           = "0.1"
	GUID               = "{5F696F74-1A76-45B0-A22D-242E83C481B9}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="pCmd">
		</Server>
		<Client Name="objBaseIp" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FimLuc"/>
		<Dokumentation Revision="0.1" Date="2015-10-07" Author="FimLuc" Company="Sigmatek" Description="TXCommands I_INIT_MERKEREX  und I_MERKEREX hinzugefügt"/>
	</RevDoku>
	<Network Name="DebugIp">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{7EB4D0AD-27CC-42FE-8276-374CDA4CD2E9}"
				Class      = "BaseIp"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="pCmd"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.pCmd" Destination="_base.pCmd" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using BaseIp

DebugIp : CLASS
: BaseIp
	TYPE
	  CmdIpr :
	  (
	    GET_IP_HEAD_ADDRESS,
	    GET_IP_ADDRESS,
	    GET_CHKSUM,
	    SET_TRIGGER,
	    GET_LOAD_STATE,
	    SET_BREAKPOINT,
	    CMD_SINGLESTEP,
	    CMD_RUN_IPR,
	    SET_CODE_POINTER,
	    GET_FUNK_STATE,
	    CMD_STEPOVER,
	    CMD_STEPOUT,
	    CMD_HOLD,
	    CMD_REMOVE_ALL_BP,
	    GET_NBR_OF_IP_PROGS
	  )$UINT;
	  SEG_INFO : STRUCT
	    isAvail : BOOL;
	    isLast : BOOL;
	    segNbr : UINT;
	    segLen : UINT;
	    pData : ^USINT;
	    cmd : USINT;
	    reqLen : UDINT;
	    fGetResp : BOOL;
	    segNbrResp : UINT;
	  END_STRUCT;
	END_TYPE
  //Servers:
  //Clients:
	objBaseIp 	: CltChCmd_BaseIp;
  //Variables:
		m_udIdTool 	: HDINT;
		m_udLastCall 	: UDINT;
		m_bMarkedForDeletion 	: BOOL;
		m_cmdIf 	: ^pVoid;
		m_rxCounter 	: UDINT;
		m_nextSegNbr 	: UINT;
		m_pRxBuf 	: ^USINT;
		m_pTxBuf 	: ^USINT;
		m_txBufUsed 	: UDINT;
		m_pTxBufUsed 	: ^USINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL CyWork;
	
	FUNCTION GLOBAL DebugIp
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL DebugIp2
		VAR_INPUT
			useOsResources 	: BOOL;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL InitCode
		VAR_INPUT
			useOsResources 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL BefIpr
		VAR_INPUT
			bSetNext 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			state 	: iprStates;
		END_VAR;
	
	FUNCTION GetClassName
		VAR_INPUT
			pObj 	: ^VirtualBase;
			pResData 	: ^void;
		END_VAR
		VAR_OUTPUT
			uiLen 	: UINT;
		END_VAR;
	
	FUNCTION RegisterCommPort
		VAR_INPUT
			udID 	: HDINT;
		END_VAR
		VAR_OUTPUT
			pIp 	: ^DebugIp;
		END_VAR;
	
	FUNCTION LockCommPort
		VAR_INPUT
			udID 	: HDINT;
		END_VAR
		VAR_OUTPUT
			udLocked 	: HDINT;
		END_VAR;
	
	FUNCTION UnLockCommPort
		VAR_INPUT
			udID 	: HDINT;
		END_VAR
		VAR_OUTPUT
			udLocked 	: HDINT;
		END_VAR;
	
	FUNCTION GLOBAL ReleaseCommPort
		VAR_INPUT
			udID 	: HDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetToolID
		VAR_OUTPUT
			udID 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetToolID
		VAR_INPUT
			udID 	: UDINT;
		END_VAR;
	
	FUNCTION AWL GetAddCRC
		VAR_INPUT
			src 	: ^void;
			count 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
	
	FUNCTION GetCltPara
		VAR_INPUT
			pRead 	: ^void;
		END_VAR
		VAR_OUTPUT
			dPara 	: DINT;
		END_VAR;
	
	FUNCTION GetPara
		VAR_INPUT
			pRead 	: ^void;
		END_VAR
		VAR_OUTPUT
			dPara 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL dtor;
	
	FUNCTION ProcessLslCmd
		VAR_OUTPUT
			state 	: iprStates;
		END_VAR;
	
	FUNCTION CheckNextSegNbr
		VAR_INPUT
			pSI 	: ^SEG_INFO;
		END_VAR
		VAR_OUTPUT
			retCode 	: DINT;
		END_VAR;
	
	FUNCTION LslCmdOpen
		VAR_OUTPUT
			pCmdIf 	: pVoid;
		END_VAR;
	
	FUNCTION LslCmdClose;
	
	FUNCTION GLOBAL LslCmdSend
		VAR_INPUT
			txBuffer 	: ^USINT;
			sendLen 	: UDINT;
			status 	: USINT;
			cpuStatus 	: USINT;
			awlBpStatus 	: USINT;
		END_VAR
		VAR_OUTPUT
			retCode 	: DINT;
		END_VAR;
	
	FUNCTION LslCmdError;
	
	FUNCTION GLOBAL ReleaseAllCommPorts;
	
	FUNCTION GetMerkerExStruct
		VAR_INPUT
			pRead 	: ^void;
			pResData 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			bOk 	: BOOL;
		END_VAR;
	
	FUNCTION OnEndMerkerExCmd
		VAR_INPUT
			pMerkerExStruct 	: ^sMerkerExCmd;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION OnMerkerExCmd
		VAR_INPUT
			pRead 	: ^void;
			pResData 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			udLen 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL pCmd::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DebugIp::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_DEBUGIP
0$UINT, 1$UINT, (SIZEOF(::DebugIp))$UINT, 
0$UINT, 1$UINT, 0$UINT, 
TO_UDINT(2472075151), "DebugIp", //Class
TO_UDINT(1945645538), "BaseIp", 0$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
(::DebugIp.objBaseIp.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2933630878), "objBaseIp", TO_UDINT(1945645538), "BaseIp", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_DebugIp 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DebugIp] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DebugIp::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= BaseIp::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= BaseIp::pCmd.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, BaseIp::pCmd.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_DebugIp;
	vmt.CmdTable.NewInstr		:= #pCmd::NewInst();
	vmt.CmdTable.CyWork		:= #CyWork();
	BaseIp::pCmd.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF BaseIp::pCmd.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= DebugIp();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include ".\RTOS_PrivHeader.h"
#include ".\RTOS_Private.h"
#include ".\include\L2_Ipr.h"
#include <LSL_ST_IFLINKER.H>

#pragma using ProgIp
#pragma using ProgMgr
#pragma using IprMgr

#pragma using ObjectReader

#define arraysize(p)                (sizeof(p)/sizeof(p[0]))

VAR_EXTERNAL
#ifndef DUMMY_LOADER
  mt_api          : ^LSL_MT_TYPE; // multitask interface (needed for semaphores)
#endif  
END_VAR

FUNCTION GLOBAL StoreCmdEx
VAR_INPUT
	pCmd            : ^CMDMETH;
	mode            : CMDMETHMODE;
	useOsResources	: BOOL;
  allocPermanent : BOOL; // TRUE=Speicher kann in einen Bereich gelegt werden, der nicht freigegeben werden muss
END_VAR
VAR_OUTPUT
	pMeth           : ^CMDMETH;
END_VAR;
FUNCTION GLOBAL __CDECL GetDataBufferFlag
VAR_INPUT
	pObj		: ^VirtualBase;
END_VAR
VAR_OUTPUT
	bSet		: BOOL;
END_VAR;
FUNCTION GLOBAL ConnectChs
VAR_INPUT
	pChNames		: ^char;
END_VAR
VAR_OUTPUT
	ret_code		: ConfStates;
END_VAR;
FUNCTION GLOBAL _GetChConnection
VAR_INPUT
	pObjDsc			: ^ObjDsc;
	pChDsc			: ^ChDscEntry;
	pName			: pChar;
#ifdef _LSL_TARGETARCH_ARM
END_VAR
VAR_OUTPUT
  retcode : UDINT;
#endif
END_VAR;
FUNCTION GLOBAL _GetObjNameFromAddr
VAR_INPUT
	pObj		: ^VirtualBase;
	pObjName	: pChar;
END_VAR
VAR_OUTPUT
	AX			: UINT;
END_VAR;
FUNCTION GLOBAL InstallTask
VAR_INPUT
	pThis		: ^VirtualBase;
	udRate		: UDINT;
	bMode		: UDINT;
  dPrio	: DINT := -1;
  bDelayed : BOOL := FALSE;
  core : DINT := 0;
END_VAR
VAR_OUTPUT
	ret_code		: ConfStates;
END_VAR;
FUNCTION GLOBAL LOADER_FreeCmd
VAR_INPUT
	pCmd            : ^CMDMETH;
	useOsResources	: BOOL;
END_VAR;
FUNCTION GLOBAL __CDECL LDR_SetWait4Visu  //ZP000
VAR_INPUT
  bWait : BOOL;
  timeout_ms : BOOL;
END_VAR;

#define CS_RUN_RAM              0
#define CS_RUN_ROM              1
#define CS_STOP_BRKPT           15
#define CS_SINGLESTEP           18
#define CS_LOADER_INIT          100
#define CS_LOADER_OK            105

#pragma pack( push, 1 )
TYPE

	  sMerkerExCmd : STRUCT  
	    tTimeout : UDINT;
	    udHandle : UDINT;
	    udLasalId : UDINT;
	    udLen : UDINT;
	    udBufferLen : UDINT;
	    pBuffer : ^void;
	    bValid : BOOL;
      bRead : BOOL;
      (* 8d-2885
        ofs wird beim Empfang von I_INIT_MERKEREX in GetMerkerExStruct mit -1 initialisiert.
        Wenn dann das erste Paket mit I_MERKEREX eintrifft, wird ofs auf den im Paket enthaltenen 
        Offset gesetzt. Damit ist der Offset Wert bekannt, mit dem die SetDataAt Methode 
        am Ende in der Funktion OnEndMerkerExCmd aufgerufen werden muss.
      *)
      ofs : DINT; 
	  END_STRUCT;
  
END_TYPE
#pragma pack(pop)

VAR_GLOBAL
  
  m_pMerkerExStruct 	      : ^sMerkerExCmd;
  m_udMerkerExStructCnt 	  : UDINT;
	
END_VAR


FUNCTION IsApplRunning
VAR_OUTPUT
  isRunning : BOOL;
END_VAR

  IF _runstatus = CS_RUN_RAM |
     _runstatus = CS_RUN_ROM |
     _runstatus = CS_STOP_BRKPT |
     _runstatus = CS_SINGLESTEP |
     (_runstatus >= CS_LOADER_INIT & _runstatus <= CS_LOADER_OK) THEN
    isRunning := TRUE;
  ELSE
    isRunning := FALSE;
  END_IF;

END_FUNCTION

FUNCTION DebugIp::DebugIp
VAR_OUTPUT
  ret_code : ConfStates;
END_VAR
  // Das ist nur ein Dummy Konstruktor der nie aufgerufen wird, da Objekte 
  // von dieser Klasse händisch angelegt werden (d.h. alloc + Aufruf des Konstruktors) 
  // und als Konstrukor der DebugIp2 (mit einem Übergabeparameter) verwendet wird.
  (0$^UDINT)^ := 0; // Exception provozieren
  ret_code := C_OUTOF_NEAR;
END_FUNCTION

FUNCTION GLOBAL DebugIp::DebugIp2
	VAR_INPUT
		useOsResources 	: BOOL;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
VAR
	vmt	: _LSL_STD_VMETH;
	nCmdSize	: UINT;
END_VAR
   
    _memset(this$^void, 0, sizeof(DebugIp));

	BaseIp2(useOsResources);

	nCmdSize		:= BaseIP::pCmd.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;
	_memcpy((#vmt.CmdTable)$^USINT, BaseIP::pCmd.pMeth, nCmdSize);

	// Anzahl der virtuellen Methoden erhöht sich in DebugIP nicht
	// overwrite default methods here
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.NewInstr 	:= #pCmd::NewInst();

	// pr, 30.6.05, 02.01.013
	// Free BaseIp's command table before re-allocating
	// Note: it is allowed to free this table because it was allocated EXCLUSIVE and not SHARED !
	LOADER_FreeCmd(pCmd.pMeth, m_bOsResourcesUsed);

	// store new command table
	pCmd.pMeth		:= StoreCmdEx(pCmd:=#vmt.CmdTable, EXCLUSIVE, m_bOsResourcesUsed, allocPermanent:=FALSE);

	m_udIdTool		:= 0;
	m_udLastCall	:= ops.tAbsolute;
	m_bMarkedForDeletion := FALSE;	//++bugfix040628
  
  IF pCmd.pMeth = NIL THEN
    ret_code  := C_OUTOF_NEAR;
  ELSE
    ret_code  := C_OK;
  END_IF;

END_FUNCTION

// destructor
FUNCTION GLOBAL DebugIp::dtor

  IF pCmd.pMeth <> NIL THEN
	  LOADER_FreeCmd(pCmd.pMeth, m_bOsResourcesUsed);
    pCmd.pMeth := NIL;
  END_IF;
	LslCmdClose();
  IF _m.head.pcode <> NIL THEN
	  IF m_bOsResourcesUsed THEN
	    OS_SysFree(_m.head.pcode);
		ELSE
      _free(_m.head.pcode);
		END_IF;
    _m.head.pcode := NIL;
  END_IF;

END_FUNCTION

FUNCTION GLOBAL DebugIp::InitCode
	VAR_INPUT
		useOsResources 	: BOOL;
	END_VAR

	DebugIp2(useOsResources);
  IF m_bOsResourcesUsed THEN
    SetCodePointer(OS_SysMalloc(sizeof(Instruct))$UDINT);
  ELSE
    SetCodePointer(_alloc_align(sizeof(Instruct))$UDINT);
  END_IF;

END_FUNCTION
VAR_PRIVATE
	udLockID		: HDINT;		// comm buffer locked for this tool
	udLockTime		: HDINT;		// comm buffer locked since..
END_VAR

//[#ENGLISH]
// Try to lock the 1st communication channel for a debugging tool with
// the given ID. The tool has to verify the returned ID.
FUNCTION	DebugIp::LockCommPort
VAR_INPUT
	udID		: HDINT;
END_VAR
VAR_OUTPUT
	udLocked	: HDINT;
END_VAR

	IF udLockID = 0 | ops.tAbsolute-udLockTime > 500 THEN
		udLockID	:= udID;
		udLockTime	:= ops.tAbsolute;
	END_IF;

	udLocked	:= udLockID;

END_FUNCTION
//[#ENGLISH]
// Unlocks the common communication buffer
FUNCTION	DebugIp::UnLockCommPort
VAR_INPUT
	udID		: HDINT;
END_VAR
VAR_OUTPUT
	udLocked	: HDINT;
END_VAR

	udLocked	:= udLockID;

	IF udID = udLockID THEN
		udLockId	:= 0;
	END_IF;

END_FUNCTION

//[#ENGLISH]
// A debugging tool can get its own communication channel. The tool has
// to send a unique identification number (i.e. the start-up time). It can
// later on use this function to check if the channel is still reserved
// for sole use of this tool.
//[>udID]	identification number of the debugging tool
//[<pIp]	pointer to the assigned interpreter object
FUNCTION DebugIp::RegisterCommPort
VAR_INPUT
	udID			: HDINT;
END_VAR
VAR_OUTPUT
	pIp				: ^DebugIp;
END_VAR
VAR
	pLast			: ^DebugIp;
END_VAR

	IF udID = 0 THEN			// 0 is a reserved number
		pIp	:= NIL;
		RETURN;
	END_IF;

	pIp		:= ops.ptPgBuff;
	pLast	:= NIL;
	
	WHILE pIp DO
		IF pIp^.GetToolID() = udID THEN
      // Zeitpunkt des letzten Zugriffs aktualisieren, damit der hier zurückgegebene 
      // Kommunikationskanal auf jeden Fall noch eine Zeit lang gültig ist. 
      // Wenn man das nicht macht, dann kann der Kommunikationskanal ungültig 
      // werden, und die Zugriffe funktionieren dann nicht mehr.
      pIp^.m_udLastCall := ops.tAbsolute;
			RETURN;				// the tool can still use the old port
		END_IF;
		pLast	:= pIp;
		pIp		:= (pIp^.GetNextIp()) $ ^DebugIp;
	END_WHILE;

	pIp		:= IprMgr::GetIpObj(m_bOsResourcesUsed);		// create a new port object
	IF pIp = NIL THEN
		RETURN;
	END_IF;

	pLast^.SetNextIp( pIp );
	pIp^.SetToolID( udID );		// register the tool's id

END_FUNCTION
//[#ENGLISH]
// A debug tool should release its communication channel at the end
// of the debug session. The application itself will release the channel
// if it was not used during the last 30 seconds. After this period it 
// waits another 30 seconds, till the channel is finally released.
//[>udId]	identification number of the debug tool
FUNCTION DebugIp::ReleaseCommPort
VAR_INPUT
	udId		: HDINT;
END_VAR
VAR
	pLast,
	pIp			: ^DebugIp;
END_VAR

	pIp		:= ops.ptPgBuff;
	pLast	:= NIL;
	
	WHILE pIp DO
		IF pIp^.GetToolID() = udID THEN
			IF pLast THEN		// don't release the 1st object
				pLast^.SetNextIp( pIp^.GetNextIp() );	// unchain Ip
        pIp^.dtor();
				IF m_bOsResourcesUsed THEN
					OS_SysFree(pIp);
				ELSE
					_free(pIp);
				END_IF;
			END_IF;
			RETURN;
		END_IF;
		pLast	:= pIp;
		pIp		:= (pIp^.GetNextIp()) $ ^DebugIp;
	END_WHILE;

END_FUNCTION
//------------------------------------------------------------------------------
// DebugIp::ReleaseAllCommPorts
//------------------------------------------------------------------------------
FUNCTION GLOBAL DebugIp::ReleaseAllCommPorts
VAR
	pLast,
	pIp			: ^DebugIp;
END_VAR

	pIp	:= OPS.ptPgBuff;
	OPS.ptPgBuff := NIL;
	WHILE pIp DO
		pLast	:= pIp;
		pIp		:= (pIp^.GetNextIp()) $ ^DebugIp;
		pLast^.dtor();
		IF m_bOsResourcesUsed THEN
			OS_SysFree(pLast);
		ELSE
			_free(pLast);
		END_IF;
	END_WHILE;

END_FUNCTION

FUNCTION MemBarrier
  IF MT_API & MT_API^.version >= 0x00010005 THEN
    OS_MT_MemBarrier();
  END_IF;
END_FUNCTION

#ifdef COMLINK_TCP_SERVER
FUNCTION GLOBAL SyncRefListsTcpAll VAR_INPUT lasalid : udint; END_VAR;
#endif
FUNCTION DebugIp::CyWork
VAR
	bSetNext		: UDINT;		// not used
  ws : iprStates;
end_var

	IF _m.head.workState = BUSY THEN

    if( _m.head.workStateIntern = READY )then
      _m.head.funkSt := READY;
    end_if;
    ws	:= BEFIPR(#bSetNext);
    m_udLastCall := ops.tAbsolute;
    
   #ifdef COMLINK_TCP_SERVER
    if(_m.head.pCode^.opCode = I_WRITE) then
      SyncRefListsTcpAll(_m.head.pCode^.aPara[0]$udint);
    end_if;
   #endif
	
    // Dieser Code mit workStateIntern und funkSt ist mit 02.02.067, 15.10.2007 
    // dazugekommen (BS 430, Stefanon). Damit sollte GetState und Kill für den 
    // Debuginterpreter verfügbar sein.
    if( ws <> READY )then
      if( ( ws = ERROR ) | ( ws = ERROR_BUSY ) )then
        _m.head.workStateIntern := READY;
      else
        _m.head.workStateIntern := ws;
      end_if;
    else 
      if( _m.head.funkSt = BUSY )then
        if( _m.head.workStateIntern <> BUSY )then
          _m.head.funkSt := READY;          
        end_if;
      end_if;    
      _m.head.workStateIntern := READY;
    end_if;

    // _m.head.workState darf erst gesetzt werden, wenn die Verarbeitung fertig ist, 
    // weil _m.head.workState dem OS signalisiert, dass der Request abgeschlossen ist.
    // Weiters wird hier eine Memory-Barriere gesetzt, damit auf Multicoresystemen 
    // die Änderungen sichtbar sind, wenn _m.head.workState gesetzt wird.
    MemBarrier();
    _m.head.workState	:= ws;
    
	ELSIF m_udIdTool & ops.tAbsolute-m_udLastCall	> 60000 THEN
		// Ip not used any longer
		m_bMarkedForDeletion := TRUE; //++bugfix040628
	END_IF;

END_FUNCTION
// static function, gets the class name for an object pointer
//[>pObj]		this-pointer of the object
//[<pResData]	the class-name of the object is copied there
//[<uiLen]		string length of the class name + 1
FUNCTION DebugIp::GetClassName
VAR_INPUT
	pObj			: ^VirtualBase;
	pResData		: ^void;
END_VAR
VAR_OUTPUT
	uiLen			: UINT;
END_VAR
VAR
	pObjHdr			: ^Obj;
	pClsName		: ^char;
END_VAR

	IF pObj THEN
		pObjHdr			:= LSL_GetHdr(pObj)$^Obj;
		pClsName		:= _GetClsName(pObjHdr^.pClsHdr);
		uiLen			:= _strlen(pClsName)$UINT+1;
		_memcpy(pResData, pClsName, uiLen);
	ELSE
		uiLen			:= 0;	// no valid object address given
	END_IF;

END_FUNCTION
FUNCTION GLOBAL VIRTUAL DebugIp::pCmd::NewInst
VAR_INPUT
	pPara		: ^CmdStruct;
	pResult		: ^results;
END_VAR
VAR_OUTPUT
	ret_code	: iprStates;
END_VAR
VAR
	pSubProg		: ^SubPrgHead;
	pPrgIp			: ^ProgIp;
	i				: UINT;
//	pString			: ^CHAR;
END_VAR

	ret_code := READY;

	CASE pPara^.uiCmd$CmdIpr OF 
	//liefert die Anzashl der vorhandenen Interpreterprogramme
	GET_NBR_OF_IP_PROGS:
		pResult^.uiLng := sizeof(UINT) + 2;
    IF Ops.pSequDir <> NIL THEN
      pResult^.aData[0]$UINT := Ops.pSequDir^.uiIprCnt;
    ELSE
      pResult^.aData[0]$UINT := 0;
    END_IF;
	//liefert die Adresse eines Interpreterkopfes 
	//aPara[0] : Programmnummer 
	GET_IP_HEAD_ADDRESS:
		pSubProg 	:= ProgMgr::GetProgram(TO_UINT(pPara^.aPara[0]$BYTE));
		pResult^.uiLng := sizeof(UDINT) + 2;
		pResult^.aData[0]$pSubPrgHead := pSubProg;
	//liefert die Adresse eines Interpreters
	//aPara[0] : Programmnummer 
	GET_IP_ADDRESS:
		pPrgIp		:= IprMgr::GetInterpreter(pPara^.aPara[0]$BYTE);
		pResult^.uiLng := sizeof(UDINT) + 2;
		pResult^.aData[0]$^ProgIp := pPrgIp;
	//Liefert die Checksumme eines Interpreters
	//aPara[0] : Programmnummer 
	GET_CHKSUM:
		pSubProg 	:= ProgMgr::GetProgram(TO_UINT(pPara^.aPara[0]$BYTE));
		pResult^.uiLng := sizeof(UDINT) + 2;
		pResult^.aData[0]$UDINT := pSubProg^.udCRCorig;
	//Entfernt alle Interpreterbreakpoints
	CMD_REMOVE_ALL_BP:
		//pString := OS_SSR_Malloc(255);
		//_itoa(ops.tAbsolute, pString);
		//TRACE(pString);
    IF OPS.pProg THEN
      i	:= OPS.pProg^.uiProgs;
      WHILE i DO
        i	-= 1;
        pPrgIp := IprMgr::GetInterpreter(i);
        pPrgIp^.RemoveAllBreakpoints();	
      END_WHILE;
      g_LoadTimeout += 200;
    END_IF;        

	// delegate commands to specific interpreter-object
	SET_TRIGGER,
	GET_LOAD_STATE,
	SET_BREAKPOINT,
	CMD_SINGLESTEP,
	CMD_RUN_IPR,
	SET_CODE_POINTER,
	GET_FUNK_STATE,
	CMD_STEPOVER,
	CMD_STEPOUT,
	CMD_HOLD:
		pPrgIp := IprMgr::GetInterpreter(pPara^.aPara[0]$BYTE);
		ret_code := pPrgIp^.NewInst(pPara, pResult);

	END_CASE;
	
END_FUNCTION

// Calculates a simple CRC for a block of bytes, by adding the
// bytes of this block.


FUNCTION AWL DebugIp::GetAddCRC
	VAR_INPUT
		src 	: ^void;
		count 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: USINT;
	END_VAR

 #ifdef _LSL_TARGETARCH_ARM
    STMDB     sp!, {r6} 
 
    MOV       retcode , #0
    CMP       count, #0
    BEQ       GetAddCrc_End
GetAddCrc_Loop    
    LDRB      r6, [src], #1
    ADD       retcode, retcode, r6
    SUBS      count, count, #1
    BNE       GetAddCrc_Loop
    AND       retcode, retcode, #255
GetAddCrc_End 
 
    LDMIA     sp!, {r6}
 #else
    CLR       EAX			// initialize retcode
    L.ECX     count
    JECXZ     GetAddCrc_End // check for valid length
    L.EDI     src
GetAddCrc_Loop
    ADD       (EDI)		// add next byte to CRC
    INC       EDI			// point to next byte
    DEC       ECX			// decrement remaining length
    JNZ       GetAddCrc_Loop	// still bytes to add ??

GetAddCrc_End
    S.AL      retcode
 #endif
 
END_FUNCTION

(*
// -> EDI		: pointer to the memory block
// -> ECX		: length of the block
// <- AL		: simple check sum
//
FUNCTION AWL DebugIp::GetAddCRC
	VAR_INPUT
		EDI 	: ^void;
		ECX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		AL 	: USINT;
	END_VAR


		CLR			AL			// initialize the CRC
		JECXZ		ENDE		// check for valid length

NEXT
		ADD			(EDI)		// add next byte to CRC
		INC			EDI			// point to next byte
		DEC			ECX			// decrement remaining length
		JNZ			NEXT		// still bytes to add ??

ENDE							// AL contains the CRC

END_FUNCTION
*)

//    
//    This is the Interpreter
//    ----------------------------------------------------------
//		-> pointer to active interpreter
//		<- bSetNext	: usually TRUE, after GOTO or CALL FALSE
//		<- state	: ready, busy, error, error_busy

FUNCTION GLOBAL DebugIp::BefIpr
VAR_INPUT
	bSetNext		: ^UDINT;
END_VAR
VAR_OUTPUT
	state			: IPRSTATES;
END_VAR
VAR
	pResData		: ^UDINT;
	dPara			: DINT;
	pObj			: ^OBJ;
	uiPrgNo			: UINT;
	pPrgIp			: ^ProgIp;
	pRead			: ^VOID;
	j				: UINT;
	progAddr		: ^VOID;
	chMode			: CHMODE;
	pSubProg		: ^SubPrgHead;
	udCheck			: UDINT;
	fCmdProcessed   : BOOL;
  pNext     : ^CHAR;
  pHelp     : ^CHAR;
  usLen     : USINT;
  szName    : ARRAY[0..254] of CHAR;
  udNo      : UDINT;    //JOE 25-02-2011
  udNoResult: UDINT;    //JOE 25-02-2011
  pMeth     : ^void;    //JOE 25-02-2011
END_VAR

	pRead 		:= #_m.head.pCode^.aPara[0];
	pResData 	:= #_m.resu.aData[0]$UDINT;
	bSetNext^	:= TRUE;
	state		:= READY;

	// Hier sind die Befehle enthalten, die auch bei einer ungültigen RTDB 
	// funktionieren müßen.
	fCmdProcessed := TRUE;
	CASE _m.head.pCode^.opCode OF
	//--------------------------------------------------------------------
	// Returns the version number of the loader firmware.
	// Byte: Len: Mnemo:
	// 0     0    <none>     no parameters
	// -----------------
	// 0	 1	  <LoRev>	lower revision
	// 1	 1	  <HiRev>	higher revision
	//--------------------------------------------------------------------
	I_GET_VERSION:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;
			_m.resu.uiLng	:= sizeof(Ops.uiLoaderVersion)+2;
			_m.resu.aData[0]$UINT := Ops.uiLoaderVersion$UINT;
		END_IF;
    
	//--------------------------------------------------------------------
	// I_LSLCMD contains the lasal online protocol
	//--------------------------------------------------------------------
	I_LSLCMD:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;
			state := ProcessLslCmd();
		END_IF;
    
	I_LOCK:
		IF _m.head.funkst = READY THEN
			pResData^$HDINT	:= LockCommPort(pRead^$HDINT);
			_m.resu.uiLng		:= sizeof(UINT)+sizeof(HDINT);
		END_IF;

	I_UNLOCK:
		IF _m.head.funkst = READY THEN
			pResData^$HDINT	:= UnLockCommPort(pRead^$HDINT);
			_m.resu.uiLng		:= sizeof(UINT);
		END_IF;

		
	// A debugging tool needs a communication channel to the LASAL application.
	// To log in it sends a 'unique' number of 4 bytes length. Later on it has 
	// to use the channel at least every 30s. Otherwise the application will
	// release the communication channel automatically.
	I_REGISTER:
		IF _m.head.funkst = READY THEN
			pResData^$^DebugIp	:= RegisterCommPort(pRead^$HDINT);
			_m.resu.uiLng		:= sizeof(UINT)+sizeof(HDINT);
		END_IF;

	// A debugging tool should release the communication channel at the end
	// of the session.
	I_RELEASE:
		IF _m.head.funkst = READY THEN
			IF pRead^$HDINT = m_udIdTool THEN
				// no suicide here !
				m_bMarkedForDeletion := TRUE;	//++bugfix040628
			ELSE
				ReleaseCommPort(pRead^$HDINT);
			END_IF;
		END_IF;

	ELSE
		fCmdProcessed := FALSE;
    
  END_CASE;
  
	IF fCmdProcessed THEN
		GOTO Ende;
	END_IF;

	IF (_RtOSversion >= 16#1000) & !!(OPS.loaderFlags AND LOADER_ISAPPLVALID) THEN
		// In der obigen CASE Anweisung für Befehle ohne RTDB war der Befehl 
		// nicht zu finden -> Fehler zurückliefern
		state  := ERROR;
		_m.resu.uiLng := SEND_STATE_ONLY;
	ELSE
		// Hier sind die Befehle enthalten, die nur bei einer gültigen RTDB funktionieren
	CASE _m.head.pCode^.opCode OF
	I_GET_CALLED_IPR,		
	I_GET_CALLED_FROM,
	I_END_SOFTLOAD_IPR,
	I_TRY_SOFTLOAD_IPR,
	I_STOP_IPR_CHECK_FOR_LOAD,
	//I_START_IPR,
	I_GET_TRIGGER_COUNT,
	I_GET_ACT_OFFSET,
  I_GET_STACKINFO,
	I_GETPROGSTATE:
		IF _m.head.funkst = READY THEN
			_m.head.funkst	:= BUSY;
			uiPrgNo	:= pRead^$CHAR;
			IF uiPrgNo >= OPS.pProg^.uiProgs THEN
				GOTO SET_ERROR;
			END_IF;
			pPrgIp := IprMgr::GetInterpreter(uiPrgNo);
			pPrgIp^.DebugInst(_m.head.pCode, #_m.resu);
		END_IF;

	I_GETPROGSTATE_ALL:
		IF _m.head.funkst = READY THEN
			_m.head.funkst	:= BUSY;
			uiPrgNo	:= 0;
      _m.resu.uiLng				:= 2;		// len(2)
      pResData^$UINT := OPS.pProg^.uiProgs;
      pResData += 2;
      _m.resu.uiLng	+= 2;
			WHILE uiPrgNo < OPS.pProg^.uiProgs DO
        IF pResData > ((#_m.resu.aData[arraysize(results.adata)-1])-4)$^UDINT THEN
          GOTO SET_ERROR;
        END_IF;
        pPrgIp := IprMgr::GetInterpreter(uiPrgNo);
        (pResData+0)^$IprStates	:= pPrgIp^._m.head.FunkSt;
        (pResData+2)^$UINT		:= pPrgIp^.uiActLine;
        pResData += 4;
        _m.resu.uiLng				+= 4;		// state(2)+line(2)
        uiPrgNo += 1;
			END_WHILE;
		END_IF;

	//--------------------------------------------------------------------
	// Liefert die Zykluszeit des CheckForLoads das am längsten braucht
	//--------------------------------------------------------------------
	I_GET_CFL_CYCLE:
		IF _m.head.funkst = READY THEN
			_m.head.funkst	:= BUSY;
			
			j := OPS.pProg^.uiProgs;
			udCheck := 0;

			// are there any interpreters running?
			WHILE j DO
				j	-= 1;
				pPrgIp := IprMgr::GetInterpreter(j);
				
				dPara$UDINT	:= pPrgIp^.GetCFLCycle();
				IF dPara$UDINT > udCheck THEN
					udCheck := dPara$UDINT;
				END_IF;
			END_WHILE;

			pResData^ := udCheck;
			_m.resu.uiLng	:= 6; 
		END_IF;

	//--------------------------------------------------------------------
	// Calls the read method of a server and returns the value
	// Byte: Len: Mnemo:
	// 0     1    <PreFix>   P_IMMED .. returns the given value, 
	//						 P_VARIA .. calls the server channels read()
	// 1     4    <pSvrCh>   return value or pointer to the server channel
	//--------------------------------------------------------------------
	I_READ:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

			IF (pRead^$Prefix <> P_IMMED) & !!IsValidServer((((pRead+1)$^pVoid)^)$^SvrCh) THEN
				GOTO SET_ERROR;
			END_IF;

      //DB1753: Applikationscode wird nicht aufgerufen, wenn die Applikation nicht läuft
      IF (pRead^$Prefix <> P_IMMED) & !!IsApplRunning() THEN 
				GOTO SET_ERROR;
      END_IF;

			pResData^		:= GetPara(pRead)$UDINT;
			_m.resu.uiLng		:= 2+sizeof(DINT);	// len (2) + data (4 byte)
		END_IF;

	//--------------------------------------------------------------------
	// Calls the read method of the connected server and returns the value
	// Byte: Len: Mnemo:
	// 0     1    <PreFix>   P_IMMED .. returns the given value, 
	//						 P_VARIA .. calls read() of the connected server
	// 1     4    <pSvrCh>   return value or pointer to the server channel
	//--------------------------------------------------------------------
	I_READ_CLT:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

			IF (pRead^$Prefix <> P_IMMED) & !!IsValidClient((((pRead+1)$^pVoid)^)$^CltCh) THEN
				GOTO SET_ERROR;
			END_IF;

      //DB1753: Applikationscode wird nicht aufgerufen, wenn die Applikation nicht läuft
      IF (pRead^$Prefix <> P_IMMED) & !!IsApplRunning() THEN 
				GOTO SET_ERROR;
      END_IF;

			pResData^		:= GetCltPara(pRead)$UDINT;
			_m.resu.uiLng		:= 2+sizeof(DINT);	// len (2) + data (4 byte)
		END_IF;


	//--------------------------------------------------------------------
	//         0123  P,54678
	// <Write> <Dest) <Data>
	//--------------------------------------------------------------------

	I_WRITE:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

			IF !!IsValidServer(((pRead$^pVoid)^)$^SvrCh) THEN
				GOTO SET_ERROR;
			END_IF;

      //DB1753: Applikationscode wird nicht aufgerufen, wenn die Applikation nicht läuft
      IF !!IsApplRunning() THEN 
				GOTO SET_ERROR;
      END_IF;

			progAddr		:= pRead+4;			// evaluate expression
			dPara			:= GetResu((#progAddr)$^void, _m.head.pResu);
			//CLI();		// darf nicht sein weil es writes gibt die länger dauern 
			// 				// und dann in einer single CPU Lösung alles steht !!! #FA 02092003
			pResData^		:= WR(((pRead$^pVoid)^)$pSvrCh, dPara);
			//STI();
			_m.resu.uiLng		:= 2+sizeof(DINT);	// len (2) + data (4 byte)
		END_IF;

	//--------------------------------------------------------------------
	//          0123   4,5    P,7,8,9,10
	// <Write> <Dest> offset <Data>   dest is address of client channel
	//--------------------------------------------------------------------

	I_WRITE_TO_CLNT:
		IF _m.head.funkst = READY THEN
			_m.head.funkst 	:= BUSY;

			IF !!IsValidClient(((pRead$^pVoid)^)$^CltCh) THEN
				GOTO SET_ERROR;
			END_IF;

      //DB1753: Applikationscode wird nicht aufgerufen, wenn die Applikation nicht läuft
      IF !!IsApplRunning() THEN 
				GOTO SET_ERROR;
      END_IF;

			progAddr		:= pRead+6;
			dPara			:= GetResu((#progAddr)$^void, _m.head.pResu);	// evaluate expression
//**			CLI();
			pResData^		:= WR_CHNL(((pRead$^pVoid)^)$^pSvrCh, 
										(pRead+4)^$UINT, dPara);
//**			STI();
			_m.resu.uiLng		:= 2+sizeof(DINT);	// len (2) + data (4 byte)
		END_IF;

	//--------------------------------------------------------------------
	// Calls the init method of a server or an object
	// Byte: Len: Mnemo:
	// 0     4    <pSvrCh>   pointer to the object
	//--------------------------------------------------------------------

	I_INIT:
		IF _m.head.funkst = READY THEN
			_m.head.funkst	:= BUSY;
			pRead^$^VirtualBase^.Init();
		END_IF;

	//--------------------------------------------------------------------
	// Creates a new object with a given name of a given class
	// Byte: Len: Mnemo:
	// 0     n    <ClsName> 0-terminated Class Name, length n
	// n     m    <ObjName> 0-terminated Object Name, length m, can be empty
	//--------------------------------------------------------------------
	I_NEW_OBJ:
		IF _m.head.funkst = READY THEN
			_m.head.funkst	:= BUSY;
			dPara	:= to_dint(_strlen(pRead$^char));
     #ifdef _LSL_USECLISTI
			CLI();
			pResData^$^VirtualBase	:= ObjectReader::NewObj(pRead$^char, (pRead+dPara+1)$^char);
			STI();
     #else
			pResData^$^VirtualBase	:= ObjectReader::NewObj(pRead$^char, (pRead+dPara+1)$^char);
     #endif
			_m.resu.uiLng	:= 2+sizeof(pVoid);	// len (2) + data (4 byte)
		END_IF;

	//--------------------------------------------------------------------
	// Removes an object from the RTDB, disconnects the other objects
	// Byte: Len: Mnemo:
	// 0     m    <ObjName> 0-terminated Object Name, length m, can be empty
	//--------------------------------------------------------------------
	I_DEL_OBJ:
		IF _m.head.funkst = READY THEN
			_m.head.funkst	:= BUSY;
     #ifdef _LSL_USECLISTI
			CLI();
     #endif
			IF DelObj(pRead$^char) THEN
				pResData^$ConfStates	:= C_OK;
			ELSE
				pResData^$ConfStates	:= C_UNKNOWN_OBJECT;
			END_IF;

			_m.resu.uiLng	:= sizeof(UINT)+sizeof(ConfStates);
     #ifdef _LSL_USECLISTI
			STI();
     #endif
		END_IF;

	//--------------------------------------------------------------------
	// Connects a client and a server channel. Both channels must exist
	// Byte: Len: Mnemo:
	// 0     n    <CltName> 0-terminated Client Channel Name, length n
	// n     m    <SvrName> 0-terminated Server Channel Name, length m
	//--------------------------------------------------------------------
	I_CONNECT:
		IF _m.head.funkst = READY THEN
			_m.head.funkst	:= BUSY;
     #ifdef _LSL_USECLISTI
			CLI();
			pResData^$ConfStates := ConnectChs(pRead$^char);
			STI();
     #else
			pResData^$ConfStates := ConnectChs(pRead$^char);
     #endif
			_m.resu.uiLng	:= sizeof(ConfStates)+sizeof(UINT);
		END_IF;

	//--------------------------------------------------------------------
	// Tells the OS to call a cyclic function for a given object.
	// Byte: Len: Mnemo:
	// 0     4    <pObj>    pointer to the object
	// 4     4    <time>    period duration
	// 8     2    <mode>    Bg/Cy/Rt-function will be called
	//--------------------------------------------------------------------
	I_SET_CYCLE:
		IF _m.head.funkst = READY THEN
			_m.head.funkst	:= BUSY;
     #ifdef _LSL_USECLISTI
			CLI();
     #endif 
			pResData^$ConfStates := 
        InstallTask( pRead^$^VirtualBase,							// pObj
              (pRead+sizeof(pVoid))^$udint,				// time
              (pRead+sizeof(pVoid)+sizeof(udint))^$uint);	// mode
     #ifdef _LSL_USECLISTI
			STI();
     #endif 
			_m.resu.uiLng	:= sizeof(ConfStates)+sizeof(UINT);
		END_IF;

	//--------------------------------------------------------------------
	// < I_CMD ><pSvrCh_cmd><NewInst-cmd><Expr><P_COMMA><Expr>...P_EOL
	//--------------------------------------------------------------------
	// The CMD-number is 2 bytes long.
	// If a CMD receives parameters in the CmdStruct (multiple DINT values),
	// then these values have to be separated by a P_COMMA and terminated with
	// a P_EOL.
	// The given length is not checked, only the EOL terminates parameter evaluation.
	I_CMD_DEBUGIP,
	I_CMD:
    IF _m.head.pCode^.opCode = I_CMD_DEBUGIP THEN
      pRead^$^DebugIp := this;
    END_IF;
		state	 := CallUserClassMethod();
		IF state = READY & 
			_m.head.workstate = SINGLESTEP THEN
			state := SINGLESTEP;
			_m.head.workstate := READY;
		END_IF;

	//--------------------------------------------------------------------
	// create a new IP-program
	//    1By   Flags
	//            76543210
	//            !    !!!
	//            !    !! \_ 0 = MerkerEx, 1 = vorbereitet für Ramex, dzt. nicht implementiert !!!
	//            !    ! \__ 0 = dynamisch erweiterbar, 
	//            !    !     1 = fix allokiert, Größe und Speicherort kann sich nicht mehr ändern
	//             \____\___ 0 = reserviert
	//    4By   PreAllocSize
	//            Wenn <> 0, dann wird der Speicher mit dieser Größe vorallokiert
	//            
	//  Return:
	//    1By   ProgNbr
	//            16#ff = Fehler
	//--------------------------------------------------------------------
  (*** ++pr:test ***
	I_CREATE_PROG:
		IF _m.head.funkst = READY THEN
			_m.head.funkst		:= BUSY;
			pResData$^USINT^ := ProgMgr::CreateIprProg(pRead$^USINT^, (pRead+1)$^UDINT^)$USINT;
			_m.resu.uiLng := SIZEOF(USINT)+SIZEOF(results.uiLng);
		END_IF;
   *** ++pr:test ***)
    
	//--------------------------------------------------------------------
	// test if there is something to load into the programs
	//--------------------------------------------------------------------
	// should be put into the automatic cycle

	I_CHECK_FOR_LOAD:
		_m.head.funkst		:= BUSY;
		CheckForLoad();
		_m.resu.uiLng	:= SEND_STATE_ONLY;

	// an external station is going to transmit an IP-program
	I_START_LOAD_PR:
		IF _m.head.funkst = READY THEN
			_m.head.funkst		:= BUSY;

			OPS.udProgLength :=  pRead^   $UDINT;
			OPS.uiProgNoLoad := (pRead+4)^$UINT;

			// check if length is within range 
			IF OPS.pProg <> NIL &
        OPS.udProgLength <> 0 &
				OPS.udProgLength < 16#FFFF &
				OPS.uiProgNoLoad < OPS.pProg^.uiProgs THEN

				// set system ready to receive an IPR-program
				OPS.udProgSize   := 0;
				j				 := MAX_IP_PROGS + OPS.uiProgNoLoad;

				IF ProgMgr::AllocProg(OPS.udProgLength + (NewSubPrgHead.subProgHead)$UDINT, j) = FALSE THEN
					GOTO DONT_LOAD_PROG;
				END_IF;

				OPS.pDestProg 	 := ProgMgr::GetProgram(j);

				// bit will be set when the program is completly 
				// transmitted into temporary memory
				ClearLoadBit(Ops.uiProgNoLoad);
		  ELSE
			DONT_LOAD_PROG:
				// prevent system from receiving a IPR-program
				OPS.udProgSize	:= 16#FFFFFFFF;
				GOTO SET_ERROR;
			END_IF;

			_m.resu.uiLng	:= SEND_STATE_ONLY;
		END_IF;

	//--------------------------------------------------------------------
	//  load program word <offset> <program......>
	//  para[0]		<offset>		4 byte
	//  para[4]		<chksum>		1 byte
	//  para[5]		<code>			x byte
	//--------------------------------------------------------------------
	I_LOAD_PROG:
	I_LOAD_PROG2:
		IF _m.head.funkst = READY THEN
			_m.head.funkst		:= BUSY;

			IF (OPS.udProgSize = pRead^$UDINT) & (OPS.udProgLength <> 0) THEN

				// get the recently received number of bytes
				j	:= _m.head.pCode^.uiLng-(sizeof(UDINT)+1);
        IF _m.head.pCode^.opCode = I_LOAD_PROG2 THEN
          // I_LOAD_PROG ist fehlerhaft: es werden 3 Bytes zuviel 
          // für die Checksummenberechnung verwendet, da uiLng das 
          // Längenfeld selbst und das Kommandobyte beinhaltet.
          // Weil es aber für diesen Fehler im Lasal bereits einen 
          // Workaraound gibt, kann man das nicht einfach richtigstellen. 
          // Es gibt stattdessen einen neuen Befehl I_LOAD_PROG2 der 
          // diesen Fehler nicht hat.
          j -= 3;
        END_IF;

				IF (pRead+4)^$USINT <> GetAddCRC(pRead+5, j) |  // retry
					OPS.udProgLength < j THEN
					GOTO SET_ERROR;		// block transmission error
				END_IF;

				_MEMCPY(OPS.pDestProg+OPS.udProgSize, pRead+5, j);
							
				OPS.udProgSize		+= j;
				OPS.udProgLength	-= j;
			    					
				// test if it was the end
				IF OPS.udProgLength = 0 THEN

					// now test if this interpreter is running or not
					pPrgIp := IprMgr::GetInterpreter(OPS.uiProgNoLoad);
					//udCheck := pPrgIp^.GetFileCheck();
					IF pPrgIp^.LoadProgFromTemp(Ops.uiProgNoLoad) <> C_OK THEN
						GOTO SET_ERROR;	// i.e. linker error
					END_IF;
					
					pResData^ := pPrgIp^.GetCFLCycle();
				ELSE
					pResData^ := 0;
				END_IF;


			ELSE
				// error: terminal and CPU are asynchron
				GOTO SET_ERROR;
			END_IF;

			_m.resu.uiLng	:= 6; 

		END_IF;


	// -------------------------------------------------------------------
	//   get back the program from the CPU
	// -------------------------------------------------------------------
	//  <programnumberBYTE><Offset in the ProgramUINT>
	//  only copys the part of the program into the resultbuffer
	//  every new time the pointer into the program is new
	//  loaded
	//  para[0]		<#Prog>		1 byte
	//  para[1]		<offs>		4 byte

	I_GETPROG:
		IF _m.head.funkst = READY THEN
			_m.head.funkst		:= BUSY;

			IF (OPS.pProg <> NIL) & (TO_UINT(pRead^$BYTE) < OPS.pProg^.uiProgs) THEN

				pSubProg := ProgMgr::GetProgram(TO_UINT(pRead^$BYTE));

				// check if the offset is bigger than the program size
				IF pSubProg^.udLng > (pRead+1)^$UDINT THEN

					// always copy full length the caller has to take care for end
					_MEMCPY(pResData,
							pSubProg + (pRead+1)^$UDINT,
							SIZEOF(results.aData));

					_m.resu.uiLng	:= SIZEOF(results.aData)+SIZEOF(results.uiLng);
				ELSE
					// error: caller wants to have a too big offset //
					GOTO SET_ERROR;
				END_IF;

			ELSE	      // error terminal wants to get an unknown program
				GOTO SET_ERROR;
			END_IF;

		END_IF;

	//--------------------------------------------------------------------
	//<i_get_Global_Addr> <"varname">
	//--------------------------------------------------------------------

	I_GET_GLOBAL_ADDR:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

      pResData^$UDINT := OS_LNK_GetAddress_Variable(pRead$^char)$UDINT;
			_m.resu.uiLng := 6;			// len(2), 1x Ptr (4)
      
		END_IF;

	//--------------------------------------------------------------------
	//<i_get_Data> <address><len>
	//--------------------------------------------------------------------

	I_GET_DATA:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

      IF (pRead+4)^$USINT <= SIZEOF(results.aData) THEN
        _memcpy(pResData, pRead^$^pVoid, (pRead+4)^$USINT);
        _m.resu.uiLng := 2 + (pRead+4)^$USINT;			// len(2), data
      ELSE
				GOTO SET_ERROR;
      END_IF;
      
		END_IF;

	//--------------------------------------------------------------------
	//<i_set_Data> <address(4B)><len(1B)><data>
	//--------------------------------------------------------------------

	I_SET_DATA:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

     	_memcpy(pRead^$^pVoid, pRead+5, (pRead+4)^$USINT);
			_m.resu.uiLng	:= SEND_STATE_ONLY;
      
		END_IF;

	//--------------------------------------------------------------------
	//<i_getObj_list> <"[byte]objectname[byte]varname[byte]varname[0]">
	//--------------------------------------------------------------------

	I_GET_OBJ_LIST:	//ZP000
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

      usLen := (pRead$^USINT)^;
      pRead += 1;
      _memcpy(#szName[0], pRead, usLen);
      szName[usLen] := 0;
            
      chMode := _LookUpEmbed_C(#szName[0], pResData$^pVoid, NIL);
      
      CASE chMode OF
        
      _CH_OBJ:  //----------------------------------------------------------
        
        (pResData+4)^$CHMODE := chMode;
        _m.resu.uiLng := 8;			// len(2), 1x Ptr (4), Mode (2)
        pNext := pRead + usLen;
        
      ELSE  //--------------------------------------------------------------
        //--- object not found, or no object
        (pResData)^$UDINT := 0;
        (pResData+4)^$CHMODE := _CH_NONE;
        _m.resu.uiLng := 8;			// len(2), 1x Ptr (4), Mode (2)

        //--- say also 0 for the rest of the server
        pNext := pRead + usLen;
        usLen := pNext^$USINT;
        pNext += 1;
        while (usLen > 0) do

          (pResData + (_m.resu.uiLng - 2))^$UDINT := 0;
          (pResData + (_m.resu.uiLng - 2) + 4)^$CHMODE := _CH_NONE;
          _m.resu.uiLng += 6;			// 1x Ptr (4), Mode (2)

          pNext += usLen;
          usLen := pNext^$USINT;
          pNext += 1;
        end_while;
        pNext := NIL;
      END_CASE;
      
      //--- nur wenn mehr als 1 name übergeben wurde
      if (pNext <> NIL) then

        pHelp := #szName[usLen];
        pHelp^$CHAR := '.';
        pHelp += sizeof(CHAR);
        
        usLen := pNext^$USINT;
        pNext += 1;
        
        while (usLen > 0) do

          _memcpy(pHelp, pNext, usLen);
          (pHelp + usLen)^ := 0;          
          
          chMode := _LookUpEmbed_C(#szName[0], (pResData + (_m.resu.uiLng - 2))$^pVoid, NIL);
          
          CASE chMode OF
          _CH_NONE,
          _CH_CLT_CMD,
          _CH_CLT_DATA,
          _CH_CLT_EMB,
          _CH_CLT_OBJ,
          _CH_CMD,
          _CH_SVR,
          _CH_CNST,
          _CH_OBJ:
            (pResData + (_m.resu.uiLng - 2) + 4)^$CHMODE := chMode;
            _m.resu.uiLng += 6;			// 1x Ptr (4), Mode (2)
          ELSE
            //--- variable not found
            (pResData + (_m.resu.uiLng - 2))^$UDINT := 0;
            (pResData + (_m.resu.uiLng - 2) + 4)^$CHMODE := _CH_NONE;
            _m.resu.uiLng += 6;			// 1x Ptr (4), Mode (2)
          END_CASE;

          pNext += usLen;
          usLen := pNext^$USINT;
          pNext += 1;

        end_while;
      end_if;

		END_IF;
    
  //--------------------------------------------------------------------
	//<i_rd_svrlist> <[no 4byte][lid 4byte][lid 4byte][lid 4byte]..>  //JOE 25-02-2011
	//--------------------------------------------------------------------
  I_RD_SVRLIST:
    IF _m.head.funkst = READY THEN
      _m.head.funkst := BUSY;
  
      udNo       := pRead^$UDINT;      //no of lids
      pRead      += sizeof(UDINT);     //move ptr
      udNoResult := 0;                 //initialize
      
      pResData^  := udNo;              //set no of return data
      pResData   += sizeof(UDINT);     //move result ptr
      
      while (udNo > 0) do
        if (IsValidServer((((pRead)$^pVoid)^)$pSvrCh)) then
          //call read method and save data into result buffer
          //old style awl method: pResData^ := RD((((pRead)$^pVoid)^)$pSvrCh)$UDINT;          
          pMeth          := (((pRead)$^pVoid)^)$^void;
          pResData^$DINT := pMeth$^VirtualBase^.Read();
        else
          pResData^$DINT := ACCESS_DENIED;    //set default value, if data couldn´t be read
        end_if;
                      
        pRead      += sizeof(UDINT);   //move ptr
        pResData   += sizeof(UDINT);   //move result ptr
        udNo       -= 1;               //dec counter
        udNoResult += 1;               //inc counter of no result data
      end_while;
      
      //--- 2 byte of uiLng + size of udNo + size of n data
      _m.resu.uiLng := TO_UINT(2 + sizeof(UDINT) + (udNoResult * sizeof(UDINT)));
    end_if;

  //--------------------------------------------------------------------
	//<i_wr_svrlist> <[no 4byte][lid 4byte][data 4byte][lid 4byte][data 4byte][lid 4byte]..>  //JOE 25-02-2011
	//--------------------------------------------------------------------
  I_WR_SVRLIST:
    IF _m.head.funkst = READY THEN
      _m.head.funkst := BUSY;
  
      udNo       := pRead^$UDINT;      //no of lids and data
      pRead      += sizeof(UDINT);     //move ptr
      udNoResult := 0;                 //initialize
      
      pResData^  := udNo;              //set no of return data
      pResData   += sizeof(UDINT);     //move result ptr
      
      while (udNo > 0) do
        if (IsValidServer((((pRead)$^pVoid)^)$pSvrCh)) then
          //call write method and save return data into result buffer
          //old style awl method: pResData^ := WR((((pRead)$^pVoid)^)$pSvrCh, (pRead + sizeof(UDINT))^$DINT)$UDINT;          
          pMeth          := (((pRead)$^pVoid)^)$^void;
          pRead          += sizeof(UDINT);              //move ptr to data
          pResData^$DINT := pMeth$^VirtualBase^.Write(pRead^$DINT);
        else
          pRead          += sizeof(UDINT);
          pResData^$DINT := ACCESS_DENIED;        //set default value, if data couldn´t be written
        end_if;
        
        pRead      += sizeof(UDINT);   //move ptr to next lid
        pResData   += sizeof(UDINT);   //move result ptr
        udNo       -= 1;               //dec counter
        udNoResult += 1;               //inc counter of no result data
      end_while;
      
      //--- 2 byte of uiLng + size of udNo + size of n data
      _m.resu.uiLng := TO_UINT(2 + sizeof(UDINT) + (udNoResult * sizeof(UDINT)));
    end_if;
    
  //--------------------------------------------------------------------
	//<i_getObj> <"varname">
	//--------------------------------------------------------------------

	I_GET_OBJ:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;
									// text // p_CH      // p_obj
			chMode := _LookUpEmbed_C(pRead$^char, pResData$^pVoid, pResData$^pVirtualBase+SIZEOF(pVoid));
			
			CASE chMode OF
			_CH_NONE:
				(pResData+8)^$CHMODE := chMode;
				(pResData+10)^$UINT  := 0;
				_m.resu.uiLng := 14;			// len(2), 2x Ptr (8), Mode (4), class name (x)
				GOTO GOT_OBJ;
			_CH_CLT_CMD,		// für LASAL zumindest zum Debugger testen drinnen lassen
			_CH_CLT_DATA,
			_CH_CLT_EMB,
			_CH_CLT_OBJ,
			_CH_CMD,_CH_SVR,_CH_CNST:
				(pResData+8)^$CHMODE := chMode;
				(pResData+10)^$UINT  := 0;
				_m.resu.uiLng := 14;			// len(2), 2x Ptr (8), Mode (4), class name (x)
			_CH_OBJ:
				(pResData+8)^$CHMODE := chMode;
				(pResData+10)^$UINT  := 0;
				_m.resu.uiLng := 14+			// len(2), 2x Ptr (8), Mode (4), class name (x)
								GetClassName(pResData^$^VirtualBase, pResData+12);
			ELSE
				GOTO SET_ERROR;
			END_CASE;

			IF GetDataBufferFlag( pResData^ $ ^VirtualBase ) THEN
				_m.resu.uiLng += 1;
				_m.resu.aData[_m.resu.uiLng-3] := 0x4;
			END_IF;
			GOT_OBJ:

		END_IF;

	//--------------------------------------------------------------------
	//<i_get_Obj_CLS> <"varname">
	//--------------------------------------------------------------------

	I_GET_OBJ_CLS:

		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

							// text       // p_CH   // p_obj
			CASE _LookUpEmbed_C(pRead$^char, pResData$^pVoid, pResData$^pVirtualBase+4) OF
			_CH_NONE:
				GOTO SET_ERROR;

			_CH_CNST:
				_STRCPY(pResData$^char+8, "DINT");
				GOTO SET_ERG;

			ELSE
				pObj   := LSL_GetHdr((pResData+4)^$UDINT);
				_STRCPY(pResData$^char+8, _GetClsName(pObj^.pClsHdr));

SET_ERG:
				_m.resu.uiLng	:= (10+_STRLEN(pResData$^char+8)+1)$UINT;	// 10 = len(2)+2x Ptr(8)
			END_CASE;
		END_IF;


	//--------------------------------------------------------------------
	// Returns the name of the class of a given object
	// Byte: Len: Mnemo:
	// 0     4    <pThis>    pointer to the object
	//--------------------------------------------------------------------
	I_GET_CLS:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;
			_m.resu.uiLng	:= sizeof(UINT)+GetClassName(pRead^$^VirtualBase, pResData);
		END_IF;

	//--------------------------------------------------------------------
	// Returns the pointer to a class descriptor. The class name is given 
	// Byte: Len: Mnemo:
	// 0     4    <pClsName>    class name
	//--------------------------------------------------------------------
	I_GET_CLS_BY_NAME:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;
			pResData^$^ClsHdr	:= _LookupCls(pRead$^char);
			_m.resu.uiLng	:= sizeof(UINT)+sizeof(^ClsHdr);
		END_IF;

	//--------------------------------------------------------------------
	// Returns the pointer to the next derived class of a base class.
	// Byte: Len: Mnemo:
	// 0     4    <pClsBase>    class pointer of base class
	// 4     4    <pClsLast>    class pointer of last derived class
	//--------------------------------------------------------------------
	I_GET_NXT_DERIVED:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;
			pRead		:= _GetNextDerivedClass((pRead+4)^$^ClsHdr, pRead^$^ClsHdr);
			pResData^$^ClsHdr	:= pRead$^ClsHdr;
			_m.resu.uiLng	:= sizeof(UINT)+sizeof(^ClsHdr);
			IF pRead THEN			// if class exists
				pRead		:= _GetClsName(pRead$pClsHdr);		// get pointer to its name
				j			:= _strlen(pRead$^char)$UINT;	// and copy it to result buffer
				_memcpy(pResData+sizeof(pClsHdr), pRead, j);
				_m.resu.uiLng	+= j;						// add string length
			END_IF;
		END_IF;

	//--------------------------------------------------------------------
	// Returns the definition of a class
	// Byte: Len: Mnemo:
	// 0     4    <pClsDsc>    pointer to the previous class descriptor
	//													!!! NIL returns the first class !!!
	//--------------------------------------------------------------------
	I_READ_CLASS:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

     #ifdef _LSL_TARGETARCH_ARM
			_GetClsNameN(#_m.resu.uiLng, pRead^$^ClsHdr, pResData);
     #else
			_GetClsNameN(pRead^$^ClsHdr, pResData);
			_m.resu.uiLng	:= AX;
     #endif
		END_IF;


	//--------------------------------------------------------------------
	// Returns the definition of an object
	// Byte: Len: Mnemo:
	// 0     4    <pCls>     pointer to a class header
	// 4     2    <pObjDsc>  pointer to the previous object descriptor
	//												!!! NIL returns the first object !!!
	//--------------------------------------------------------------------
	I_READ_OBJECT:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;

     #ifdef _LSL_TARGETARCH_ARM
			_GetObjNameN(#_m.resu.uiLng, pRead^$pClsHdr, (pRead+4)^$^OBJ, pResData);
     #else
			_GetObjNameN(pRead^$pClsHdr, (pRead+4)^$^OBJ, pResData);
			_m.resu.uiLng	:= AX;
     #endif
		END_IF;


	//--------------------------------------------------------------------
	// Returns the definition of an channel
	// Byte: Len: Mnemo:
	// 0     4    <pCls>     pointer to a class header
	// 4     2    <pObjDsc>  pointer to the previous channel descriptor
	//												!!! NIL returns the first channel !!!
	//--------------------------------------------------------------------
	I_READ_CHANNEL:
		IF _m.head.funkst = READY THEN
			_m.head.funkst		:= BUSY;

     #ifdef _LSL_TARGETARCH_ARM
			_GetClsChan(#_m.resu.uiLng, pRead^$pClsHdr, (pRead+4)^$^ChDsc, pResData);
     #else
			_GetClsChan(pRead^$pClsHdr, (pRead+4)^$^ChDsc, pResData);
			_m.resu.uiLng	:= AX;
     #endif
		END_IF;


	//--------------------------------------------------------------------
	// Get the definition of a method of a class
	// Byte: Len: Mnemo:
	// 0     4    <pCls>     pointer to a class header
	// 4     2    <uiMeth>   # OF the method
	//--------------------------------------------------------------------
//	I_READ_METHOD:	LSL2
//		IF _m.head.funkst = READY THEN
//			_m.head.funkst	:= BUSY;
//
//			_GetMethNamen(pRead^$pClsHdr, (pRead+4)^$UINT, pResData$^MethDscEntry);
//			_m.resu.uiLng := AX;
//		END_IF;


	//--------------------------------------------------------------------
	// Byte: Len: Mnemo: provides a checksum over the descriptor tables of
	// 0     0    <>     the project, no parameters
	//--------------------------------------------------------------------
	I_GET_DESC_CRC:

		IF _m.head.funkst = READY THEN
			_m.head.funkst		:= BUSY;

     #ifdef _LSL_TARGETARCH_ARM
			_m.resu.uiLng := to_uint(_GetDesc_CRC(pResData));
     #else
			_GetDesc_CRC(pResData);
			_m.resu.uiLng :=  AX;
     #endif
		END_IF;


	//--------------------------------------------------------------------
	// Byte: Len: Mnemo:   retrieves the name of the connected channel    of
	// 0     4    pObjDsc  pointer to the object descriptor
	// 4     4    pChDsc   pointer to the class' channel descriptor
	// returns the name without 0-termination                      
	//--------------------------------------------------------------------
  	I_READ_CONNECT:
		IF _m.head.funkst = READY THEN
			_m.head.funkst		:= BUSY;

     #ifdef _LSL_TARGETARCH_ARM
			_m.resu.uiLng := to_uint(_GetChConnection(pRead^$pObjDsc, (pRead+4)^$^ChDscEntry, pResData$^char));
     #else
			_GetChConnection(pRead^$pObjDsc, (pRead+4)^$^ChDscEntry, pResData$^char);
			_m.resu.uiLng :=  AX;
     #endif
		END_IF;


	I_GET_OBJ_NAME:
		IF _m.head.FunkSt = READY THEN
			_m.head.funkst	:= BUSY;
     #ifdef _LSL_TARGETARCH_ARM
			_m.resu.uiLng	:= to_uint(_GetObjNameFromAddr(pRead^$^VirtualBase, pResData$^char));
     #else
			_m.resu.uiLng	:= _GetObjNameFromAddr(pRead^$^VirtualBase, pResData$^char);
     #endif
		END_IF;

	//--------------------------------------------------------------------
	//<I_GET_PROGNR> <>
	//--------------------------------------------------------------------

	I_GET_PROGNR:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;
			
			pResData^	:= ProgMgr::GetProgramNumber(pRead $ ^char);
			_m.resu.uiLng	:= 3;	// len (2) + data (1 byte)
		END_IF;

	//--------------------------------------------------------------------
	//<I_VISU_RDY> <>
	//--------------------------------------------------------------------

	I_VISU_RDY:	//ZP000
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;
			
      LDR_SetWait4Visu(FALSE, 0);
			_m.resu.uiLng	:= SEND_STATE_ONLY;
		END_IF;
    
  //--------------------------------------------------------------------
	//<I_INIT_MERKEREX> <>
  //
  //  0 1 2 3   4                5 6 7 8    9 10 11 12
	//  <Dest>    <Read=0/write=1> <Callerid> <datalen>
  //  returns 4 Byte Handle, 4 byte datalen 
	//--------------------------------------------------------------------
  I_INIT_MERKEREX:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;
      
      IF !!IsValidServer(((pRead$^pVoid)^)$^SvrCh) THEN
				GOTO SET_ERROR;
			END_IF;

      //DB1753: Applikationscode wird nicht aufgerufen, wenn die Applikation nicht läuft
      IF !!IsApplRunning() THEN 
				GOTO SET_ERROR;
      END_IF;

      IF (GetMerkerExStruct(pRead, pResData) = TRUE) THEN
        _m.resu.uiLng		:= 2 + sizeof(UDINT)+sizeof(UDINT);	//  handle (4 byte) + len (4 byte)
      ELSE
				GOTO SET_ERROR;
      END_IF;
			
		END_IF;
    
  //--------------------------------------------------------------------
	//<I_MERKEREX> <>
  //   0 1 2 3                        4 5 6 7     8 9 10 11   12 13 14 15  ab 16
	//  <Handle from I_INIT_MERKEREX>  <Callerid>  <datalen>   <offset>     <data>
  //  returns 4 byte datalen 
	//--------------------------------------------------------------------
  I_MERKEREX:
		IF _m.head.funkst = READY THEN
			_m.head.funkst := BUSY;
   
      udCheck := OnMerkerExCmd(pRead, pResData);
      IF (udCheck = 0) THEN
        GOTO SET_ERROR;
      ELSE
   			 _m.resu.uiLng := 2 + udCheck$UINT;		// len
      END_IF;
      
		END_IF;
      
	ELSE
  		state := BaseIp::BefIpr(bSetNext);
  		IF state = ERROR THEN
SET_ERROR:
			state  := ERROR;
   			_m.resu.uiLng := SEND_STATE_ONLY;
  		END_IF;

	END_CASE;
  END_IF;

Ende:

END_FUNCTION


#include <lsl_st_cmdif.h>

(*
  Initialisiert das DebugIp Modul
*)
FUNCTION GLOBAL DebugIp_Init

  OS_pLslCmd := NIL;
  m_pMerkerExStruct := NIL;
  m_udMerkerExStructCnt := 0;

END_FUNCTION

(*
  Globale LslCmd Send-Callback Funktion
*)
FUNCTION __cdecl G_LslCmdSend
VAR_INPUT
#pragma warning(disable:73)
  pUserData : pVoid;
  txBuffer : ^USINT;
  sendLen : UDINT;
  cmd : USINT;
  status : USINT;
  cpuStatus : USINT;
  awlBpStatus : USINT;
#pragma warning(default:73)
END_VAR
VAR_OUTPUT
  retCode : DINT;
END_VAR

 #ifdef _LSL_TARGETARCH_ARM
  retCode := pUserData$^DebugIp^.LslCmdSend(txBuffer, sendLen, status, cpuStatus, awlBpStatus);
 #else
  ESI := pUserData;
  retCode := DebugIp::LslCmdSend(txBuffer, sendLen, status, cpuStatus, awlBpStatus);
 #endif
 
END_FUNCTION
(*
	Öffnet eine LslCmd Verbindung zum Betriebssystem und allokiert die Sende- und 
	Empfangsbuffer.	
*)
FUNCTION DebugIp::LslCmdOpen
VAR_OUTPUT
	pCmdIf : pVoid;
END_VAR
	
	IF (OS_pLslCmd = NIL) & OS_CILGet("LSLCMDIF", #OS_pLslCmd$void) THEN
		m_cmdIf := NIL;
    pCmdIf := NIL;
    RETURN;
	END_IF;

	m_rxCounter := 0;
	m_nextSegNbr := 0;

  IF m_bOsResourcesUsed THEN
    m_pRxBuf := OS_SysMalloc(LSLCMD_RECVBLOCKSIZE)$^USINT;
    // Am Anfang Platz für 3 Byte Statuscodes reservieren
    m_pTxBuf := OS_SysMalloc(LSLCMD_SENDBLOCKSIZE + 3)$^USINT;
  ELSE
    m_pRxBuf := _alloc(LSLCMD_RECVBLOCKSIZE)$^USINT;
    m_pTxBuf := _alloc(LSLCMD_SENDBLOCKSIZE + 3)$^USINT;  
  END_IF;
  
 	m_cmdIf$pVoid := OS_LSLCMD_Open(LSLCMD_COMMID_LOADER,
							  this,						        // userData
							  #m_rxCounter,			      // 
							  m_pTxBuf + 3,			      // txBuffer
							  LSLCMD_SENDBLOCKSIZE,		// maxTXlen
							  LSLCMD_SENDBLOCKSIZE,		// maxSendBlockSize
							  LSLCMD_RECVBLOCKSIZE,		// maxRecvBlockSize
							  #G_LslCmdSend() 			  // fnSend
							  );

	IF m_cmdIf = NIL | m_pRxBuf = NIL | m_pTxBuf = NIL THEN
		LslCmdClose();
	END_IF;

	pCmdIf := m_cmdIf;

END_FUNCTION
(*
	Schließt eine LslCmd Verbindung und gibt die Sende- und Empfangsbuffer frei.	
*)
FUNCTION DebugIp::LslCmdClose

	IF m_cmdIf <> NIL THEN
		OS_LSLCMD_Close(m_cmdIf);
		m_cmdIf := NIL;
	END_IF;

	IF m_pRxBuf <> NIL THEN
    IF m_bOsResourcesUsed THEN
      OS_SysFree(m_pRxBuf);
    ELSE
      _free(m_pRxBuf);
    END_IF;
		m_pRxBuf := NIL;
	END_IF;

	IF m_pTxBuf <> NIL THEN
    IF m_bOsResourcesUsed THEN
      OS_SysFree(m_pTxBuf);
    ELSE
      _free(m_pTxBuf);
    END_IF;
		m_pTxBuf := NIL;
	END_IF;

END_FUNCTION
(*
	Die Callback Sendefunktion, die vom LslCmd Modul aufgerufen wird, wenn 
	Daten zu senden sind.
  Wenn kein Fehler auftritt, wird 0 zurückgegeben, ansonsten ein neg. Fehlercode.
*)
FUNCTION GLOBAL DebugIp::LslCmdSend
VAR_INPUT
  txBuffer : ^USINT;
  sendLen : UDINT;
  status : USINT;
  cpuStatus : USINT;
  awlBpStatus : USINT;
END_VAR
VAR_OUTPUT
  retCode : DINT;
END_VAR
VAR
  pTxBuf : ^USINT;
END_VAR

  retCode := -1;

  IF sendLen > LSLCMD_SENDBLOCKSIZE THEN
    RETURN;
  END_IF;

  pTxBuf := m_pTxBuf;
  pTxBuf^ := status;
  pTxBuf += 1;
  pTxBuf^ := cpuStatus;
  pTxBuf += 1;
  pTxBuf^ := awlBpStatus;
  pTxBuf += 1;

  m_txBufUsed := sendLen + 3;
  m_pTxBufUsed := m_pTxBuf;

  retCode := 0;
	
END_FUNCTION
(*
	Die Callback Sendefunktion, die vom LslCmd Modul aufgerufen wird, wenn 
	ein Fehler in der Verarbeitung passiert (unbekannter Befehl).
	Sie dient dazu, den internen Status zurückzusetzen.
*)
FUNCTION DebugIp::LslCmdError
	
		m_nextSegNbr := 0; 

END_FUNCTION
//
// I_LSLCMD Befehl:
//	Mit dem I_LSLCMD Befehl wird ein Segment eines Lasal32 Online Befehls und dessen 
//  Antwort übertragen. Ein Befehl und die Antwort wird in Segmente unterteilt, weil 
//  mit dem Befipr Mechanismus pro Request nur max. 255/254 Bytes übertragen werden 
//  können.
//  Jedes Segment wird mit einer segNbr numeriert (0-basierend). Anhand der segNbr 
//	können doppelte oder fehlende Segmente erkannt werden.
//	Zuerst werden die Segmente des Requests übertragen, danach werden die Segmente der 
//	Response angefordert. Das letzte Segment des Requests und das erste Segment der 
//	Response werden in einem einzigen Befipr Befehl übertragen.
//
// Aufbau eines Segments
// 
//   flags   : USINT
//   			Bit 7   : 1 = kennzeichnet letztes Segment
//   			Bit 6   : 1 = Anforderung eines Segments der Lasal32 Response.
//              			  Die angeforderte Segmentnummer steht im Feld seqNbr bzw. 
//                      wenn flags.7 = 1, dann wird Segmentnummer 0 angefordert.
//                      Dieses Bit kann nur im Befipr Code und nicht in der Befipr 
//                      Resu gesetzt sein.
//				Bit 5   : 1 = Single-Segment
//                      Bei einem Single-Segment fehlt segNbr. Die Segmentnummer 
//                      ist in diesem Fall 0.
//   segNbr  : UINT
//				Segmentnummer des Lasal32 Requests bzw. der (angeforderten) Response.
//   data    : ARRAY[0..??] OF USINT;
//				Die Daten des Segments. Die Anzahl der Daten wird aus dem Längenfeld 
//				des Befipr Befehls errechnet.
// 
// Verpackung des Segments im Befipr Befehl
//
// 	Instruct:
// 	a) Single-Segment
//		! uiLng(2B) ! opcode(1B) ! aData(255B)                                                !
//  	!                        ! flags(1B) ! data(254B)                                     !
//  	!                                    ! cmd(1B) ! data(253B)                           !
// 	b) Multi-Segment, 1.Segment
//		! uiLng(2B) ! opcode(1B) ! aData(255B)                                                !
//  	!                        ! flags(1B) ! segNbr(2B) ! reqLen(4B) ! data(248B)           !
//  	!                                                              ! cmd(1B) ! data(247B) !
// 	c) Multi-Segment, 2.+ Segment
//		! uiLng(2B) ! opcode(1B) ! aData(255B)                                                !
//  	!                        ! flags(1B) ! segNbr(2B) ! data(252B)                        !
//
// 	Results:
// 	a) 1.Segment
//		! uiLng(2B) ! aData(254B)                                                             !
//  	!           ! flags(1B) ! data(253B)                                                  !
//  	!                       ! status(1B) | cpuStatus(1B) ! extStatus(1B) ! data(250B)     !
// 	b) 2.+ Segment
//		! uiLng(2B) ! aData(254B)                                                             !
//  	!           ! flags(1B) ! data(253B)                                                  !
//
// Max. mögliche Datenmengen in einer 4-Segment Message:
//	Request:
//		1.Segment:	   1B Cmd, 248B Data
//  	2.-4.Segment:        3*252B Data
//      	           -----------------
//          	       1B Cmd, 1004B Data
//  Response:
//		1.Segment:	   3B Status, 250B Data
//  	2.-4.Segment:           3*253B Data
//                   --------------------
//                   3B Status, 1009B Data
//
//  Der Einfachheit halber und wg. einer Reserve für zukünftige Erweiterungen 
//  wird die max. mögliche Datenmenge auf 1000 Bytes festgelegt.

(*
  Interpretiert eine I_LSLCMD Instruktion und setzt die Elemente der Struktur 
  SEG_INFO entsprechend. Wenn ein Fehler festgestellt wird, dann wird FALSE 
  zurückgegeben.
*)
FUNCTION InterpretLslCmdInstruct
VAR_INPUT
  pCode : ^INSTRUCT;
  pSI : ^DebugIp::SEG_INFO;
END_VAR
VAR_OUTPUT
  retCode : BOOL;
END_VAR
VAR
	flags		: USINT;
END_VAR

  retCode := TRUE;

  _memset(pSI, 0, sizeof(DebugIp::SEG_INFO));

	flags  := pCode^.aPara[0] AND 16#E0;

	IF ((flags AND 16#C0) = 16#00) | ((flags AND 16#C0) = 16#C0) THEN
    //
    // Es ist ein Request Segment vorhanden
    // 
    pSI^.isAvail := TRUE;
    IF flags AND 16#80 THEN
      pSI^.isLast := TRUE;
    END_IF;
  	IF flags AND 16#20 THEN
  		// Single-Segment beinhaltet das segNbr Feld nicht
  		pSI^.segNbr := 0;
  		pSI^.segLen := pCode^.uiLng - sizeof(UINT) - 1(*cmd*) - 1(*flags-1*);
  		pSI^.pData  := #pCode^.aPara[1];

      pSI^.reqLen := pSI^.segLen;
  	ELSE
  		// Multi-Segment beinhaltet das segNbr Feld
  		pSI^.segNbr := pCode^.aPara[1]$UINT;
  		IF pSI^.segNbr = 0 THEN
  			// Beim 1.Segment einer Multi-Segment Message ist das Feld reqLen vorhanden
    		pSI^.segLen := pCode^.uiLng - sizeof(UINT) - 1(*cmd*) - 7(*flags-1,segNbr-2,reqLen-4*);
  			pSI^.pData  := #pCode^.aPara[7];

        pSI^.reqLen := pCode^.aPara[3]$UDINT;
  		ELSE
  			// Beim den folgenden Segmenten einer Multi-Segment Message ist das Feld reqLen 
  			// nicht vorhanden und wird auch nicht benötigt.
    		pSI^.segLen := pCode^.uiLng - sizeof(UINT) - 3(*flags-1,segNbr-2*);
  			pSI^.pData  := #pCode^.aPara[3];
  		END_IF;
  	END_IF;
    IF pSI^.segNbr = 0 THEN
      pSI^.cmd := pSI^.pData^;
      pSI^.pData += 1;
    END_IF;
  END_IF;

  IF flags AND 16#40 THEN
    //
    // Es wird ein Response Segment angefordert
    // 
    pSI^.fGetResp := TRUE;
    IF flags AND 16#80 THEN
      pSI^.segNbrResp := 0;
    ELSE
      pSI^.segNbrResp := pCode^.aPara[1]$UINT;
    END_IF;
  END_IF;

  // es müßen entweder Segmentdaten vorhanden sein oder welche angefordert werden.
  IF !!pSI^.isAvail & !!pSI^.fGetResp THEN
    retCode := FALSE;
  END_IF;

END_FUNCTION
(*
  Prüft, ob die empfange Segmentnummer mit der nächsten erwarteteten übereinstimmt.
  Wenn das erste Segment erkannt wird, dann werden die Zustandsvariablen resettiert.
  Return:
   1: o.k.
   0: doppeltes Segment empfangen
  -1: ungültige Segmentnummer 
*)
FUNCTION DebugIp::CheckNextSegNbr
VAR_INPUT
  pSI : ^SEG_INFO;
END_VAR
VAR_OUTPUT
  retCode : DINT;
END_VAR
VAR
  segNbrTmp : UINT;
END_VAR

  retCode := 1;

	IF pSI^.isAvail & pSI^.segNbr = 0 THEN
    // Das erste Segment resetiert die Zustandsvariablen
    m_nextSegNbr := 0;
    m_txBufUsed := 0;
    m_pTxBufUsed := NIL;
  END_IF;

	IF pSI^.isAvail THEN
    segNbrTmp := pSI^.segNbr;
  ELSE
    segNbrTmp := pSI^.segNbrResp OR 16#8000;
  END_IF;
  IF segNbrTmp <> m_nextSegNbr THEN 
    IF (segNbrTmp = m_nextSegNbr - 1) | (m_nextSegNbr = 16#8001 & pSI^.isLast) THEN
      // doppelte Segmentnummer eingetroffen
      retCode := 0;
    ELSE
      // ungültige Segmentnummer eingetroffen
      retCode := -1;
		END_IF;
  END_IF;

END_FUNCTION
(*
	Bearbeitet einen I_LSLCMD Befehl. Wird vom DebugIp::BefIpr heraus aufgerufen.
*)
FUNCTION DebugIp::ProcessLslCmd
VAR_OUTPUT
	state		: IprStates;
END_VAR
VAR
  segInfo : SEG_INFO;
  segOk : DINT;
  retLen : UINT;
	rc : DINT;
  pDest : ^USINT;
  bFirstRespSeg : BOOL;
END_VAR

	state		:= READY;
	_m.resu.uiLng	:= SEND_STATE_ONLY;		// no return value specified

	// Falls noch keine LslCmd Verbindung besteht, dann wird sie jetzt hergestellt.
	IF m_cmdIf = NIL & LslCmdOpen() = NIL THEN
    state := ERROR;
		RETURN;
	END_IF;

  //
  // die Felder des Headers auswerten
  //
  IF !!InterpretLslCmdInstruct(_m.head.pCode, #segInfo) THEN
    state := ERROR;
		RETURN;
	END_IF;

  //
  // wurde die korrekte Segmentnummer empfangen ?
  //
  segOk := CheckNextSegNbr(#segInfo);
  IF segOk = 0 THEN
    // doppelte Segmentnummer eingetroffen -> Segmentdaten werden nicht benötigt
    GOTO CheckGetResp;
	END_IF;
  IF segOk < 0 THEN
    // ungültige Segmentnummer eingetroffen -> Fehler
    GOTO ProcessLslCmd_Error;
  END_IF;

	IF segInfo.isAvail THEN
    //
    // Es ist ein Request Segment vorhanden
    // 
		IF segInfo.segNbr = 0 THEN // handelt es sich um das 1.Segment ?
			rc := OS_LSLCMD_PRECmd(m_cmdIf,
			                       m_pRxBuf,				// defRxBuf
								             LSLCMD_RECVBLOCKSIZE,	// defRxBufSize
                             segInfo.cmd,	    // cmd
                             segInfo.reqLen		// dataLen
                             );
      IF rc <> PRECMD_DATA & rc <> PRECMD_POST THEN
        GOTO ProcessLslCmd_Error;
      END_IF;
		END_IF;

    //++todo:
    //OS_LSLCMD_SetErrorFlag aufrufen, wenn ein Fehler auftritt

    // Request Daten aufsammeln
    OS_LSLCMD_CollectData(m_cmdIf, segInfo.pData, segInfo.segLen);

    IF segInfo.isLast THEN // handelt es sich um das letzte Segment ?
      OS_LSLCMD_POSTCmd(m_cmdIf, fError := 0);
      m_nextSegNbr := 16#8000;
    ELSE
      m_nextSegNbr := segInfo.segNbr + 1;
    END_IF;
  END_IF;

CheckGetResp:
  IF segInfo.fGetResp THEN
    //
    // Es wird ein Response Segment angefordert
    // 
    IF m_pTxBufUsed = NIL THEN
      // keine Antwort vorhanden
      state := ERROR;
    ELSE
      retLen := m_txBufUsed$UINT;
      IF retLen > arraysize(_m.head.pResu^.aData) - 1 THEN
        retLen := arraysize(_m.head.pResu^.aData) - 1;
      END_IF;
      pDest := #_m.head.pResu^.aData[1];

      _m.head.pResu^.aData[0] := 0;      // flags
      IF m_pTxBufUsed = m_pTxBuf THEN
        // 1.Antwortsegment
        bFirstRespSeg := TRUE;
      ELSE
        // die folgenden Antwortsegmente
        bFirstRespSeg := FALSE;
      END_IF;

      _memcpy(pDest, m_pTxBufUsed, retLen);
      _m.head.pResu^.uiLng := retLen + 2(*uiLng*) + 1(*flags*);

      m_pTxBufUsed += retLen;
      m_txBufUsed -= retLen;
      IF m_txBufUsed = 0 THEN
        IF bFirstRespSeg THEN
          _m.head.pResu^.aData[0] := 16#A0;  // flags: single + last Segment
        ELSE
          _m.head.pResu^.aData[0] := 16#80;  // flags: last Segment
        END_IF;
        m_pTxBufUsed := NIL;
        m_nextSegNbr := 0;
      ELSE
        m_nextSegNbr := (segInfo.segNbrResp + 1) OR 16#8000;
      END_IF;
    END_IF;
  END_IF;

	RETURN;

ProcessLslCmd_Error:

  m_nextSegNbr := 16#8000;
  state := ERROR;
  OS_LSLCMD_POSTCmd(m_cmdIf, fError := 1);

END_FUNCTION

// Liefert die ID des Tools, für das dieser Ip zuständig ist
FUNCTION GLOBAL DebugIp::GetToolID
VAR_OUTPUT
	udID		: UDINT;
END_VAR

	udID	:= m_udIDTool;

END_FUNCTION
// Liefert die ID des Tools, für das dieser Ip zuständig ist
FUNCTION GLOBAL DebugIP::SetToolID
VAR_INPUT
	udID		: UDINT;
END_VAR

	m_udIDTool	:= udID;

END_FUNCTION

// This function returns the next parameter from a
// parameter buffer
FUNCTION DebugIp::GetPara
	VAR_INPUT
		pRead 	: ^void;
	END_VAR
	VAR_OUTPUT
		dPara 	: DINT;
	END_VAR

  IF pRead^$Prefix = P_IMMED THEN		// prefix:	constant
    dPara := (pRead+1)^$DINT;
  ELSE													// prefix:	variable address
    dPara := RD((((pRead+1)$^pVoid)^)$pSvrCh);
  END_IF;

END_FUNCTION
// pRead should point to the address of a client channel. The read- method
// of the connected server is called, and the results are returned.
FUNCTION DebugIp::GetCltPara
	VAR_INPUT
		pRead 	: ^void;
	END_VAR
	VAR_OUTPUT
		dPara 	: DINT;
	END_VAR

  IF pRead^$Prefix = P_IMMED THEN		// prefix:	constant
    dPara := (pRead+1)^$DINT;
  ELSE													// prefix:	variable address
    dPara := RD_Chnl((((pRead+1)$^pVoid)^)$pSvrCh, 0);
  END_IF;

END_FUNCTION

FUNCTION DebugIp::GetMerkerExStruct
	VAR_INPUT
		pRead 	: ^void;
		pResData 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		bOk 	: BOOL;
	END_VAR
  VAR
    udLasalId         : UDINT;
  	bRead             : BYTE;
    udCaller          : UDINT;
    udLen             : UDINT;
    itr               : UDINT;
		pFirstUnused 	    : ^sMerkerExCmd;
		pMerkerExStruct   : ^sMerkerExCmd;
		pSvr 	            : ^SvrCh;
  END_VAR
  
  pFirstUnused := NIL;
  bOk := FALSE;

  //  0 1 2 3   4                5 6 7 8    9 10 11 12
	//  <Dest>    <Read=0/write=1> <Callerid> <datalen>
  
  udLasalId := pRead^$UDINT;
  bRead := (pRead+4)^$BYTE;
  udCaller := (pRead+5)^$UDINT;
  udLen := (pRead+9)^$UDINT;
  
  IF ((m_pMerkerExStruct = NIL) | (m_udMerkerExStructCnt = 0)) THEN
  
    m_pMerkerExStruct := _alloc_resize_LDR(sizeof(sMerkerExCmd))$^sMerkerExCmd;
    IF (m_pMerkerExStruct = NIL) THEN
      RETURN;
    END_IF;
    
    m_udMerkerExStructCnt := 1;
    _memset(m_pMerkerExStruct, 0, sizeof(sMerkerExCmd));
    pFirstUnused := m_pMerkerExStruct;
  
  END_IF;
  
  IF ((m_pMerkerExStruct = NIL) | (m_udMerkerExStructCnt = 0)) THEN
    RETURN;
  END_IF;

  IF (pFirstUnused = NIL) THEN
    FOR itr := 0 TO (m_udMerkerExStructCnt -1 ) BY 1 DO
      pMerkerExStruct := (m_pMerkerExStruct + (itr * sizeof(sMerkerExCmd)));
      
      // nach bestimmten timeout werden die buffers ungültig und können wiederverwendet werden
      IF ((pMerkerExStruct^.bValid = TRUE) & ((ops.tAbsolute - pMerkerExStruct^.tTimeout) > 3000)) THEN // 3s TCP Timeout
        pMerkerExStruct^.bValid := FALSE;
        pMerkerExStruct^.udHandle := 0;
        pMerkerExStruct^.udLen := 0;
        pMerkerExStruct^.tTimeout := 0;
      END_IF;
      
      // ersten freien buffer suchen
      IF ((pFirstUnused = NIL) & (pMerkerExStruct^.bValid = FALSE)) THEN
        pFirstUnused := pMerkerExStruct;
      ELSIF ((pFirstUnused <> NIL) & (pMerkerExStruct^.bValid = FALSE) & (pFirstUnused^.udBufferLen < udLen) & (pFirstUnused^.udBufferLen < pMerkerExStruct^.udBufferLen)) THEN
        pFirstUnused := pMerkerExStruct;
      END_IF;
    END_FOR;
  END_IF;
  
  IF (pFirstUnused = NIL) THEN

    m_udMerkerExStructCnt += 1;
    pMerkerExStruct := _realloc_LDR(m_pMerkerExStruct, m_udMerkerExStructCnt * sizeof(sMerkerExCmd))$^sMerkerExCmd;
    IF (pMerkerExStruct = NIL) THEN
      // Speicher aus...
      m_udMerkerExStructCnt -= 1;
      RETURN;
    ELSE
      m_pMerkerExStruct := pMerkerExStruct;
    END_IF;
    
    pMerkerExStruct := (m_pMerkerExStruct + ((m_udMerkerExStructCnt - 1) * sizeof(sMerkerExCmd)));
    _memset(pMerkerExStruct, 0, sizeof(sMerkerExCmd));

  ELSE
  
    pMerkerExStruct := pFirstUnused;

  END_IF;
  
  IF (bRead = 0) THEN
    pSvr  := udLasalId$^SvrCh;
    udLen := pSvr$^MerkerEx^.GetSize();
  END_IF;
  
  pMerkerExStruct^.udHandle  := udCaller;
  pMerkerExStruct^.udLasalId := udLasalId;
  pMerkerExStruct^.udLen     := udLen;
  pMerkerExStruct^.bValid    := TRUE;
  pMerkerExStruct^.bRead     := (bRead = 0);
  pMerkerExStruct^.ofs       := -1;
  
  IF (pMerkerExStruct^.udLen > 0) THEN

    IF ((pMerkerExStruct^.pBuffer = NIL) | (pMerkerExStruct^.udBufferLen = 0)) THEN
      pMerkerExStruct^.pBuffer :=  _alloc_resize_LDR(pMerkerExStruct^.udLen)$^void;
      pMerkerExStruct^.udBufferLen := pMerkerExStruct^.udLen;
    ELSIF ((pMerkerExStruct^.pBuffer <> NIL) & (pMerkerExStruct^.udLen > pMerkerExStruct^.udBufferLen)) THEN
      pMerkerExStruct^.pBuffer :=  _realloc_LDR(pMerkerExStruct^.pBuffer, pMerkerExStruct^.udLen)$^void;
      pMerkerExStruct^.udBufferLen := pMerkerExStruct^.udLen;
    END_IF;
    
    IF (pMerkerExStruct^.pBuffer = NIL) THEN
      // speicher aus
      RETURN;
    END_IF;
    
    // buffer leeren
    _memset(pMerkerExStruct^.pBuffer, 0, pMerkerExStruct^.udBufferLen);

    IF (bRead = 0) THEN
      // Copy data to buffer
      pSvr$^MerkerEx^.GetDataAt(pMerkerExStruct^.pBuffer$^USINT, pMerkerExStruct^.udLen, 0);
    END_IF;

  END_IF;

  pMerkerExStruct^.tTimeout := OPS.tAbsolute;
  
  pResData^     := pMerkerExStruct$UDINT;
  (pResData+4)^ := pMerkerExStruct^.udLen;
  
  bOk := TRUE;
  
END_FUNCTION


FUNCTION DebugIp::OnEndMerkerExCmd
	VAR_INPUT
		pMerkerExStruct 	: ^sMerkerExCmd;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
		pSvr 	: ^SvrCh;
  END_VAR
  
  ret_code := C_OK;

  pSvr := (pMerkerExStruct^.udLasalId)$^SvrCh;
  pMerkerExStruct^.tTimeout := OPS.tAbsolute;

  IF (pMerkerExStruct^.bRead = FALSE) THEN
    
    // write buffer to merkerEx
    IF (pMerkerExStruct^.udLen > pSvr$^MerkerEx^.GetSize()) THEN 
      ret_code := pSvr$^MerkerEx^.SetSize(pMerkerExStruct^.udLen);
    END_IF;
        
    IF (ret_code = C_OK) THEN
      ret_code := pSvr$^MerkerEx^.SetDataAt(pMerkerExStruct^.pBuffer$^USINT + pMerkerExStruct^.ofs, 
                                            pMerkerExStruct^.udLen - pMerkerExStruct^.ofs$UDINT, 
                                            pMerkerExStruct^.ofs$UDINT);
    END_IF;
  
  END_IF;
  
  pMerkerExStruct^.bValid := FALSE;
  pMerkerExStruct^.udHandle := 0;
  pMerkerExStruct^.udLen := 0;
  pMerkerExStruct^.tTimeout := 0;

END_FUNCTION


FUNCTION DebugIp::OnMerkerExCmd
	VAR_INPUT
		pRead 	: ^void;
		pResData 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR
  VAR
    pMerkerExStruct  : ^sMerkerExCmd;
    udOffset    : UDINT;
    pData       : ^void;
    udCaller    : UDINT;
  END_VAR

  udLen := 0;
  
    //--------------------------------------------------------------------
	//<I_MERKEREX> <>
  //   0 1 2 3                        4 5 6 7     8 9 10 11   12 13 14 15  ab 16
	//  <Handle from I_INIT_MERKEREX>  <Callerid>  <datalen>   <offset>     <data>
	//--------------------------------------------------------------------

  pMerkerExStruct := pRead^$^sMerkerExCmd;
  udCaller := (pRead+4)^$UDINT;  
  
  IF ((pMerkerExStruct^.bValid = FALSE) | (udCaller <> pMerkerExStruct^.udHandle)) THEN
    RETURN;
  END_IF;
   
  udOffset := (pRead+12)^$UDINT;
  udLen := (pRead+8)^$UDINT;
  
  IF pMerkerExStruct^.ofs = -1 THEN
    pMerkerExStruct^.ofs := udOffset$DINT;
  END_IF;

  
  IF ((udOffset + udLen) > pMerkerExStruct^.udLen) THEN
     udLen := (pMerkerExStruct^.udLen - udOffset);
  END_IF;
  
  IF (pMerkerExStruct^.bRead = TRUE) THEN
    // buffer to resultdata
    _memcpy(pResData, pMerkerExStruct^.pBuffer + udOffset, udLen);
  ELSE
    // data to buffer
    pData := (pRead+16)$^void;
    _memcpy(pMerkerExStruct^.pBuffer + udOffset, pData, udLen);
  END_IF;
 
  pMerkerExStruct^.tTimeout := OPS.tAbsolute;
  
  IF ((udOffset + udLen) = pMerkerExStruct^.udLen) THEN
    OnEndMerkerExCmd(pMerkerExStruct);
  END_IF;
  
END_FUNCTION
