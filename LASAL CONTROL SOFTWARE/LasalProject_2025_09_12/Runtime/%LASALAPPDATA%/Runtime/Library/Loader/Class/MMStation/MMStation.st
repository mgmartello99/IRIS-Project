//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include <.\ComTypes.h>

(*!
<Class
	Name               = "MMStation"
	Revision           = "0.0"
	GUID               = "{642BC841-861D-462C-A514-8F2AF06B8A78}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(810,120)"
	Comment            = "Informationen zu einer MMStation">
	<Channels>
		<Server Name="ClassSvr" GUID="{DA209673-FA85-4777-A806-6697B913E5A5}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\ComTypes.h" Include="true"/>
			<File Path=".\Loader\Source\include\MultiMasterdefs.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FimLuc"/>
		<Dokumentation Revision="0.0" Date="2015-10-07" Author="FimLuc" Company="Sigmatek" Description="erstellt"/>
	</RevDoku>
</Class>
*)
MMStation : CLASS
	TYPE
#pragma pack(push, 1)
	  ComDefEx : STRUCT  //! <Type Comment="Comdef Struktur für die COMLINK Verbindung" Name="ComDefEx"/>
	    Interface : UDINT;
	    Adress : UINT;
	    pt_COM : ^comData;
	    IpAddress : UDINT;
	    port : UDINT;
	    res : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		m_acConnStr : ARRAY [0..NLNG] OF CHAR;
			//! <Variable Comment="Connection String" Name="m_acConnStr"/>
		m_bConnStrLen 	: BYTE;			//! <Variable Comment="Länge des ConnectionStrings" Name="m_bConnStrLen"/>
		m_bID 	: BYTE;			//! <Variable Comment="Id der Station 0..255" Name="m_bID"/>
		m_bUserCallback 	: BYTE;
		m_bUserStopConn 	: BOOL;
		m_ComDef 	: ComDefEx;
		m_opLastConnTry 	: UDINT;
		m_szName : ARRAY [0..NLNG] OF CHAR;

		m_udCrc 	: UDINT;			//! <Variable Comment="Descriptor CRC der Station" Name="m_udCrc"/>
		m_udServerStartIdx 	: UDINT;
		m_udSymbolServerCnt 	: UDINT;			//! <Variable Comment="Anzahl der Server" Name="m_udSymbolServerCnt"/>
		m_udSymbolServerFoundCnt 	: UDINT;
		m_udSymbolServerInitCnt 	: UDINT;
		m_uiComCnt 	: UDINT;			//! <Variable Comment="Zähler wie oft eine Station verbunden wird und der Verbindungsstatus geprüft wird&#13;&#10;" Name="m_uiComCnt"/>
		m_udState 	: UDINT;
		m_bCheckLdrVersion 	: BOOL;
		m_bLdrVersionOk 	: BOOL;
		m_bAliveTimeActive 	: BOOL;
		m_waitForReqTimeout_ms 	: UDINT;
		m_allReqInitialised 	: DINT;
		m_udState_preFirstInit 	: UDINT;
		m_allReqInitialised_preFirstInit 	: BOOL;
		m_changingConnStr 	: BOOL;
		m_ComdefMutex 	: ^void;
  //Functions:
				//! <Function Comment="Prüft ob Station verbunden ist und setzt den Status wenn geändert" Name="CheckAndRefreshState"/>
	FUNCTION GLOBAL CheckAndRefreshState
		VAR_OUTPUT
			bConnected 	: BOOL;			//! <Variable Comment="TRUE: Verbunden" Name="CheckAndRefreshState.bConnected"/>
		END_VAR;
	
	FUNCTION GLOBAL CheckFileName
		VAR_INPUT
			pszFileName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			nRes 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Establishes connection to plc&#13;&#10;Flag bUserStart is TRUE is function is called from a global loader function&#13;&#10;returns TRUE if successful&#13;&#10;[#DEUTSCH]&#13;&#10;Baut eine Verbindung zu der Station auf&#13;&#10;Das Flag bUserStart gibt an, ob die Funktion via Loaderfunktion oder intern aufgerufen wird&#13;&#10;Liefert TRUE wenn die Verbindung hergestellt wurde" Name="Connect"/>
	FUNCTION GLOBAL Connect
		VAR_INPUT
			bUserStart 	: BOOL;
		END_VAR
		VAR_OUTPUT
			bOk 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL DecreaseSvrInitCnt;
				//! <Function Comment="[#ENGLISH]&#13;&#10;termitates connections to plc&#13;&#10;Flag bUserStart is TRUE is function is called from a global loader function&#13;&#10;returns TRUE if plc is &quot;offline&quot;&#13;&#10;[#DEUTSCH]&#13;&#10;Trennt die Verbindung zu der Station&#13;&#10;Das Flag bUserStart gibt an, ob die Funktion via Loaderfunktion oder intern aufgerufen wird&#13;&#10;Liefert TRUE wenn die Station &quot;offline&quot; ist" Name="Disconnect"/>
	FUNCTION GLOBAL Disconnect
		VAR_INPUT
			bUserStop 	: BOOL;
		END_VAR
		VAR_OUTPUT
			bOk 	: BOOL;
		END_VAR;
				//! <Function Comment="Liefert VerbindungsStruktur" Name="GetComDef"/>
	FUNCTION GLOBAL GetComDef
		VAR_OUTPUT
			pComDef 	: ^Comdef;			//! <Variable Comment="Zeiger auf die Verbindungsstruktur" Name="GetComDef.pComDef"/>
		END_VAR;
	
	FUNCTION GLOBAL GetConnStr
		VAR_INPUT
			pszConnStr 	: ^CHAR;
		END_VAR;
				//! <Function Comment="Liefert Descriptor CRC" Name="GetCrc"/>
	FUNCTION GLOBAL GetCrc
		VAR_OUTPUT
			udCrc 	: UDINT;
		END_VAR;
				//! <Function Comment="Liefert den Dateinamen" Name="GetFileName"/>
	FUNCTION GLOBAL GetFileName
		VAR_INPUT
			pFileName 	: ^CHAR;			//! <Variable Comment="Name der Datei, 0 Terminierter String" Name="GetFileName.pFileName"/>
		END_VAR;
				//! <Function Comment="Liefert ID der Station" Name="GetId"/>
	FUNCTION GLOBAL GetId
		VAR_OUTPUT
			Id 	: BYTE;			//! <Variable Comment="Id der Station" Name="GetId.Id"/>
		END_VAR;
	
	FUNCTION GLOBAL GetSvrCount
		VAR_OUTPUT
			udCnt 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetSvrStartIdx
		VAR_OUTPUT
			udIdx 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL InvokeCallback;
				//! <Function Comment="Prüft ob Station verbunden ist" Name="IsConnected"/>
	FUNCTION GLOBAL IsConnected
		VAR_OUTPUT
			bConnected 	: BOOL;
		END_VAR;
				//! <Function Comment="Prüft ob Station verbunden ist und initialisiert" Name="IsReady"/>
	FUNCTION GLOBAL IsReady
		VAR_OUTPUT
			bReady 	: BOOL;
		END_VAR;
				//! <Function Comment="Verbindungsstring setzen" Name="SetConnStr"/>
	FUNCTION GLOBAL SetConnStr
		VAR_INPUT
			pszStr 	: ^CHAR;
		END_VAR;
				//! <Function Comment="Setzt die Descriptor CRC" Name="SetCrc"/>
	FUNCTION GLOBAL SetCrc
		VAR_INPUT
			udCrc 	: UDINT;			//! <Variable Comment="Descriptor CRC" Name="SetCrc.udCrc"/>
		END_VAR;
	
	FUNCTION GLOBAL SetServerCnt
		VAR_INPUT
			udCnt 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetServerFoundCnt
		VAR_INPUT
			udCnt 	: UDINT;
		END_VAR;
				//! <Function Comment="Wandelt den AsciiString in das IP Format um" Name="AsciiToIPAdr"/>
	FUNCTION AsciiToIPAdr
		VAR_INPUT
			pStr 	: ^CHAR;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			udVal 	: UDINT;
		END_VAR;
				//! <Function Comment="Wandelt den AsciiString in eine UDINT Zahl um" Name="AsciiToUdint"/>
	FUNCTION AsciiToUdint
		VAR_INPUT
			pStr 	: ^CHAR;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			udVal 	: UDINT;
		END_VAR;
				//! <Function Comment="Parst den Verbindungsstring&#13;&#10;Art der Verbindung, derzeit nur TCP unterstützt&#13;&#10;IP Adresse&#13;&#10;Port falls vorhanden, ansonsten DefaultPort" Name="ParseConnStr"/>
	FUNCTION ParseConnStr
		VAR_OUTPUT
			bOk 	: BOOL;			//! <Variable Comment="TRUE: Benötigte Daten in Verbindungsstring gefunden" Name="ParseConnStr.bOk"/>
		END_VAR;
	
	FUNCTION ConnAllowed
		VAR_OUTPUT
			bOk 	: BOOL;
		END_VAR;
	
	FUNCTION SetState
		VAR_INPUT
			udState 	: UDINT;
		END_VAR;
	
	FUNCTION isRemotePlcNodeValid
		VAR_OUTPUT
			retVal 	: BOOL;
		END_VAR;
	
	FUNCTION UpdateAllReqInitialised;
	
	FUNCTION GLOBAL GetAllReqInitialised
		VAR_OUTPUT
			allReqInitialised 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL ComDefLock;
	
	FUNCTION GLOBAL ComDefUnlock;
	
	FUNCTION GLOBAL Initialize;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MMStation::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MMSTATION
0$UINT, 0$UINT, (SIZEOF(::MMStation))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(1180499479), "MMStation", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::MMStation.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
END_FUNCTION


#define USER_CNT_MMStation 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MMStation] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MMStation::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

#pragma usingLtd DebugIp

//{{LSL_IMPLEMENTATION
#include <LSL_ST_MT.H>
#include <RTOS_Mem.h>
#include ".\Multimaster.h"

#define ConnectTimeout  5000 // ms
#define AliveTimeout    1000 // ms

#pragma using MMServer

VAR_EXTERNAL
  // liste die auf speicheradresse der MMServer-Objekte zeigt
  m_pMMServer       : ^void;
  mt_api            : ^LSL_MT_TYPE; // multitask interface
END_VAR

FUNCTION GLOBAL MMStation::GetId
	VAR_OUTPUT
		Id 	: BYTE;
	END_VAR

  Id := m_bID;

END_FUNCTION

FUNCTION GLOBAL MMStation::SetConnStr
	VAR_INPUT
		pszStr 	: ^CHAR;
	END_VAR

  // buffer kopieren
  _strcpy(#m_acConnStr[0], pszStr);
  // länge merken
  m_bConnStrLen := _strlen(#m_acConnStr[0]);
  
END_FUNCTION

FUNCTION MMStation::ParseConnStr
	VAR_OUTPUT
		bOk 	: BOOL;
	END_VAR
  VAR
  	itr            : UDINT; // iterator für string
    bEnd           : BOOL; // Schleifenabbruch 
    c              : CHAR; // aktuelles zeichen 
    bConTypFound   : BOOL; // art der verbindung gefunden 
    bConFound      : BOOL; // ConnString geparst
    iStartConn     : UDINT; // startindex des connection sting 
    iEndConn       : UDINT; // endindex des connection sting 
    iStartPort     : UDINT; // startindex des ports bei IP
    iEndPort       : UDINT; // endindex des ports bei IP 
    pChar          : ^CHAR; // hilfszeiger 
  END_VAR

  bOk := FALSE;
  bEnd := FALSE;
  bConTypFound := FALSE;
  itr := 0;
  iStartConn := 0;
  iEndConn := 0;
  bConFound := FALSE;
  iStartPort := 0;
  iEndPort := 0;
  
  m_ComDef.Interface := 0;
	m_ComDef.Adress    := 0;
	m_ComDef.pt_Com    := NIL;
	m_ComDef.IpAddress := 0;
	m_ComDef.port      := 0;
	m_ComDef.res       := 0;
  
  WHILE (itr < m_bConnStrLen) DO
    c := m_acConnStr[itr];
    IF ((c = ':') & (bConTypFound = false)) THEN
      iStartConn := itr + 1;
      IF (itr = 5) THEN //check auf TCPIP
        IF ((m_acConnStr[0] = 'T') & (m_acConnStr[1] = 'C') & (m_acConnStr[2] = 'P') & (m_acConnStr[3] = 'I') & (m_acConnStr[4] = 'P')) THEN
           bConTypFound := TRUE;
           m_ComDef.Interface := COMLINK_IFNUM_TCP1;
        END_IF;
      END_IF;
    ELSIF ((c = ':') & (bConTypFound = true)) THEN // port mit angegeben?
      iEndConn := itr;
      iStartPort := itr + 1;
    END_IF;
    
    itr += 1;
    
    IF (itr = m_bConnStrLen) THEN
       IF (iEndConn = 0) THEN
        iEndConn := itr;
      END_IF;
        iEndPort := itr;
    END_IF;

  END_WHILE;
  
  // TCP/IP
  IF (m_ComDef.Interface = COMLINK_IFNUM_TCP1) THEN
  
    // port umwandeln oder auf default port setzen
    IF ((iStartPort <> 0) & (iEndPort > iStartPort) & ((iEndPort-iStartPort) <= 4)) THEN
      pChar := #m_acConnStr[iStartPort];
      m_ComDef.port := AsciiToUdint(pChar, iEndPort-iStartPort);
    ELSE
      m_ComDef.port := MM_DEFAULT_TCP_PORT;
    END_IF;

    // IP kopieren
    IF ((iStartConn <> 0) & (iEndConn > iStartConn) & ((iEndConn-iStartConn) <= 15)) THEN
      pChar := #m_acConnStr[iStartConn];
      m_ComDef.ipAddress := AsciiToIPAdr(pChar, iEndConn-iStartConn); // IP umwandeln
      bConFound := TRUE;
    END_IF;
  END_IF;
  
  bOk := bConFound & bConTypFound;

END_FUNCTION

FUNCTION MMStation::AsciiToUdint
	VAR_INPUT
		pStr 	: ^CHAR;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		udVal 	: UDINT;
	END_VAR
  VAR
  	i : UDINT;
  	iEnd : UDINT;
  END_VAR

  udVal := 0;
  
  IF (udLen > 0) THEN
    iEnd := udLen-1;
    FOR i:=0 TO iEnd BY 1 DO
      udVal += (TO_UDINT((pStr + i)^) - 48) * (TO_UDINT(10**(udLen - i - 1)));
    END_FOR;
  END_IF;

END_FUNCTION

FUNCTION xhy_temp
	VAR_INPUT
		ux 	: UDINT;
 		uy 	: UDINT;
	END_VAR
	VAR_OUTPUT
		udVal 	: UDINT;
	END_VAR
  VAR
  	index : UDINT;
  END_VAR
  
  IF uy = 0 THEN
    udVal := 1;
    RETURN;
  END_IF;

  udVal := ux;
  
  FOR index := 2 TO uy DO
    udVal *= ux;
  END_FOR;
  
END_FUNCTION

FUNCTION MMStation::AsciiToIPAdr
	VAR_INPUT
		pStr 	: ^CHAR;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		udVal 	: UDINT;
	END_VAR
  VAR
  	udDummy : UDINT;  // hilfsDummy
    pDummy  : ^CHAR;  // hilfsDummy
    itr     : UDINT;  // iterator für string
    len     : UDINT;  // Anzahl der Stellen zw den Punkten
    pos     : UDINT;  // welche Stelle der IP gelesen wird
    c       : CHAR;   // aktueller Char
  END_VAR
  
  // OS Funktion der Klasse _IP
  //udVal := _IP::ConvertBinToStr();

  itr := 0;
  len := 0;
  udVal := 0;
  pos := 0;
  
  WHILE (itr < udLen) DO
    c := (pStr + itr)^;
    IF (c = '.') THEN
CalcIPVal:
      pDummy := (pStr + itr - len);
      udDummy := AsciiToUdint(pDummy, len);
      udVal += (udDummy * xhy_temp(256,pos));
      pos += 1;
      len := 0;
    ELSE
      len += 1;
    END_IF;
    itr += 1;
    
    IF (itr = udLen) THEN // letze Stelle der IP hinzufügen
      GOTO CalcIPVal;
    END_IF;
    
  END_WHILE;
  
END_FUNCTION

FUNCTION GLOBAL MMStation::Connect
	VAR_INPUT
		bUserStart 	: BOOL;
	END_VAR
	VAR_OUTPUT
		bOk 	: BOOL;
	END_VAR
  VAR
  	ret          : UINT;
  END_VAR

  bOk := FALSE;

  // Falls die Verbindung vom Benutzer unterbrochen wurde
  // kann die Verbindung nur wieder vom Benutzer gestartet werden
  IF ((bUserStart = FALSE) & (m_bUserStopConn = TRUE)) THEN
    RETURN;
  END_IF;
  
  ComDefLock();

  IF ((ConnAllowed() = true) & (ParseConnStr() = true)) THEN
  
     MM_TRACE("calling LOGIN, IP %02X", m_ComDef.IpAddress, 0, 0);
     ret := LOGIN(#m_ComDef$Comdef);
     MM_TRACE("LOGIN, ret=0x%X", TO_UDINT(ret), 0, 0);
     m_uiComCnt += 1;
     
     // set AliveTime damit mitbekommen wird, wenn Verbindung unterbrochen ist
     IF (ret = 0) THEN
        LDR_SetIamAliveTime(#m_ComDef$Comdef, AliveTimeout, -1$UDINT, -1$UDINT); // default werte übernehmen
        m_uiComCnt += 1;
     END_IF;
    
     bOk := (ret = 0);
     
     IF (bOk = false) THEN
        m_opLastConnTry := ops.tAbsolute;
     END_IF;

  END_IF;
  
  IF ((bOk = true) & (m_bUserCallback = 0)) THEN
    IF (m_udSymbolServerCnt = 0) THEN
      SetState(_MMState::Online);
    ELSE
      SetState(_MMState::Online_Initializing);
    END_IF;
    m_bUserCallback := 1;
  END_IF;
  
  m_bUserStopConn := FALSE;
  
  ComDefUnlock();

  
END_FUNCTION

FUNCTION MMStation::isRemotePlcNodeValid
VAR_OUTPUT
  retVal : BOOL;
END_VAR
VAR
	 pComdef : ^COMDEF;
END_VAR

  retVal := FALSE;

  pComdef := #m_ComDef$Comdef;

  IF ((pComdef) & (pComdef^.pt_COM) & (pComdef^.pt_COM^.pNode))  THEN
    retVal := TRUE;
  END_IF;

END_FUNCTION


FUNCTION GLOBAL MMStation::CheckAndRefreshState
	VAR_OUTPUT
		bConnected 	: BOOL;
	END_VAR

  bConnected := FALSE;

  IF (m_udState$_MMState = _MMState::Offline) THEN
    RETURN;
  END_IF;
  
  ComDefLock();

  IF (isRemotePlcNodeValid() = TRUE) THEN
  
    bConnected := (LDR_isRemotePlcAlive(#m_ComDef$Comdef) > 0);
    m_uiComCnt += 1;
  
    IF (bConnected = FALSE) THEN
      // refresh liste beenden
      StartStopRefresh(#m_ComDef$Comdef, 0, 0);
      // reset AliveTime, kann nur True sein wenn auch Verbindung besteht
      LDR_SetIamAliveTime(#m_ComDef$Comdef, 0, 0, 0);
      // Verbindung beenden
      MM_TRACE("CheckAndRefreshState: calling LOGOUT, IP %08X", m_ComDef.IpAddress, 0, 0);
      LOGOUT(#m_ComDef$Comdef);
      MM_TRACE("LOGOUT, ret", 0, 0, 0);
    END_IF;
      
  END_IF;
  
  IF (bConnected = FALSE) THEN
    SetState(_MMState::Offline);
  END_IF;
  
  ComDefUnlock();

END_FUNCTION

FUNCTION GLOBAL MMStation::Disconnect
	VAR_INPUT
		bUserStop 	: BOOL;
	END_VAR
	VAR_OUTPUT
		bOk 	: BOOL;
	END_VAR
  
  // besteht eine Verbindung?
  bOk := TRUE;
  
  ComDefLock();

  IF (m_udState$_MMState <> _MMState::Offline) THEN
  
    // reset AliveTime, kann nur True sein wenn auch Verbindung besteht
    IF (isRemotePlcNodeValid() = true) THEN
      LDR_SetIamAliveTime(#m_ComDef$Comdef, 0, 0, 0);
      m_uiComCnt += 1;
    END_IF;
    // Verbindung beenden
    MM_TRACE("Disconnect: calling LOGOUT, IP %08X", m_ComDef.IpAddress, 0, 0);
    bOk := (LOGOUT(#m_ComDef$Comdef) = 0);
    MM_TRACE("LOGOUT, ret", 0, 0, 0);

  END_IF;
  
  IF ((bOk = true) & (m_udState$_MMState <> _MMState::Offline)) THEN
    SetState(_MMState::Offline);
  END_IF;
  
  m_bUserStopConn := bUserStop;
  
  ComDefUnlock();


END_FUNCTION

FUNCTION GLOBAL MMStation::GetComDef
	VAR_OUTPUT
		pComDef 	: ^Comdef;
	END_VAR
 
  pComDef := #m_ComDef$Comdef;

END_FUNCTION

FUNCTION GLOBAL MMStation::ComDefLock

  OS_MT_WAIT(m_ComdefMutex); 
 
END_FUNCTION

FUNCTION GLOBAL MMStation::ComDefUnlock

  OS_MT_SIGNAL(m_ComdefMutex); 
 
END_FUNCTION

FUNCTION GLOBAL MMStation::SetCrc
	VAR_INPUT
		udCrc 	: UDINT;
	END_VAR

  m_udCrc := udCrc;

END_FUNCTION

FUNCTION GLOBAL MMStation::GetCrc
	VAR_OUTPUT
		udCrc 	: UDINT;
	END_VAR

  udCrc := m_udCrc;

END_FUNCTION

FUNCTION GLOBAL MMStation::GetFileName
	VAR_INPUT
		pFileName 	: ^CHAR;
	END_VAR
  VAR
  	udLen : UDINT;
  END_VAR

  // datei name erstellen
   _memcpy(pFileName, MM_FILE_PATH, 11);
   
    udLen := _strlen(#m_szName[0]);
    
   _strcpy(pFileName+11, #m_szName[0]);
   
   _memcpy(pFileName+11+udLen, MM_FILE_EXT, 4);
   
   (pFileName+11+udLen+4)^ := 0;

END_FUNCTION

FUNCTION GLOBAL MMStation::GetSvrCount
	VAR_OUTPUT
		udCnt 	: UDINT;
	END_VAR

  udCnt := m_udSymbolServerCnt;

END_FUNCTION

FUNCTION GLOBAL MMStation::GetSvrStartIdx
	VAR_OUTPUT
		udIdx 	: UDINT;
	END_VAR
  
 udIdx := m_udServerStartIdx;

END_FUNCTION

FUNCTION GLOBAL MMStation::GetConnStr
	VAR_INPUT
		pszConnStr 	: ^CHAR;
	END_VAR
  
  _strncpy(pszConnStr, #m_acConnStr[0], m_bConnStrLen);
  (pszConnStr+m_bConnStrLen+1)^ := 0;

END_FUNCTION

FUNCTION GLOBAL MMStation::Initialize

  m_ComdefMutex := OS_MT_CREATESEMAPHORE(MTSEMATYPE_MUTEX, 
                                         1,    // initvalue
                                         0,    // flags: 0 means create unconitionally
                                         "LDRMM_ComdefMutex" 
                                         );
  
END_FUNCTION

FUNCTION GLOBAL MMStation::CheckFileName
	VAR_INPUT
		pszFileName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		nRes 	: DINT;
	END_VAR
  VAR
    szFileName     : ARRAY [0..255] OF CHAR;
    lexem1         : CLocLex;
    lexem2         : CLocLex;  
  END_VAR

  nRes := -1;
  
  GetFileName(#szFileName[0]);
  
  lexem1.InitText(pszFileName);
  lexem2.InitText(#szFileName[0]);
  
  IF (lexem1.udCRC = lexem2.udCRC) THEN
     IF (_strcmp(pszFileName, #szFileName[0]) = 0) THEN
      nRes := 0;
    END_IF;
  END_IF;

END_FUNCTION


FUNCTION GLOBAL MMStation::DecreaseSvrInitCnt

  IF (m_udSymbolServerInitCnt > 0) THEN
    m_udSymbolServerInitCnt -= 1;
  END_IF;

  IF (m_udSymbolServerInitCnt = 0) THEN
    IF (m_udSymbolServerFoundCnt = m_udSymbolServerCnt) THEN // alle gefunden
      SetState(_MMState::Online);
    ELSE
      SetState(_MMState::Online_NotAllServerAvailable);
    END_IF;
  END_IF;

END_FUNCTION


FUNCTION GLOBAL MMStation::SetServerCnt
	VAR_INPUT
		udCnt 	: UDINT;
	END_VAR
  
  m_udSymbolServerCnt := udCnt;

END_FUNCTION

FUNCTION GLOBAL MMStation::SetServerFoundCnt
	VAR_INPUT
		udCnt 	: UDINT;
	END_VAR
  
  m_udSymbolServerInitCnt := udCnt;
  m_udSymbolServerFoundCnt := udCnt;
  
  IF (udCnt = 0) THEN
    DecreaseSvrInitCnt();
  END_IF;


END_FUNCTION


FUNCTION MMStation::ConnAllowed
	VAR_OUTPUT
		bOk 	: BOOL;
	END_VAR

  bOk  := FALSE;

  IF (m_opLastConnTry = 0) THEN // first connection try
    bOk := TRUE;
  END_IF;

  IF ((m_udState$_MMState = _MMState::Offline) & ((ops.tAbsolute - m_opLastConnTry) > ConnectTimeout)) THEN
    bOk := TRUE;
  END_IF;
  
END_FUNCTION


FUNCTION GLOBAL MMStation::IsReady
	VAR_OUTPUT
		bReady 	: BOOL;
	END_VAR

  bReady := ((m_udState$_MMState = _MMState::Online) | (m_udState$_MMState = _MMState::Online_NotAllServerAvailable));
  
END_FUNCTION


FUNCTION MMStation::SetState
	VAR_INPUT
		udState 	: UDINT;
  END_VAR
  VAR
  	oldState : UDINT;
  END_VAR

  oldState := m_udState;
  m_udState := udState;
  IF(m_udState$_MMState = _MMState::Offline)THEN
    m_bUserCallback := 0;
    m_udSymbolServerInitCnt := m_udSymbolServerFoundCnt;
    m_opLastConnTry := OPS.tAbsolute;
  END_IF;
  
  // Bei einer Änderung von m_udState muss das m_allReqInitialised Flag aktualisiert werden
  IF oldState <> m_udState THEN
    MM_TRACE("state %d -> %d, IP 08%X", oldState, m_udState, m_ComDef.IpAddress); 
    UpdateAllReqInitialised();
  END_IF;  
  
  InvokeCallback();

END_FUNCTION


FUNCTION GLOBAL MMStation::InvokeCallback
  
  MM_InvokeUserCallback(m_bID, 0, m_udState);

END_FUNCTION


FUNCTION GLOBAL MMStation::IsConnected
	VAR_OUTPUT
		bConnected 	: BOOL;
	END_VAR
  
  bConnected := (m_udState$_MMState <> _MMState::Offline);

END_FUNCTION

(*
  Ermittelt, ob alle Required Server dieser Station initialisiert sind.
  Das Ergebnis wird in m_allReqInitialised gespeichert.
*)
FUNCTION MMStation::UpdateAllReqInitialised
  VAR
		allReqInitialised 	: DINT;
  	i             : UDINT; // schleifenzähler
    cntServer       : UDINT; // Anzahl der Server
    pServer 	      : ^MMServer; // Zeiger auf Server
    pIterSvr        : ^void;
  END_VAR

  allReqInitialised := 1;//TRUE
  cntServer := GetSvrCount();
  IF ((cntServer > 0) & (cntServer < -1$UDINT) & (m_pMMServer <> NIL)) THEN
    cntServer -= 1;
    pIterSvr := m_pMMServer + (GetSvrStartIdx() * sizeof(UDINT));
    FOR i:=0 TO cntServer BY 1 DO
      pServer := pIterSvr^$^MMServer;
      IF (pServer <> NIL) & pServer^.IsRequired() THEN
        IF !!pServer^.IsInitializedFlagSet() | 
           m_udState$_MMState = _MMState::Offline | 
           m_udState$_MMState = _MMState::Online_Initializing THEN
          allReqInitialised := 9999;//FALSE
          EXIT;
        END_IF;
      END_IF;
      pIterSvr += sizeof(UDINT);
    END_FOR;
  END_IF;
  
  m_allReqInitialised := allReqInitialised;

END_FUNCTION

FUNCTION GLOBAL MMStation::GetAllReqInitialised
	VAR_OUTPUT
		allReqInitialised 	: BOOL;
	END_VAR

  IF m_allReqInitialised = 0(*not initialized*) THEN
    UpdateAllReqInitialised();
  END_IF;
  IF m_allReqInitialised = 1(*TRUE*) THEN
    allReqInitialised := TRUE;
  ELSE
    allReqInitialised := FALSE;
  END_IF;

END_FUNCTION

