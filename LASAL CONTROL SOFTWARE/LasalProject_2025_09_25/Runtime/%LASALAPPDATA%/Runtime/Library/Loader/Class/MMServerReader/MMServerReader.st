//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "MMServerReader"
	Revision           = "0.0"
	GUID               = "{B81B1224-A116-4F38-B718-89DF9E998BAD}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(810,120)"
	Comment            = "Parst die Tabelle mit den Informationen zu den MMServern">
	<Channels>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FimLuc"/>
		<Dokumentation Revision="0.0" Date="2015-10-07" Author="FimLuc" Company="Sigmatek" Description="erstellt"/>
	</RevDoku>
	<Network Name="MMServerReader">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{8C4E6344-ED8A-4249-A851-37CC56CBF70B}"
				Class      = "ProjectReader"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Server0"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using ProjectReader

MMServerReader : CLASS
: ProjectReader
  //Servers:
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION CheckReqCls
		VAR_INPUT
			bString 	: BOOL;
			bMerkerEx 	: BOOL;
		END_VAR
		VAR_OUTPUT
			bOk 	: BOOL;
		END_VAR;
	
	FUNCTION CreateObj
		VAR_INPUT
			pName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			pSvr 	: ^MMServer;
		END_VAR;
	
	FUNCTION CreateObjMerkerEx
		VAR_INPUT
			pName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			pSvr 	: ^MMServer;
		END_VAR;
	
	FUNCTION CreateObjString
		VAR_INPUT
			pName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			pSvr 	: ^MMServer;
		END_VAR;
	
	FUNCTION SkipStation
		VAR_INPUT
			pTable 	: ^void;
		END_VAR
		VAR_OUTPUT
			pTab 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL ReadConfigMultimaster
		VAR_INPUT
			pStationReader 	: ^MMStationReader;
		END_VAR
		VAR_OUTPUT
			pMMServer 	: ^void;
		END_VAR;
	
	FUNCTION Create4ByteObj
		VAR_INPUT
			pName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			pSvr 	: ^MMServer;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MMServerReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MMSERVERREADER
0$UINT, 0$UINT, (SIZEOF(::MMServerReader))$UINT, 
0$UINT, 0$UINT, 0$UINT, 
TO_UDINT(3577251694), "MMServerReader", //Class
TO_UDINT(1931374299), "ProjectReader", 0$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
END_FUNCTION


#define USER_CNT_MMServerReader 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MMServerReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MMServerReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code	:= ProjectReader::@STD();

END_FUNCTION

#pragma usingLtd MMServer
#pragma usingLtd MMStationReader

//{{LSL_IMPLEMENTATION
#include <RTOS_Mem.h>

#pragma using MMStation
#pragma using ClassReader
#pragma using MMServerString
#pragma using MMServerMerkerEx
#pragma using MerkerEx
#pragma using MMBuffer
#pragma using MMServerImpl


#define StringHI 1
#define StringLOW 80

#define MerkerExHI 1
#define MerkerExLOW 20 

#define MMMerkerExHI  0
#define MMMerkerExLOW 0

VAR_PRIVATE
  
  bStringChecked,
  bStringOk,
  bMerkerChecked,
  bMerkerOk         : BOOL;

END_VAR

FUNCTION GLOBAL _LookupCls
VAR_INPUT
	pName		: ^char;
END_VAR
VAR_OUTPUT
	pCls		: ^ClsHdr;
END_VAR;

FUNCTION GLOBAL MMServerReader::ReadConfigMultimaster
	VAR_INPUT
		pStationReader 	: ^MMStationReader;
	END_VAR
	VAR_OUTPUT
		pMMServer 	: ^void;
	END_VAR
  VAR
  	nStationEntries : UINT;  	
    nSymbolEntries  : UINT;
    iStationItr     : UINT;
    iSymbolItr      : UINT;
    nVersion        : UINT;
    cBuf            : ARRAY[ 0..255 ] OF CHAR;
    nCount          : UDINT;
    pTab            : ^void;
		pSvr 	          : ^MMServer;
    pStation        : ^MMStation;
    udRead          : UDINT;
    udLen           : UDINT;
    udLen1          : UDINT;
		pObjPtr         : ^void;
    udCrc           : UDINT;
    
    cSvrName        : ARRAY[ 0..255 ] OF CHAR;
 		SvrFlags 	      : UDINT;
 		SvrType 	      : BYTE;
    SvrPrio         : UINT;
    udEndForStation : UDINT;
    udEndForServer  : UDINT;
  END_VAR

  bStringChecked := FALSE;
  bStringOk := FALSE; 
  bMerkerChecked := FALSE;  
  bMerkerOk := FALSE;        

  pMMServer := NIL;
  udRead := 0;

  pTab := _FindFctName(MM_TableName);
  IF pTab = NIL THEN
    // keine Tabelle vorhanden, kann bei älteren Lasal Versionen der Fall sein
    RETURN;
  END_IF;
  
 (* 
  Aufbau der Tabelle 
    4   Tabellengröße
    2   Versionsnummer
    2   Anzahl der Stationen
    n-mal:
     2   Stations ID
     0-terminierter String: Stationsname 
     2   Anzahl der Symbole(Server)
        n-mal:
          0-terminierter String: Objektname.Server 
          1 Byte: Prio (0...FF)
          1 Byte: ServerType (4-Byte, N-Byte; String, Bit)
          4 Byte: div Flags (writeprotected, required, newInst, usw)
  *)
  
  nCount	:= pTab$^UDINT^; // Tabellengröße

	IF (nCount = 0) THEN
		RETURN;
	END_IF;

  pTab += sizeof(UDINT);  // Tabellengröße

  nVersion := pTab$^UINT^;
  
  IF (nVersion <> 0) THEN
		RETURN; 
  END_IF;

	pTab += sizeof(UINT);  // Versionsnummer
  
  nStationEntries := pTab$^UINT^;

  IF (nStationEntries = 0) THEN
    // es gibt keine Stationen also auch keine SymbolServer
    RETURN;
  END_IF;
  
  pTab += sizeof(UINT);  // Station Count
  
  IF (CheckReqCls(FALSE, FALSE) = FALSE) THEN
    TRACE_ERR("Multimaster: not all required Classes available.");
    RETURN;
  END_IF;
  
  udEndForStation := nStationEntries - 1;

  FOR iStationItr := 0 TO udEndForStation  BY 1 DO
  
    // buffer reseten
    cBuf[0] := 0;
    
    // stationsnamen
   udLen := _strlen(pTab $ ^char);
   _memcpy(#cBuf[0], pTab $ ^char, udLen+1); // Null mitkopieren
   pTab += udLen+1; // Name überspringen
     
   pStation := pStationReader^.GetStation(#cBuf[0]);
   
   IF (pStation <> NIL) THEN

     nSymbolEntries := pTab$^UINT^;
     pTab += sizeof(UINT); // Anzahl der Symbols pro Station
     
     IF (nSymbolEntries > 0) THEN
     
        pStation^.SetServerCnt(nSymbolEntries);        
        pStation^.m_udServerStartIdx := udRead;
        
        IF (udRead = 0) THEN
          pMMServer := _alloc_resize_LDR(nSymbolEntries * sizeof(UDINT));
          pObjPtr := pMMServer;
        ELSE
          pMMServer := _realloc_LDR(pMMServer, (udRead + nSymbolEntries) * sizeof(UDINT));
          pObjPtr := (pMMServer + (udRead * sizeof(UDINT)));
        END_IF;
        
        
        IF (pMMServer = NIL) THEN
          TRACE2_ERR("Out of Memory. Reading table {0}: Creating object of Server '{1}' at Station '{2}' failed!", MM_TableName, #cSvrName[0], #pStation^.m_szName[0]);
          RETURN;
        END_IF;
      
        udRead += nSymbolEntries;
        
        udEndForServer := nSymbolEntries - 1;
        FOR iSymbolItr := 0 TO udEndForServer  BY 1 DO
          
          // buffer reseten
          cBuf[0] := 0;
           
          // Read table 
          
          // Crc einlesen
          udCrc := pTab$^UDINT^;
          pTab += sizeof(UDINT); // Station ID

          // Obj namen erstellen
          // StationId.Obj.Server
          _strcpy(#cBuf[0], #pStation^.m_szName[0]);
          udLen1 := _strlen(#cBuf[0]);
          
          cBuf[udLen1] := '.';
          
          udLen := _strlen(pTab $ ^char);
           _memcpy(#cBuf[udLen1+1], pTab $ ^char, udLen+1); // Null mitkopieren

          cSvrName[0] := 0;
           _memcpy(#cSvrName[0], pTab $ ^char, udLen+1); // Null mitkopieren

          pTab	+= udLen + 1;	// Klassenname + Abschluß-Nuller überlesen
            
          SvrType := pTab$^USINT^;
          pTab += sizeof(USINT); // ServerType
          
          IF (SvrType = _MM_CHTY_BIN) THEN
            SvrType := _MM_CHTY_4BYTE; // kein unterschied im loader
          END_IF;
            
          SvrPrio := pTab$^UINT^;
          pTab += sizeof(UINT); // Prio
            
          SvrFlags := pTab$^UDINT^;
          pTab += sizeof(UDINT); // Flags
            
          // objekt erstellen
          IF (SvrType = _MM_CHTY_STRING) THEN
            pSvr := CreateObjString(#cBuf[0]);
          ELSIF (SvrType = _MM_CHTY_MERKER) THEN
            pSvr := CreateObjMerkerEx(#cBuf[0]);
            pStation^.m_bCheckLdrVersion := TRUE;
          ELSE
            pSvr := Create4ByteObj(#cBuf[0]);
          END_IF;

          IF (pSvr <> NIL) THEN
          
            pObjPtr^$UDINT := pSvr$UDINT;
            
             // server daten einlesen
            pSvr^.m_pStation := pStation;
          
            _strcpy(#pSvr^.m_szServerName[0], #cSvrName[0]);
            pSvr^.m_bServerNameLen := _strlen(#pSvr^.m_szServerName[0]);
            
            pSvr^.m_flServerType := SvrType;
            
            pSvr^.m_uiPriority := SvrPrio;
            
            pSvr^.m_flFlags := SvrFlags;
            
            pSvr^.m_udCrc32 := udCrc;
          
            pObjPtr += sizeof(UDINT);
            
          ELSE
          
            TRACE2_ERR("Reading table {0}: Creating object of Server '{1}' at Station '{2}' failed!", MM_TableName, #cSvrName[0], #pStation^.m_szName[0]);
            pObjPtr^$UDINT := NIL;
            pObjPtr += sizeof(UDINT);
            
          END_IF;

        END_FOR;
        
     END_IF;
   ELSE
     TRACE1_ERR("Reading table {0}: Station '{1}' not configured in Station.txt!", MM_TableName, #cBuf[0]);
     pTab := SkipStation(pTab);
   END_IF;
  END_FOR;
    
END_FUNCTION

FUNCTION MMServerReader::CheckReqCls
	VAR_INPUT
		bString 	: BOOL;
		bMerkerEx 	: BOOL;
	END_VAR
	VAR_OUTPUT
		bOk 	: BOOL;
	END_VAR
  VAR
    pReqCls : ^ClsHdr;
    bDummy,
    bDummy1,
    bErr    : BOOL;
  END_VAR
  
  bOk := FALSE;
  bDummy := FALSE;
  bDummy1 := FALSE;
  bErr := FALSE;

  IF  (bString = TRUE) THEN
  
    pReqCls := _LookupCls( "MerkerEx" );
    IF( pReqCls = NIL ) THEN
      IF( ClassReader::NewCls( "MerkerEx" ) = NIL ) THEN
        TRACE_ERR("To use Multimaster String Server Class MerkerEx (>= 1.20) has to be included in the project.");
        bErr := TRUE;
      ELSE
        pReqCls := _LookupCls( "MerkerEx" );
      END_IF;
    END_IF;
    IF( pReqCls = NIL ) THEN
      IF (bErr = FALSE) THEN
        TRACE_ERR("To use Multimaster String Server Class MerkerEx (>= 1.20) has to be included in the project.");
      END_IF;
    ELSIF ((pReqCls^.pDsc^.udRev.Hi < MerkerExHI) & (pReqCls^.pDsc^.udRev.Lo < MerkerExLOW)) THEN
      TRACE_ERR("Update MerkerEx (>= 1.20).");
    ELSE 
      bDummy := TRUE; 
    END_IF;
  
    bErr := FALSE;
    pReqCls := _LookupCls( "StringInternal" );
    IF( pReqCls = NIL ) THEN
      IF( ClassReader::NewCls( "StringInternal" ) = NIL ) THEN
        TRACE_ERR("To use Multimaster String Server StringInternal (>= 1.80) has to be included in the project.");
        bErr := TRUE;
      ELSE
        pReqCls := _LookupCls( "StringInternal" );
      END_IF;
    END_IF;
    IF( pReqCls = NIL ) THEN
      IF (bErr = FALSE) THEN
        TRACE_ERR("To use Multimaster String Server StringInternal (>= 1.80) has to be included in the project.");
      END_IF;
    ELSIF ((pReqCls^.pDsc^.udRev.Hi < StringHI) & (pReqCls^.pDsc^.udRev.Lo < StringLOW)) THEN
      TRACE_ERR("Update StringInternal (>= 1.80).");
    ELSE 
      bDummy1 := TRUE; 
    END_IF;
   
    pReqCls := _LookupCls( "MMServerString" );
    IF( pReqCls = NIL ) THEN
      IF( ClassReader::NewCls( "MMServerString" ) = NIL ) THEN
        TRACE_ERR("To use Multimaster String Server Class MMServerString has to be included in the project.");
        RETURN;
      END_IF;
      pReqCls := _LookupCls( "MMServerString" );
    END_IF;
    IF( pReqCls = NIL ) THEN
      TRACE("To use Multimaster String Server Class MMServerString has to be included in the project.");
      RETURN;
    END_IF;
    
    IF((bDummy = FALSE) | (bDummy1 = FALSE)) THEN
      RETURN;
    END_IF;
    
  ELSIF (bMerkerEx = TRUE) THEN
  
    pReqCls := _LookupCls( "MerkerEx" );
    IF( pReqCls = NIL ) THEN
      IF( ClassReader::NewCls( "MerkerEx" ) = NIL ) THEN
        TRACE_ERR("To use Multimaster String Server Class MerkerEx (>= 1.20) has to be included in the project.");
        bErr := TRUE;
      ELSE
        pReqCls := _LookupCls( "MerkerEx" );
      END_IF;
    END_IF;
    IF( pReqCls = NIL ) THEN
      IF (bErr = FALSE) THEN
        TRACE_ERR("To use Multimaster String Server Class MerkerEx (>= 1.20) has to be included in the project.");
      END_IF;
    ELSIF ((pReqCls^.pDsc^.udRev.Hi < MerkerExHI) & (pReqCls^.pDsc^.udRev.Lo < MerkerExLOW)) THEN
      TRACE_ERR("Update MerkerEx (>= 1.20).");
    ELSE 
      bDummy := TRUE; 
    END_IF;
  
    pReqCls := _LookupCls( "MMServerMerkerEx" );
    IF( pReqCls = NIL ) THEN
      IF( ClassReader::NewCls( "MMServerMerkerEx" ) = NIL ) THEN
        TRACE_ERR("To use Multimaster MerkerEx Server Class MMServerMerkerEx has to be included in the project.");
        RETURN;
      END_IF;
      pReqCls := _LookupCls( "MMServerMerkerEx" );
    END_IF;
    IF( pReqCls = NIL ) THEN
      TRACE_ERR("To use Multimaster MerkerEx Server Class MMServerMerkerEx has to be included in the project.");
      RETURN;
    ELSIF ((pReqCls^.pDsc^.udRev.Hi < MMMerkerExHI) & (pReqCls^.pDsc^.udRev.Lo < MMMerkerExLOW)) THEN
      TRACE_ERR("Only Revision 0.0 of MMServerMerkerEx supported.");
      RETURN;
    END_IF;
    
    IF (bDummy = FALSE) THEN
      RETURN;
    END_IF;

  ELSE
        
    pReqCls := _LookupCls( "MMBuffer" );
    IF( pReqCls = NIL ) THEN
      IF( ClassReader::NewCls( "MMBuffer" ) = NIL ) THEN
        RETURN;
      END_IF;
      pReqCls := _LookupCls( "MMBuffer" );
      IF( pReqCls = NIL ) THEN
        RETURN     ;
      END_IF;
    END_IF;
     
    pReqCls := _LookupCls( "MMServerImpl" );
    IF( pReqCls = NIL ) THEN
      IF( ClassReader::NewCls( "MMServerImpl" ) = NIL ) THEN
        RETURN;
      END_IF;
      pReqCls := _LookupCls( "MMServerImpl" );
      IF( pReqCls = NIL ) THEN
        RETURN     ;
      END_IF;
    END_IF;  
    
    pReqCls := _LookupCls( "MMServer4ByteImpl" );
    IF( pReqCls = NIL ) THEN
      IF( ClassReader::NewCls( "MMServer4ByteImpl" ) = NIL ) THEN
        RETURN;
      END_IF;
      pReqCls := _LookupCls( "MMServer4ByteImpl" );
      IF( pReqCls = NIL ) THEN
        RETURN     ;
      END_IF;
    END_IF; 
    
    pReqCls := _LookupCls( "MMServer" );
    IF( pReqCls = NIL ) THEN
      IF( ClassReader::NewCls( "MMServer" ) = NIL ) THEN
        RETURN;
      END_IF;
      pReqCls := _LookupCls( "MMServer" );
      IF( pReqCls = NIL ) THEN
        RETURN     ;
      END_IF;
    END_IF;
  
  END_IF;

  bOk := TRUE;

END_FUNCTION

FUNCTION MMServerReader::CreateObj
	VAR_INPUT
		pName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		pSvr 	: ^mmServer;
	END_VAR
  VAR
    szName	: ARRAY [0..NLNG] OF CHAR;
  	pData		: ^MMBuffer;
	  pObj	  : ^Obj;
    pSvrImpl : ^MMServer; 
  END_VAR

  pSvr := NIL;

  pSvrImpl := ObjectReader::NewObj("MMServerImpl", pName)$^MMServer;
  
  IF(pSvrImpl = NIL)THEN
    RETURN;
  END_IF;
  
  IF ((pName = NIL) | (pName^ = 0)) THEN
    pObj	:= LSL_GetHdr(pSvrImpl);
    _strcpy(pName, #pObj^.pObjDsc^.SymName.Text[0]);
  END_IF;
  
  szName[0] := 0;

  // Embedded Client anlegen. Das muß im Gegensatz zu Lasal1 manuell gemacht 
  // werden, weil kein ON existiert.
  _strcpy(#szName[0], pName);
  _strcat(#szName[0], "\MMBufferIn");
  pData := ObjectReader::NewObj("MMBuffer", #szName[0]) $ ^MMBuffer;
  IF pData = NIL THEN
    RETURN;
  END_IF;
  
  pSvrImpl^.DataBuffer.pCh := pData $ ^SvrChCmd_UDINT;
  pSvrImpl^.DataBuffer.pCmd := pData;

  _strcpy(#szName[0], pName);
  _strcat(#szName[0], "\MMBufferOut");
  pData := ObjectReader::NewObj("MMBuffer", #szName[0]) $ ^MMBuffer;
  IF pData = NIL THEN
    RETURN;
  END_IF;
  
  pSvrImpl^.DataBufferOut.pCh := pData $ ^SvrChCmd_UDINT;
  pSvrImpl^.DataBufferOut.pCmd := pData;

  pSvr := pSvrImpl$^mmServer;
  
END_FUNCTION

FUNCTION MMServerReader::CreateObjString
	VAR_INPUT
		pName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		pSvr 	: ^mmServer;
	END_VAR
  VAR
    szName	      : ARRAY [0..NLNG] OF CHAR;
    pSvrString    : ^MMServerString;
    pMerker       : ^MerkerEx;
  END_VAR

  pSvr := NIL;
  
  IF (bStringChecked = FALSE) THEN
    bStringOk := CheckReqCls(TRUE, FALSE);
  END_IF;

  IF (bStringOk = FALSE) THEN
    RETURN;
  END_IF;

  // Obj Anlegen
  pSvrString := ObjectReader::NewObj("MMServerString", pName)$^MMServerString;
  
  IF (pSvrString = NIL) THEN
    RETURN;
  END_IF;
  
  // MMServer anlegen
  szName[0] := 0;
  pSvr := CreateObj(#szName[0]);
  IF pSvr = NIL THEN
    pSvr := NIL;
    RETURN;
  END_IF;

  // dummy buffer für Stringinternal anlegen, sonst fehler ..
  pMerker := NewObj("MerkerEx") $ ^MerkerEx;
  IF pMerker = NIL THEN
    pSvr := NIL;
    RETURN;
  END_IF;
  pMerker^.ThreadSafe := 1;


  pSvrString^.MMServer.pCh := pSvr $ ^SvrChCmd_UDINT;
  pSvrString^.MMServer.pCmd := pSvr;
  
  pSvrString^.DataBuffer.pCh := pMerker $ ^SvrChCmd_UDINT;
  pSvrString^.DataBuffer.pCmd := pMerker;
  
  pSvrString^.SingleRealloc := 1;

END_FUNCTION

FUNCTION MMServerReader::CreateObjMerkerEx
	VAR_INPUT
		pName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		pSvr 	: ^mmServer;
	END_VAR
  VAR
    szName	: ARRAY [0..NLNG] OF CHAR;
    pSvrEx  : ^MMServerMerkerEx;
    pObj    : ^OBJ;
    pCls    : ^ClsHdr;
    ppCD    : ^ChDsc;
  	uiChno	: UINT;
    lexem   : CLocLex;
    pMMServer : ^CltChCmd_MMServerBase;
  END_VAR

  pSvr := NIL;
  
  IF (bMerkerChecked = FALSE) THEN
    bMerkerOk := CheckReqCls(FALSE, TRUE);
  END_IF;

  IF (bMerkerOk = FALSE) THEN
    RETURN;
  END_IF;

  // MerkerEx MM Server
  pSvrEx := ObjectReader::NewObj("MMServerMerkerEx", pName)$^MMServerMerkerEx;
  IF (pSvrEx = NIL) THEN
    RETURN;
  END_IF;
  
  // MMServer anlegen
  szName[0] := 0;
  pSvr := CreateObj(#szName[0]);
  IF pSvr = NIL THEN
    pSvr := NIL;
    RETURN;
  END_IF;

  (* DEVOS-568
  Achtung: Auf die Elemente des MMServers darf man nicht über pSvrEx^.MMServer.<Elementname> 
  zugreifen, sondern man muss sich den Zeiger auf den MMServer auf der RTDB holen. 
  Damit wird der Offset des Servers zur Laufzeit und nicht zur Compilezeit ermittelt. 
  Zur Compilezeit ist schlecht, weil im Projekt möglicherweise eine neuere Version 
  der Klasse MMServerMerkerEx bzw. der Basisklasse MerkerEx verwendet wird und das 
  Layout der Elemente dieser Klasse dann anders ausschaut.
  *)
  pObj := LSL_GetHdr(pSvrEx);
  pCls := pObj^.pClsHdr;
#ifndef DUMMY_LOADER
  lexem.InitText("MMServer");
#endif  
  uiChNo := _LookUpChannel((#lexem) $ ^CLexem, #pCls);
  ppCD := #pCls^.aDscChs[uiChno];
  pMMServer := pSvrEx + ppCD^.pDsc^.uiOff;
  pMMServer^.pCh := pSvr $ ^SvrChCmd_UDINT;
  pMMServer^.pCmd := pSvr;
  // so darf man es nicht machen (siehe Kommentar oben):
  //pSvrEx^.MMServer.pCh := pSvr $ ^SvrChCmd_UDINT;
  //pSvrEx^.MMServer.pCmd := pSvr;
  
END_FUNCTION

FUNCTION MMServerReader::SkipStation
	VAR_INPUT
		pTable 	: ^void;
	END_VAR
	VAR_OUTPUT
		pTab 	: ^void;
	END_VAR
  VAR
  	 udLen           : UDINT;
     nSymbolEntries  : UINT;     
     iSymbolItr      : UINT;    
     nEndFor         : UINT;
  END_VAR

   pTab := pTable;
   nSymbolEntries := pTab$^UINT^;
   pTab += sizeof(UINT); // Anzahl der Symbols pro Station
   
   IF (nSymbolEntries > 0) THEN
      nEndFor := nSymbolEntries - 1;
      FOR iSymbolItr := 0 TO nEndFor  BY 1 DO
        
        pTab += sizeof(UDINT); // CRC ID
        udLen := _strlen(pTab $ ^char);
        pTab	+= udLen + 1;	// Servername + Abschluß-Nuller überlesen
        pTab += sizeof(USINT); // ServerType
        pTab += sizeof(USINT); // Prio
        pTab += sizeof(UDINT); // Flags
      
      END_FOR;
   END_IF;

END_FUNCTION


FUNCTION MMServerReader::Create4ByteObj
	VAR_INPUT
		pName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		pSvr 	: ^mmServer;
	END_VAR
  VAR
    szName	: ARRAY [0..NLNG] OF CHAR;
	  pObj	  : ^Obj;
  END_VAR

  pSvr := ObjectReader::NewObj("MMServer4ByteImpl", pName)$^MMServer;
  
  IF(pSvr = NIL)THEN
    RETURN;
  END_IF;
  
  IF ((pName = NIL) | (pName^ = 0)) THEN
    pObj	:= LSL_GetHdr(pSvr);
    _strcpy(pName, #pObj^.pObjDsc^.SymName.Text[0]);
  END_IF;
  
  szName[0] := 0;
  
END_FUNCTION
