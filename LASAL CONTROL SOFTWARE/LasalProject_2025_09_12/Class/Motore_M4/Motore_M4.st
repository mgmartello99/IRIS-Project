//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Motore_M4"
	Revision           = "0.0"
	GUID               = "{24D2C062-D0CA-41A9-9CCF-E1DF3648211A}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "100 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(720,180)">
	<Channels>
		<Server Name="ClassSvr" GUID="{FBC4DFCA-3D9A-44A9-A59B-FF7095952BE6}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ErrorState" GUID="{E445B5C3-D437-41CA-ADEB-B0E7157ADEB2}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="M4_Correction_Step" GUID="{37921A34-9705-458A-8AAD-52D7742D15CA}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="MotoreM4Step" GUID="{2EA93C34-3873-480B-AC3E-3D29B3B28D0E}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="s_1_3_pelletMode" GUID="{A93B40DD-7E5F-4767-959A-25257E01E0E3}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_calibrationMode" GUID="{F9C6BB11-1CFF-4920-923D-462F90074FA6}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_DischargeStatus" GUID="{659D00F7-B130-4B38-B397-11A25DBCA80F}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_M4_Homed" GUID="{82C15C90-199B-4B98-BBFE-8B948D8E6D8E}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_measurement_ON" GUID="{501D6280-024E-4288-8726-0B70E1090B41}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="s_pelletInTrolley" GUID="{F68D7466-3A0A-4C32-894D-E365A793DE10}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_pelletMeasured" GUID="{2030E847-33CE-4F18-AE5B-F3FA99177D4B}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_target_misurati" GUID="{E3FA101B-9B62-4F3D-A449-FE1DE6C24C5C}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="c_MaxCurrent" Required="true" Internal="false"/>
		<Client Name="c_TimerDis" Required="false" Internal="false"/>
		<Client Name="c_TimerMov" Required="true" Internal="false"/>
		<Client Name="Comando_M4" Required="true" Internal="false"/>
		<Client Name="Comando_to_M8Class" Required="true" Internal="false"/>
		<Client Name="M4_LS" Required="false" Internal="false"/>
		<Client Name="SetPositionController" Required="true" Internal="false"/>
	</Channels>
</Class>
*)
Motore_M4 : CLASS
	TYPE
	  t_sequence_Cmd_motore_M4 :  //! <Type Public="true" Name="t_sequence_Cmd_motore_M4"/>
	  (
	    Cmd_motore_M4_idle,
	    Cmd_motore_M4_homing,
	    Cmd_motore_M4_phasing,
	    Cmd_motore_M4_movement,
	    Cmd_motore_M4_reset,
	    Cmd_motore_M4_stop,
	    Cmd_motore_M4_stopped,
	    Cmd_motore_M4_Error,
	    Cmd_motore_M4_movement_2
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	MotoreM4Step 	: SvrCh_t_sequence_Cmd_motore_M4_PTofCls_Motore_M4;
	ErrorState 	: SvrCh__LMCAXIS_ERROR;
	s_measurement_ON 	: SvrCh_DINT;
	s_M4_Homed 	: SvrCh_DINT;
	M4_Correction_Step 	: SvrCh_DINT;
	s_target_misurati 	: SvrCh_DINT;
	s_calibrationMode 	: SvrCh_DINT;
	s_1_3_pelletMode 	: SvrCh_DINT;
	s_pelletMeasured 	: SvrCh_DINT;
	s_pelletInTrolley 	: SvrCh_DINT;
	s_DischargeStatus 	: SvrCh_DINT;
  //Clients:
	Comando_M4 	: CltChCmd__LMCAxis;
	Comando_to_M8Class 	: CltChCmd_Motore_M7;
	M4_LS 	: CltCh_DINT;
	c_MaxCurrent 	: CltCh_DINT;
	SetPositionController 	: CltCh_DINT;
	c_TimerDis 	: CltCh_DINT;
	c_TimerMov 	: CltCh_DINT;
  //Variables:
		ActCommand 	: t_sequence_Cmd_motore_M4;
		M4_homed 	: BOOL;
		M4_MovementStep 	: DINT;
		v_MeasurementStartOver 	: BOOL;
		v_DiscahrgeMisure_End 	: BOOL;
		v_M8_inBlockPos 	: BOOL;
		v_ErrorState 	: DINT;
		HomingStep 	: DINT;
		Movement_step 	: DINT;
		v_StartHomingCase 	: DINT;
		v_StartMovementCase 	: DINT;
		v_offset_Dis 	: DINT;
		v_target_misurati 	: DINT;
		v_M4_LS 	: DINT;
		v_ACK_M4_Mov 	: DINT;
		flag 	: DINT;
		v_startTimer 	: BOOL;
		v_pelletMeasured 	: DINT;
		v_pelletInTrolley 	: DINT;
		v_PelletAvailable 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetSequenceState
		VAR_INPUT
			Cmd_motore 	: t_sequence_Cmd_motore_M4;
			Motion_Type 	: DINT;
			StartCase 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetHomedState
		VAR_OUTPUT
			Homed 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetMisurationStartOver
		VAR_INPUT
			Status 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SetDischargeOver
		VAR_OUTPUT
			Status 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetM8Status
		VAR_INPUT
			Status 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetErrorState
		VAR_OUTPUT
			ErrorState 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetMoveDone
		VAR_OUTPUT
			OutParam 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetPelletAvailable
		VAR_INPUT
			Param 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _LMCAxis
#pragma usingLtd Motore_M7


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Motore_M4::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_MOTORE_M4
0$UINT, 0$UINT, (SIZEOF(::Motore_M4))$UINT, 
12$UINT, 7$UINT, 0$UINT, 
TO_UDINT(4251438454), "Motore_M4", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Motore_M4.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::Motore_M4.MotoreM4Step.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2470580921), "MotoreM4Step", 
(::Motore_M4.ErrorState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2975757027), "ErrorState", 
(::Motore_M4.s_measurement_ON.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4045716186), "s_measurement_ON", 
(::Motore_M4.s_M4_Homed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(539446396), "s_M4_Homed", 
(::Motore_M4.M4_Correction_Step.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4119690698), "M4_Correction_Step", 
(::Motore_M4.s_target_misurati.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(30225291), "s_target_misurati", 
(::Motore_M4.s_calibrationMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2014927943), "s_calibrationMode", 
(::Motore_M4.s_1_3_pelletMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2239501700), "s_1_3_pelletMode", 
(::Motore_M4.s_pelletMeasured.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2664205881), "s_pelletMeasured", 
(::Motore_M4.s_pelletInTrolley.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3981363852), "s_pelletInTrolley", 
(::Motore_M4.s_DischargeStatus.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2214772265), "s_DischargeStatus", 
//Clients:
(::Motore_M4.Comando_M4.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2669527164), "Comando_M4", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 114$UINT, 
(::Motore_M4.Comando_to_M8Class.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2321403570), "Comando_to_M8Class", TO_UDINT(1684970700), "Motore_M7", 0$UINT, 0$UINT, 
(::Motore_M4.M4_LS.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3494276569), "M4_LS", 
(::Motore_M4.c_MaxCurrent.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2379934917), "c_MaxCurrent", 
(::Motore_M4.SetPositionController.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(405540383), "SetPositionController", 
(::Motore_M4.c_TimerDis.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3716697944), "c_TimerDis", 
(::Motore_M4.c_TimerMov.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4100532190), "c_TimerMov", 
END_FUNCTION


#define USER_CNT_Motore_M4 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Motore_M4] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Motore_M4::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Motore_M4, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_M4_Homed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF s_M4_Homed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	M4_Correction_Step.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF M4_Correction_Step.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_target_misurati.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF s_target_misurati.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_calibrationMode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF s_calibrationMode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_1_3_pelletMode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF s_1_3_pelletMode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_pelletMeasured.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF s_pelletMeasured.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_pelletInTrolley.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF s_pelletInTrolley.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_DischargeStatus.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF s_DischargeStatus.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL Motore_M4::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR


  v_M4_LS:=M4_LS.Read();
  s_M4_Homed.Write(input:=M4_homed);
  
  s_target_misurati.Write(input:=v_target_misurati);
  
  
  case MotoreM4Step of
//===========================================================================================

    Cmd_motore_M4_idle: 
    
    if Comando_M4.AxisError.HwError then
      v_ErrorState:=1;   ;
      MotoreM4Step:=Cmd_motore_M4_Error;
    end_if;
    v_ACK_M4_Mov:=0;
//===========================================================================================

    Cmd_motore_M4_homing:
    //lo muovo fino al click dello switch, questa posizione corrisponde a quella in cui un target, se nello slider, cade nella posizione di carico
    if Comando_M4.AxisError.HwError then
      v_ErrorState:=1;   
      HomingStep:=0;
      MotoreM4Step:=Cmd_motore_M4_Error;
    end_if;
    
    
    case HomingStep of
    
    0://idle
      HomingStep:=v_StartHomingCase;
      
    5:
      if v_M4_LS then //Motore già in posizione.
        HomingStep:=50;
      else     
        HomingStep:=10;
      end_if;

      
    10://POER ON  
    
      if (Comando_M4.AxisStatus.PowerOn=0) & (Comando_M4.AxisStatus.ReadyToPowerOn) then
        Comando_M4.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
      elsif Comando_M4.AxisStatus.PowerOn then
        HomingStep:=20;
      end_if;
      
    20:
    
      Comando_M4.TuneAxis(Position:=P_M4_H, Speed:=V_M4, Accel:=A_M4, Mode:=LMCAXIS_TUNE_POSITON_IN_POSITIVE_DIRECTION, WaitTime:=0, Jerk:=J_M4);
      HomingStep:=30;
    
    30:
    if v_M4_LS=0 then //quando tocca LS
      Comando_M4.StopMove(Decel:=A_M4, Jerk:=J_M4);
      HomingStep:=40;
    end_if;
 
    
    40://Controllo che il motore si sia fermato
    
      if Comando_M4.AxisStatus.Standstill then
          Comando_M4.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
          HomingStep:=50;
      end_if;
      
    50: 
       if Comando_M4.AxisStatus.PowerOn=0 then
       SetPositionController.Write(input:=0);
          M4_homed:=TRUE;
          MotoreM4Step:=Cmd_motore_M4_idle;
          v_StartHomingCase:=0;
       end_if;
        
    end_case;

    
//==================================================================================    
     Cmd_motore_M4_movement:
    
    //
    //BLOCCO DI COMANDI PER MOVIMENTAZIONE MOTORE M4
    //
    //SI TROVA GIA' NELLA POSIZIONE IN CUI PUO' UN TARGET CADE
    
    if Comando_M4.AxisError.HwError then
      v_ErrorState:=1;   
      Movement_step:=0;
      MotoreM4Step:=Cmd_motore_M4_Error;
    end_if;
    
    
    case Movement_step of
    
    
    0: //IDLE, ATTESA COMANDI| Il motore è già nella posizione di carica->tocca il LS
        Movement_step:=v_StartMovementCase;
    10://M2 si trova nella posizione corretta di caricamento DEVE RUOTARE NEL VERSO CORRETTO PER SCARICARE TARGET, compirà 1 giro completo (quasi)
       
     if (Comando_M4.AxisStatus.PowerOn=0) & (Comando_M4.AxisStatus.ReadyToPowerOn) then
        Comando_M4.PowerOn(Mode:=LMCAXIS_MOVE_ANY_WAY);
     elsif Comando_M4.AxisStatus.PowerOn then
        Movement_step:=20;
        s_DischargeStatus.Write(input:=0);
     end_if;
     
     
    20: 
    
      if v_M8_inBlockPos then
        Movement_Step:=30;
      elsif v_M8_inBlockPos=FALSE then
        Comando_to_M8Class.SetSequenceState(Cmd_motore:=Motore_M7::Cmd_motore_M7_movement, Motion_type:=0, StartCase:=10);//dico al motore di andare in posizione di blocco
        Movement_Step:=25;
      end_if;
     
    25:
      if v_M8_inBlockPos=true then
        Movement_Step:=30;
        flag:=1;
      end_if;
      
    30:
      Comando_M4.MoveAbsolute(Position:=(P1_M4+v_offset_Dis), Speed:=V_M4, Accel:=A_M4, Decel:=A_M4, Jerk:=J_M4);
      Movement_Step:=40;
      
    40:
      IF Comando_M4.InPosition(Mode:=LMCAXIS_NO_POSITIONWINDOW, PositionWindow:=0) & Comando_M4.AxisStatus.Standstill  & v_MeasurementStartOver THEN //se ho scaricato target e dico che è pronto per la misurazione
      //FASE DI MISURAZIONE
        v_pelletMeasured+=1;
        s_pelletMeasured.Write(input:=v_pelletMeasured);
        c_TimerDis.Write(input:=1);
        c_TimerMov.Write(input:=0);
        s_measurement_ON.Write(input:=1);//MISURAZIONE ATTIVA
        s_DischargeStatus.Write(input:=1);
        v_target_misurati+=1;
        Movement_step:=50;
      END_IF;
      
    50:
      if v_MeasurementStartOver=FALSE then
        v_pelletMeasured+=1;
        s_pelletMeasured.Write(input:=v_pelletMeasured);
        c_TimerDis.Write(input:=0);
        Comando_to_M8Class.SetSequenceState(Cmd_motore:=Motore_M7::Cmd_motore_M7_movement, Motion_type:=1,StartCase:=10);//dico al motore di USCIRE dalla posizione di blocco
        v_target_misurati+=1;
        v_pelletInTrolley+=1;
        s_pelletInTrolley.Write(input:=v_pelletInTrolley);
        s_measurement_ON.Write(input:=0);
        v_offset_Dis+=1200000;
        
        if s_1_3_pelletMode.Read()=1 then
          Movement_Step:=80;
        elsif s_1_3_pelletMode.Read()=0 then
          Movement_Step:=60;
        end_if;
        
      end_if;
    
    60:
      if v_target_misurati<6 & Comando_to_M8Class.GetCoupledState()=FALSE then
        Movement_Step:=20;
      elsif v_target_misurati=6 & Comando_to_M8Class.GetCoupledState()=FALSE then
        Comando_M4.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
        Movement_Step:=70;
      end_if;
    
    70:
    if Comando_M4.AxisStatus.PowerOn=0 then
       v_DiscahrgeMisure_End:=TRUE;
       Movement_Step:=0;
       MotoreM4Step:=Cmd_motore_M4_idle;
    end_if;
    
    //Calibration Mode
    80:
      if Comando_to_M8Class.GetCoupledState()=FALSE & Comando_M4.AxisStatus.Standstill then
          s_DischargeStatus.Write(input:=2);
          Comando_M4.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
          Movement_Step:=70;    
      end_if;

    
    end_case;
//========================================================================

    Cmd_motore_M4_movement_2:
    if Comando_M4.AxisError.HwError then
      v_ErrorState:=1;   
      Movement_step:=0;
      MotoreM4Step:=Cmd_motore_M4_Error;
    end_if;
    
    
    case Movement_step of
    
    0: //IDLE, ATTESA COMANDI| Il motore è già nella posizione di carica->tocca il LS
        Movement_step:=v_StartMovementCase;
    10://M2 si trova nella posizione corretta di caricamento DEVE RUOTARE NEL VERSO CORRETTO PER SCARICARE TARGET, compirà 1 giro completo (quasi)
       
     if (Comando_M4.AxisStatus.PowerOn=0) & (Comando_M4.AxisStatus.ReadyToPowerOn) then
        Comando_M4.PowerOn(Mode:=LMCAXIS_MOVE_ANY_WAY);
     elsif Comando_M4.AxisStatus.PowerOn then
        Movement_step:=20;
     end_if;
    
    20:
    
      Comando_M4.MoveRelative(Position:=900000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION , Speed:=V_M4, Accel:=A_M4, Decel:=A_M4, Jerk:=J_M4);
      Movement_step:=30;
      
    30:
    
      if Comando_M4.AxisStatus.InPosition then
        v_ACK_M4_Mov:=1;
        Movement_step:=40;
        Comando_M4.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
      end_if;
    40:
      Movement_Step:=0;
      v_StartMovementCase:=0;
      MotoreM4Step:=Cmd_motore_M4_idle;
    
    
    
    
    end_case;
//========================================================================
    
     Cmd_motore_M4_Error:
    
      ErrorState:=Comando_M4.AxisError; //AGGIORNAMENTO SERVER
      MotoreM4Step:=Cmd_motore_M4_stop;
//========================================================================      
    Cmd_motore_M4_stop:
      
      if Comando_M4.AxisStatus.Standstill & Comando_M4.AxisStatus.PowerOn=0 then
        MotoreM4Step:=Cmd_motore_M4_stopped;
      else
        Comando_M4.QuickStop(Decel:=1000000);//se asse in errore non esegue neppure l'operazione perchè spento (e in errore)
        Comando_M4.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
      end_if;
//========================================================================      
    Cmd_motore_M4_stopped:
    //ATTESA RESET
    
//========================================================================    
    Cmd_motore_M4_reset:
      Comando_M4.QuitError();
      Comando_to_M8Class.SetSequenceState(Cmd_motore:=Motore_M7::Cmd_motore_M7_reset, Motion_type:=3, StartCase:=0);
      M4_homed:=FALSE;
      v_ErrorState:=0; 
      if Comando_M4.AxisStatus.FiltRdy then
        MotoreM4Step:=Cmd_motore_M4_idle;
      end_if;

      v_MeasurementStartOver:=FALSE;
      v_DiscahrgeMisure_End:=FALSE;
      v_M8_inBlockPos:=0;
      v_offset_Dis:=0;
      v_target_misurati:=0;
      HomingStep:=0;
      Movement_step:=0;
      v_StartHomingCase:=0;
      v_StartMovementCase:=0;
      flag:=0;
      v_ACK_M4_Mov:=0;
      v_M4_LS:=0;
      v_ErrorState:=0;
      v_startTimer:=FALSE;
      s_calibrationMode.Write(input:=0);
      //s_1_3_pelletMode.Write(input:=0);
      s_DischargeStatus.Write(input:=0);
      
      if v_pelletMeasured/2>=v_PelletAvailable then
          v_pelletMeasured:=0;
          s_pelletMeasured.Write(input:=0);
          v_pelletInTrolley:=0;
          s_pelletInTrolley.Write(input:=0);
      end_if;

//========================================================================    
  
  end_case;

	state := READY;
END_FUNCTION


FUNCTION GLOBAL Motore_M4::SetSequenceState
	VAR_INPUT
		Cmd_motore 	: t_sequence_Cmd_motore_M4;
		Motion_Type 	: DINT;
		StartCase 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  if Cmd_motore=Cmd_motore_M4_homing then
    v_StartHomingCase:=StartCase;
  elsif Cmd_motore=Cmd_motore_M4_movement then
    v_StartMovementCase:=StartCase;
  elsif Cmd_motore=Cmd_motore_M4_movement_2 then
    v_StartMovementCase:=StartCase;
  end_if;

  MotoreM4Step:=Cmd_motore;
  retcode:=true;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M4::Init
M4_homed:=FALSE;
v_MeasurementStartOver:=FALSE;
v_DiscahrgeMisure_End:=FALSE;
v_M8_inBlockPos:=0;

v_offset_Dis:=0;
v_target_misurati:=0;

HomingStep:=0;
Movement_step:=0;

v_StartHomingCase:=0;
v_StartMovementCase:=0;

flag:=0;

v_ACK_M4_Mov:=0;

v_M4_LS:=0;

v_ErrorState:=0;

v_startTimer:=FALSE;

v_pelletMeasured:=0;
v_pelletInTrolley:=0;

v_PelletAvailable:=0;

END_FUNCTION


FUNCTION GLOBAL Motore_M4::GetHomedState
	VAR_OUTPUT
		Homed 	: BOOL;
	END_VAR
  
  Homed:=M4_homed;
END_FUNCTION


FUNCTION GLOBAL Motore_M4::GetMisurationStartOver
	VAR_INPUT
		Status 	: BOOL;
	END_VAR
v_MeasurementStartOver:=Status;
END_FUNCTION


FUNCTION GLOBAL Motore_M4::SetDischargeOver
	VAR_OUTPUT
		Status 	: BOOL;
	END_VAR
Status:=v_DiscahrgeMisure_End;
END_FUNCTION


FUNCTION GLOBAL Motore_M4::GetM8Status
	VAR_INPUT
		Status 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  v_M8_inBlockPos:=Status;
  retcode:=TRUE;
  
END_FUNCTION


FUNCTION GLOBAL Motore_M4::GetErrorState
	VAR_OUTPUT
		ErrorState 	: DINT;
	END_VAR
  ErrorState:=v_ErrorState;
END_FUNCTION


FUNCTION GLOBAL Motore_M4::GetMoveDone
	VAR_OUTPUT
		OutParam 	: DINT;
	END_VAR
OutParam:=v_ACK_M4_Mov;
END_FUNCTION


FUNCTION GLOBAL Motore_M4::GetPelletAvailable
	VAR_INPUT
		Param 	: DINT;
	END_VAR
v_PelletAvailable:=Param;
END_FUNCTION
