//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Motore_M1"
	Revision           = "0.0"
	GUID               = "{19F64F66-A2A1-4EDE-911F-7787BCAC831B}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "100 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(720,180)">
	<Channels>
		<Server Name="ClassSvr" GUID="{95B43F41-703F-4288-9651-40E046A5FB3E}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ErrorState" GUID="{A8AE7172-8CBE-4215-BA6E-51EC193DC97B}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="M1_Correction_Step" GUID="{01E2D920-426E-4AC5-8601-B191F0B1AE41}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="MotoreM1Step" GUID="{FF3D9529-D33E-4416-87C0-1003F9C9FD5B}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="s_M1_coupled" GUID="{28515C8E-F6C0-4EA9-B0C2-D5FAA49D9BA4}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_M1_Homed" GUID="{D468EEC4-536B-4E41-A802-A9F313682827}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="c_MaxCurrent" Required="true" Internal="false"/>
		<Client Name="Comando_M1" Required="false" Internal="false"/>
		<Client Name="M1_LS_1" Required="true" Internal="false" Comment="Limit Switch posizione accoppiata"/>
		<Client Name="M1_LS_2" Required="false" Internal="false" Comment="Limit Switch della posizione disaccoppiata"/>
		<Client Name="SetPosition_Controller" Required="true" Internal="false"/>
	</Channels>
	<Separators>
		<Clients>
			<SepChn Position="1"/>
			<SepChn Position="4"/>
		</Clients>
	</Separators>
</Class>
*)
Motore_M1 : CLASS
	TYPE
	  t_sequence_Cmd_motore_M1 :  //! <Type Public="true" Name="t_sequence_Cmd_motore_M1"/>
	  (
	    Cmd_motore_M1_idle,
	    Cmd_motore_M1_homing,
	    Cmd_motore_M1_phasing,
	    Cmd_motore_M1_movement,
	    Cmd_motore_M1_reset,
	    Cmd_motore_M1_Error,
	    Cmd_motore_M1_stop,
	    Cmd_motore_M1_stopped
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	MotoreM1Step 	: SvrCh_t_sequence_Cmd_motore_M1_PTofCls_Motore_M1;
	ErrorState 	: SvrCh__LMCAXIS_ERROR;
	M1_Correction_Step 	: SvrCh_DINT;
	s_M1_Homed 	: SvrCh_DINT;
	s_M1_coupled 	: SvrCh_DINT;
  //Clients:
	Comando_M1 	: CltChCmd__LMCAxis;
	M1_LS_1 	: CltCh_DINT;
	M1_LS_2 	: CltCh_DINT;
	c_MaxCurrent 	: CltCh_DINT;
	SetPosition_Controller 	: CltCh_DINT;
  //Variables:
		M1_homed 	: BOOL;
		M1_coupled 	: DINT;
		MotoreM1_Motion_Type 	: DINT;
		HomingStep 	: DINT;
		MovementStep 	: DINT;
		v_StartHomingCase 	: DINT;
		v_StartMovementCase 	: DINT;
		v_M1_LS_1 	: DINT;
		v_M1_LS_2 	: DINT;
		v_ErrorState 	: DINT;
		v_M1_Correction_Step 	: DINT;
		v_ACK_M1_Mov 	: DINT;
		cicli 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetSequenceState
		VAR_INPUT
			Cmd_motore 	: t_sequence_Cmd_motore_M1;
			Motion_type 	: DINT;
			StartCase 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetHomedState
		VAR_OUTPUT
			Homed 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetCoupledState
		VAR_OUTPUT
			Coupled 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetErrorState
		VAR_OUTPUT
			ErrorState 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetMovDone
		VAR_OUTPUT
			OutParam 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL s_M1_Homed::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL s_M1_coupled::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _LMCAxis


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Motore_M1::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_MOTORE_M1
0$UINT, 0$UINT, (SIZEOF(::Motore_M1))$UINT, 
6$UINT, 5$UINT, 0$UINT, 
TO_UDINT(2366454265), "Motore_M1", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Motore_M1.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::Motore_M1.MotoreM1Step.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1537383881), "MotoreM1Step", 
(::Motore_M1.ErrorState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2975757027), "ErrorState", 
(::Motore_M1.M1_Correction_Step.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(19108166), "M1_Correction_Step", 
(::Motore_M1.s_M1_Homed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1914659803), "s_M1_Homed", 
(::Motore_M1.s_M1_coupled.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(810683571), "s_M1_coupled", 
//Clients:
(::Motore_M1.Comando_M1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4017566963), "Comando_M1", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 114$UINT, 
(::Motore_M1.M1_LS_1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(504394008), "M1_LS_1", 
(::Motore_M1.M1_LS_2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2266570914), "M1_LS_2", 
(::Motore_M1.c_MaxCurrent.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2379934917), "c_MaxCurrent", 
(::Motore_M1.SetPosition_Controller.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(265130042), "SetPosition_Controller", 
END_FUNCTION


#define USER_CNT_Motore_M1 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Motore_M1] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Motore_M1::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Motore_M1, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	M1_Correction_Step.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF M1_Correction_Step.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_M1_Homed.pMeth			:= StoreMethod( #s_M1_Homed::Read(), #M_WR_DIRECT() );
	IF s_M1_Homed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_M1_coupled.pMeth			:= StoreMethod( #s_M1_coupled::Read(), #M_WR_DIRECT() );
	IF s_M1_coupled.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL Motore_M1::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

//M1: CHARGE SLIDER

  v_M1_LS_1:=M1_LS_1.Read(); 
  v_M1_LS_2:=M1_LS_2.Read();
  
  v_M1_Correction_Step:=10000*M1_Correction_Step.Read();
  
  s_M1_Homed.Write(input:=M1_homed);
  s_M1_coupled.Write(input:=M1_coupled);
  
  case MotoreM1Step of
  
//============================================================================  
  
    Cmd_motore_M1_idle:
    
    //non si fà nulla. ATTESA COMANDI
     if Comando_M1.AxisError.HwError then
      v_ErrorState:=1;   
      MotoreM1Step:=Cmd_motore_M1_Error;
     end_if;
     v_ACK_M1_Mov:=0;
//============================================================================
  
    Cmd_motore_M1_homing:

    if Comando_M1.AxisError.HwError then
      v_ErrorState:=1;   
      HomingStep:=0;
      MotoreM1Step:=Cmd_motore_M1_Error;
    end_if;
    
    case HomingStep of
    0://idle
      HomingStep:=v_StartHomingCase;
      
    5:
      if v_M1_LS_2 then //Motore già disaccoppiato. Però per essere già accoppiato dovrebbe essere acceso.
        HomingStep:=50;
      else //il motore può essere accoppiato o in una qualsiasi posizione; è necessario comunque portarlo in pos disaccoppiata.
        HomingStep:=10;
      end_if;

      
    10:
    
      if (Comando_M1.AxisStatus.PowerOn=0) & (Comando_M1.AxisStatus.ReadyToPowerOn) then
        c_MaxCurrent.Write(input:=MotorMaxCurrent);
        Comando_M1.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY); //può ruotare in entrambi i versi
      elsif Comando_M1.AxisStatus.PowerOn then
        HomingStep:=20;
      end_if;
      
    20:
      Comando_M1.MoveEndless(Speed:=-V_M1, Accel:=-A_M1, Jerk:=-J_M1);
      //Comando_M1.TuneAxis(Position:=P_M1, Speed:=V_M1, Accel:=A_M1, Mode:=LMCAXIS_TUNE_POSITON_IN_NEGATIVE_DIRECTION, WaitTime:=0, Jerk:=J_M1);
      HomingStep:=30;  
    
    30:
    if v_M1_LS_2 then //quando tocca LS
    
      Comando_M1.StopMove(Decel:=A_M1, Jerk:=J_M1);
      HomingStep:=40;

    end_if;

    //NON SPENGO PERCHE' DEVE RIMANERE IN POSIZIONE  
    
    40://Controllo che il motore si sia fermato
    
      if Comando_M1.AxisStatus.Standstill then
        SetPosition_Controller.Write(input:=0);
        c_MaxCurrent.Write(input:=0.3*MotorMaxCurrent);
        M1_homed:=TRUE;
        M1_coupled:=0;
        MotoreM1Step:=Cmd_motore_M1_idle;
        v_StartHomingCase:=0;
        HomingStep:=0;
      end_if;
      

    end_case;

//============================================================================    
    
    Cmd_motore_M1_movement:
    
    // 0: DISACCOPPIATO->ACCOPPIATO | 1: ACCOPPIATO->DISACCOPPIATO

    if Comando_M1.AxisError.HwError then
      v_ErrorState:=1;   
      MovementStep:=0;
      MotoreM1Step:=Cmd_motore_M1_Error;
    end_if;
  
    if MotoreM1_Motion_Type=0 then

      if v_M1_LS_2 & M1_coupled=2 then // condizione di M1_Coupled perchè altrimenti quando viene attivato il LS questa condizione viene attivata e il case interno non viene terminato
        //Motore si trova già in posizione di accoppiamento
        M1_coupled:=2;  
      
      elsif M1_coupled=0 | M1_coupled=1 then
      
        
        case MovementStep of
      
          0: //IDLE
            MovementStep:=v_StartMovementCase;
            
        
          10:
            M1_coupled:=1;//in movimento
            c_MaxCurrent.Write(input:=MOTORMAXCURRENT);
            if (Comando_M1.AxisStatus.PowerOn=0) & (Comando_M1.AxisStatus.ReadyToPowerOn) then
                Comando_M1.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
            elsif Comando_M1.AxisStatus.PowerOn then
                MovementStep:=20;
            end_if;
        
          20:
            //Comando_M1.MoveAbsolute(Position:=(P_M1_C+v_M1_Correction_Step), Speed:=V_M1, Accel:=A_M1, Decel:=A_M1, Jerk:=J_M1);
            Comando_M1.MoveEndless(Speed:=V_M1, Accel:=A_M1, Jerk:=J_M1);
            MovementStep:=30;

          30:
            if v_M1_LS_1 | Comando_M1.AxisStatus.InPosition then
              Comando_M1.StopMove(Decel:=A_M1, Jerk:=J_M1);
              MovementStep:=40;
            end_if;
          
            
          40:
            if Comando_M1.AxisStatus.Standstill then
              c_MaxCurrent.Write(input:=0.3*MOTORMAXCURRENT);
              M1_coupled:=2;
              s_M1_coupled.Write(input:=M1_coupled);
              MovementStep:=0;
              v_StartMovementCase:=0;
              MotoreM1Step:=Cmd_motore_M1_idle;
            end_if;

        end_case;
      
      end_if;
    
    elsif MotoreM1_Motion_Type=1 then
    //MOVIMENTO 1: ACCOPPIATO->DISACCOPPIATO
    
        case MovementStep of
      
        0: //IDLE
          MovementStep:=v_StartMovementCase;
          M1_coupled:=1;//in movimento
        
        10: //POWER ON
          
          c_MaxCurrent.Write(input:=MOTORMAXCURRENT);
          if (Comando_M1.AxisStatus.PowerOn=0) & (Comando_M1.AxisStatus.ReadyToPowerOn) then
              Comando_M1.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
          elsif Comando_M1.AxisStatus.PowerOn then
            MovementStep:=20;
          end_if;
        
        20:
            if v_M1_LS_2=0 then
              Comando_M1.MoveEndless(Speed:=-1.3*V_M1, Accel:=-1.3*A_M1, Jerk:=-1.3*J_M1);
              MovementStep:=30;
            end_if;
        30:
        
          if v_M1_LS_2 then
            Comando_M1.StopMove(Decel:=A_M1, Jerk:=J_M1);
            MovementStep:=40;
          end_if;
          
          
        40:
          if Comando_M1.AxisStatus.Standstill then
            c_MaxCurrent.Write(input:=0.3*MOTORMAXCURRENT);
            M1_coupled:=0;
            s_M1_coupled.Write(input:=M1_coupled);
            MovementStep:=0;
            v_StartMovementCase:=0;
            MotoreM1Step:=Cmd_motore_M1_idle;
          end_if;
          
        end_case;
      
      //end_if;
    
    elsif MotoreM1_Motion_Type=2 then

        case MovementStep of
      
        0: //IDLE
        MovementStep:=v_StartMovementCase;
        
        10: //POWER ON
        //M1_coupled:=0;
          c_MaxCurrent.Write(input:=MOTORMAXCURRENT);
          if (Comando_M1.AxisStatus.PowerOn=0) & (Comando_M1.AxisStatus.ReadyToPowerOn) then
              Comando_M1.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
          elsif Comando_M1.AxisStatus.PowerOn then
            MovementStep:=20;
          end_if;
        
        20:
          Comando_M1.MoveRelative(Position:=-P_NoStuck, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=-V_M1, Accel:=-A_M1, Decel:=-A_M1, Jerk:=-J_M1);
          MovementStep:=30;

        30:
          if Comando_M1.AxisStatus.Standstill then
            Comando_M1.MoveRelative(Position:=P_NoStuck, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=V_M1, Accel:=A_M1, Decel:=A_M1, Jerk:=J_M1);
            v_ACK_M1_Mov:=1;
            MovementStep:=40;
          end_if;

        40:
          if Comando_M1.AxisStatus.Standstill then
            c_MaxCurrent.Write(input:=0.3*MOTORMAXCURRENT);
            MovementStep:=0;
            v_StartMovementCase:=0;
            MotoreM1Step:=Cmd_motore_M1_idle;
            cicli:=cicli+1;
          end_if;
          
        end_case;
      
    
    
    else
      //errore
      MotoreM1Step:=Cmd_motore_M1_reset;
    
    end_if;

//============================================================================
    
    Cmd_motore_M1_Error:
    
      ErrorState:=Comando_M1.AxisError; //AGGIORNAMENTO SERVER
      MotoreM1Step:=Cmd_motore_M1_stop;
      
//============================================================================

    Cmd_motore_M1_stop:

      
      if Comando_M1.AxisStatus.Standstill & Comando_M1.AxisStatus.PowerOn=0 then
        MotoreM1Step:=Cmd_motore_M1_stopped;
      else
        Comando_M1.QuickStop(Decel:=1000000);//se asse in errore non esegue neppure l'operazione perchè spento (e in errore)
        Comando_M1.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
      end_if;

//============================================================================

    Cmd_motore_M1_stopped:
    //ATTESA RESET
//============================================================================

    Cmd_motore_M1_reset:

      Comando_M1.QuitError();
      //M1_homed:=FALSE;
      v_ErrorState:=0; 
      if Comando_M1.AxisStatus.FiltRdy then
        MotoreM1Step:=Cmd_motore_M1_idle;
      end_if;
      
      M1_homed:=FALSE;
      M1_coupled:=0;
      MotoreM1_Motion_Type:=0;
      v_M1_Correction_Step:=M1_Correction_Step.Read();
      v_M1_LS_1:=0;
      v_M1_LS_2:=0;
      v_StartHomingCase:=0;
      v_StartMovementCase:=0;
      MovementStep:=0;
      v_ACK_M1_Mov:=0;
      cicli:=0;
      HomingStep:=0;
//============================================================================

  end_case;

	state := READY;
END_FUNCTION


FUNCTION GLOBAL Motore_M1::SetSequenceState
	VAR_INPUT
		Cmd_motore 	: t_sequence_Cmd_motore_M1;
		Motion_type 	: DINT;
		StartCase 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  MotoreM1Step:=Cmd_motore;
  MotoreM1_Motion_Type:=Motion_type;
  
  if MotoreM1Step=Cmd_motore_M1_homing then
    v_StartHomingCase:=StartCase;
  elsif MotoreM1Step=Cmd_motore_M1_movement then
    v_StartMovementCase:=StartCase;
  end_if;


  retcode:=true;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M1::Init
M1_homed:=FALSE;
M1_coupled:=0;
MotoreM1_Motion_Type:=0;

v_M1_Correction_Step:=M1_Correction_Step.Read();

v_M1_LS_1:=0;
v_M1_LS_2:=0;

v_StartHomingCase:=0;
v_StartMovementCase:=0;

v_ErrorState:=0;

MovementStep:=0;

v_ACK_M1_Mov:=0;

cicli:=0;
END_FUNCTION


FUNCTION GLOBAL Motore_M1::GetHomedState
	VAR_OUTPUT
		Homed 	: BOOL;
	END_VAR
  Homed:=M1_homed;
END_FUNCTION


FUNCTION GLOBAL Motore_M1::GetCoupledState
	VAR_OUTPUT
		Coupled 	: DINT;
	END_VAR
  Coupled:=M1_coupled;
END_FUNCTION


FUNCTION GLOBAL Motore_M1::GetErrorState
	VAR_OUTPUT
		ErrorState 	: DINT;
	END_VAR
  ErrorState:=v_ErrorState;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M1::s_M1_Homed::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	output := s_M1_Homed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M1::s_M1_coupled::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	output := s_M1_coupled;

END_FUNCTION


FUNCTION GLOBAL Motore_M1::GetMovDone
	VAR_OUTPUT
		OutParam 	: DINT;
	END_VAR
  OutParam:=v_ACK_M1_Mov;
END_FUNCTION
