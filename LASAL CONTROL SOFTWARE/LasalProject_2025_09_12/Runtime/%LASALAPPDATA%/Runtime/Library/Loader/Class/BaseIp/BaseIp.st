//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#include "RTOS_IprIntern.h"
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "BaseIp"
	Revision           = "0.0"
	GUID               = "{C220250E-0F97-4E68-81EC-4B3B5264533D}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="pCmd" GUID="NULL" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
</Class>
*)
BaseIp : CLASS
	TYPE
#pragma pack(push, 1)
	  IpStruct : STRUCT
	    uiDummy : UINT;
	    pNxtIp : ^BaseIp;
	    head : iprHead;
	    resu : results;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	pCmd 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		_m 	: IpStruct;
		m_bOsResourcesUsed 	: BOOL;
		m_lastErrorCode 	: DINT;
  //Functions:
	
	FUNCTION GLOBAL GetInterpreterNumber
		VAR_OUTPUT
			uiProgNo 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL BaseIp
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL CheckForLoad;
	
	FUNCTION SetRunTimeError;
	
	FUNCTION SetActiveObj
		VAR_INPUT
			pThis 	: ^VirtualBase;
		END_VAR;
	
	FUNCTION ClearActiveObj
		VAR_INPUT
			pThis 	: ^VirtualBase;
		END_VAR;
	
	FUNCTION EvalParaExpr
		VAR_INPUT
			pCmdBuff 	: ^CmdStruct;
			pRead 	: ^void;
		END_VAR
		VAR_OUTPUT
			ret_code 	: UDINT;
		END_VAR;
	
	FUNCTION CallUserClassMethod
		VAR_OUTPUT
			state 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL BaseIp2
		VAR_INPUT
			useOsResources 	: BOOL;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL SetCodePointer
		VAR_INPUT
			udCodeOffset 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SetCalledIpr
		VAR_INPUT
			uiIprNo 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL GetHead
		VAR_OUTPUT
			pHead 	: ^iprHead;
		END_VAR;
	
	FUNCTION GLOBAL GetResult
		VAR_OUTPUT
			pResu 	: ^results;
		END_VAR;
	
	FUNCTION GLOBAL GetNextIP
		VAR_OUTPUT
			pNext 	: ^BaseIp;
		END_VAR;
	
	FUNCTION GLOBAL SetNextIP
		VAR_INPUT
			pNext 	: ^BaseIp;
		END_VAR;
	
	FUNCTION GLOBAL BefIpr
		VAR_INPUT
			bSetNext 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			state 	: iprStates;
		END_VAR;
	
	FUNCTION AWL GLOBAL AWLSetWorkState;
	
	FUNCTION AWL GLOBAL AWLAddpCode;
	
	FUNCTION AWL GLOBAL AWLAddpResu;
	
	FUNCTION GLOBAL StartProgram
		VAR_INPUT
			uiPrgNo 	: UINT;
			uiLabelNo 	: UINT;
		END_VAR
		VAR_OUTPUT
			state 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL StartProgramOfs
		VAR_INPUT
			uiPrgNo 	: UINT;
			offset 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL RunProgram
		VAR_INPUT
			uiProgNo 	: UINT;
			uiLabelNo 	: UINT;
		END_VAR
		VAR_OUTPUT
			state 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL StopProgram
		VAR_INPUT
			uiProgNo 	: UINT;
		END_VAR
		VAR_OUTPUT
			state 	: iprStates;
		END_VAR;
	
	FUNCTION ClearLoadBit
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR;
	
	FUNCTION SetLoadBit
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR;
	
	FUNCTION IsValidServer
		VAR_INPUT
			pSvr 	: ^SvrCh;
		END_VAR
		VAR_OUTPUT
			isValid 	: BOOL;
		END_VAR;
	
	FUNCTION IsValidClient
		VAR_INPUT
			pClt 	: ^CltCh;
		END_VAR
		VAR_OUTPUT
			isValid 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL AmICalledFrom
		VAR_INPUT
			pIpr 	: ^ProgIp;
		END_VAR
		VAR_OUTPUT
			retVal 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SetLastError
		VAR_INPUT
			errorCode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetLastError
		VAR_OUTPUT
			errorCode 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB BaseIp::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_BASEIP
0$UINT, 0$UINT, (SIZEOF(::BaseIp))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(1945645538), "BaseIp", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::BaseIp.pCmd.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2901628902), "pCmd", 
//Clients:
END_FUNCTION


#define USER_CNT_BaseIp 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_BaseIp] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION BaseIp::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_BaseIp, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #SetCalledIpr();

#pragma warning (default : 74)
	pCmd.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF pCmd.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= BaseIp();

END_FUNCTION

#pragma usingLtd ProgIp

//{{LSL_IMPLEMENTATION
#include "ComLink.h"
#include ".\LoaderItf.h"
#include ".\RTOS_PrivHeader.h"

#pragma using ProgIp
#pragma using DebugIp
#pragma using IprMgr

//#define SEND_STATE_ONLY (-1)$UINT

#include ".\include\L2_Ipr.h"

FUNCTION GLOBAL StoreCmdEx
VAR_INPUT
	pCmd            : ^CMDMETH;
	mode            : CMDMETHMODE;
	useOsResources	: BOOL;
  allocPermanent : BOOL; // TRUE=Speicher kann in einen Bereich gelegt werden, der nicht freigegeben werden muss
END_VAR
VAR_OUTPUT
	pMeth           : ^CMDMETH;
END_VAR;

FUNCTION BaseIp::BaseIp
VAR_OUTPUT
  ret_code : ConfStates;
END_VAR
  // Das ist ein Konstruktor der normalerweise nicht aufgerufen wird, da Objekte 
  // von dieser Klasse händisch angelegt werden (d.h. alloc + Aufruf des Konstruktors) 
  // und als Konstrukor der BaseIp2 (mit einem Übergabeparameter) verwendet wird.
  // Es gibt aber einen Fall wo dieser Konstruktor verwendet wird: NewObj("ProgIp", #szName[0])
  ret_code := BaseIp2(FALSE);
END_FUNCTION

FUNCTION GLOBAL BaseIp::BaseIp2
	VAR_INPUT
		useOsResources 	: BOOL;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
VAR
  vmt	: _LSL_STD_VMETH;
END_VAR
   
  _memset(this$^void, 0, sizeof(BaseIp));
	m_bOsResourcesUsed := useOsResources;

	InitCmdTable (nCmd := nSTDCMD + USER_CNT_BaseIp, pCmd := #vmt.CmdTable);

	// overwrite default methods here
	#pragma warning (disable : 74)
	vmt.UserFcts[0]			:= #SetCalledIpr();
	#pragma warning (default : 74)

	pCmd.pMeth	:= StoreCmdEx(pCmd:=#vmt.CmdTable, EXCLUSIVE, m_bOsResourcesUsed, allocPermanent:=FALSE);

	_m.head.FunkSt			:= READY;
	_m.head.Workstate		:= READY;
	_m.head.pResu			:= #_m.resu;
  
  IF pCmd.pMeth = NIL THEN
    ret_code := C_OUTOF_NEAR;
  ELSE
    ret_code  := C_OK;
  END_IF;

END_FUNCTION
//--------------------------------------------------------------------
// test if there is something to load into the programs
//--------------------------------------------------------------------
// should be put into the automatic cycle
FUNCTION GLOBAL BaseIp::CheckForLoad
VAR
	uiPrgNo			: UINT;
	uiBitField		: UDINT; //UINT;
	pSeq			: ^ProgIp;
END_VAR
	
//	IF OPS.uiProgsToLoad THEN
//			uiBitField 	:= OPS.uiProgsToLoad;
  if( ( uiProgsToLoad[ 0 ] ) or ( uiProgsToLoad[ 1 ] ) )then
    uiBitField := uiProgsToLoad[ 0 ];
		uiPrgNo:= 0;
		WHILE uiPrgNo < OPS.pProg^.uiProgs DO
			IF uiBitField AND 1 THEN
				pSeq := IprMgr::GetInterpreter(uiPrgNo);
				pSeq^.LoadProgFromTemp(uiPrgNo, FALSE);
			END_IF;

      if( uiPrgNo = 31 )then
        uiBitField := uiProgsToLoad[ 1 ];
      else
        uiBitField	/= 2;
      end_if;
      
			uiPrgNo		+= 1;
		END_WHILE;

	END_IF;

END_FUNCTION
// Function should be called whenever an interpreter error occures

FUNCTION BaseIp::SetRunTimeError

	_m.head.funkst	:=	ERROR;

END_FUNCTION
FUNCTION BaseIp::SetActiveObj
VAR_INPUT
	pThis		: ^VirtualBase;
END_VAR
VAR
	i			: UINT;
	j			: UINT;
	pCmp		: ^VirtualBase;
END_VAR

	pCmp	:= pThis;	// search for existing pointer

	FOR j := 0 TO 1 DO

		FOR i:=0 TO ANZ_FPTRS-1 DO
			IF _m.head.fptrs[i] = pCmp THEN
				_m.head.fptrs[i] := pThis;
				RETURN;
			END_IF;
		END_FOR;

		pCmp	:= NIL;	// search for empty place

	END_FOR;

	SetRuntimeError();

END_FUNCTION
FUNCTION BaseIp::ClearActiveObj
VAR_INPUT
	pThis		: ^VirtualBase;
END_VAR
VAR
	i			: UINT;
END_VAR

	FOR i:=0 TO ANZ_FPTRS-1 DO
		IF _m.head.fptrs[i] = pThis THEN
			_m.head.fptrs[i] := NIL;
			RETURN;
		END_IF;
	END_FOR;

END_FUNCTION
// Function evaluates the parameter-list of a command call
// to an object.
// The results are written to a CmdStruct, the parameters are
// read from the pRead-pointer.
// In case of any syntax error, the function returns FALSE,
// otherwise TRUE.
//
FUNCTION BaseIp::EvalParaExpr
VAR_INPUT
	pCmdBuff		: ^CmdStruct;
	pRead			: pVoid;
END_VAR
VAR_OUTPUT
	ret_code		: UDINT;
END_VAR
VAR
	pCmd			: ^DINT;
	i				: UINT;
END_VAR

	pCmd 			:= #pCmdBuff^.aPara[0]$DINT;
	pCmdBuff^.uiCmd	:= (pRead+4)^$UINT; 	// cmd
	pRead			+= 6;					// this+Cmd

	IF pRead^$Prefix = P_USER_STREAM THEN
		//				total len
		i			:= _m.head.pCode^.uiLng-
					   (sizeof(UINT)+sizeof(InstrSet)+	// so(len)-so(cmd)
						sizeof(^SvrChCmd)+sizeof(CmdStruct.uiCmd)+
						sizeof(Prefix));

		IF i > 0 & i <= sizeof(CmdStruct.aPara) THEN
			_memcpy(pCmd, pRead+1, i); 
			ret_code	:= TRUE;
		ELSE
			ret_code	:= FALSE;
		END_IF;
		RETURN;
	END_IF;

		// evaluate expressions and create parameter values
	FOR i:= 0 TO MAXCMDPARA - 1 DO
		pCmd^	:= GetResu((#pRead)$pVoid, _m.head.pResu);

		CASE pRead^$Prefix OF
				// end of parameter list
		P_EOL:		EXIT;
				// add size of one parameter
		P_COMMA:	pCmd	+= sizeof(DINT);
					pRead	+= 1;

		ELSE
			_m.head.funkst		:= ERROR;
      SetLastError(PROGIP_ERR_SYNTAX);
			ret_code		:= FALSE;
			RETURN;
		END_CASE;
	END_FOR;

	ret_code	:= TRUE;
	
END_FUNCTION

// If the PARALLEL_CALL-bit is set in a command, then 
// the object pointer is stored to a Ipr-buffer. If the whole
// interpreter is stopped, the Kill()-method is called for
// all of those objects.
//
FUNCTION BaseIp::CallUserClassMethod
VAR_OUTPUT
	state		: IprStates;
END_VAR
VAR
	pThis			: ^VirtualBase;
	pRead			: ^void;
	cmdBuff			: CMDSTRUCT;
END_VAR

	pRead 		:= #_m.head.pCode^.aPara[0];
	pThis		:= ((pRead$^pVoid)^)$^VirtualBase;	// this
	state		:= READY;
	_m.resu.uiLng	:= SEND_STATE_ONLY;		// no return value specified

	IF !!IsValidServer((#pThis^.pSvrChCmd)$^SvrCh) THEN
		state			:= ERROR;
		RETURN;
	END_IF;

  // special: KILL 
  if( _m.head.pCode^.uiLng = 16#ecff )then
    _m.head.funkst := ERROR_BUSY;
  end_if;

	CASE _m.head.funkst OF
	READY:
		_m.head.funkst := BUSY;

		IF EvalParaExpr(#CmdBuff, pRead) = FALSE THEN
			state			:= ERROR;
			RETURN;
		END_IF;

		// check if a parallel call is executed on this object
		IF (CmdBuff.uiCmd AND PARALLEL_CALL) THEN
			SetActiveObj(pThis);
		ELSE 	     
		// check if a parallel call was executed
			ClearActiveObj(pThis);
		END_IF;

			// call the NewInst() for the object and let it
			// perform its action according to the command
		state := pThis^.NewInst(#CmdBuff, _m.head.pResu);

	ERROR_BUSY:
		state			:= pThis^.Kill();
		_m.head.funkst 	:= BUSY;

	BUSY:	// instruction CMD, funkstate <> _START
		//_m.head.funkst := BUSY;
		
		IF EvalParaExpr(#CmdBuff, pRead) = FALSE THEN
			state			:= ERROR;
			RETURN;
		END_IF;

		state := pThis^.GetState(#CmdBuff, _m.head.pResu);

	ELSE
		state := ERROR;
	END_CASE;

END_FUNCTION
//Setzt den Codepointer auf den neuen Offset
FUNCTION GLOBAL BaseIp::SetCodePointer
VAR_INPUT
	udCodeOffset	: UDINT;
END_VAR

	_m.head.pCode := udCodeOffset$^INSTRUCT;

END_FUNCTION
//Bestimmt welchen Interpreter dieser aufgerufen hat
#pragma warning (disable : 73)
FUNCTION GLOBAL VIRTUAL BaseIp::SetCalledIpr
VAR_INPUT
	uiIprNo		: UINT;
END_VAR

#pragma warning (default:73)
END_FUNCTION
// Liefert einen Zeiger auf den Status-Merker des Interpreters
FUNCTION GLOBAL BaseIp::GetHead
VAR_OUTPUT
	pHead		: ^IprHead;
END_VAR

	pHead		:= #_m.head;

END_FUNCTION
// Liefert einen Zeiger auf den Resultat-Puffer des Interpreters
FUNCTION GLOBAL BaseIp::GetResult
VAR_OUTPUT
	pResu		: ^Results;
END_VAR

	pResu		:= #_m.resu;

END_FUNCTION
// Liefert den nächsten Eintrag in der verketteten Liste der
// Interpretoren
FUNCTION GLOBAL BaseIp::GetNextIP
VAR_OUTPUT
	pNext		: ^BaseIp;
END_VAR

	pNext	:= _m.pNxtIp;

END_FUNCTION
// Liefert den nächsten Eintrag in der verketteten Liste der
// Interpretoren
FUNCTION GLOBAL BaseIp::SetNextIP
VAR_INPUT
	pNext		: ^BaseIp;
END_VAR

	_m.pNxtIp	:= pNext;

END_FUNCTION
FUNCTION GLOBAL BaseIP::BefIpr		// interpreter
VAR_INPUT
	bSetNext		: ^UDINT;
END_VAR
VAR_OUTPUT
	state			: IPRSTATES;
END_VAR
VAR
	pResData		: ^UDINT;
	pRead			: ^VOID;
END_VAR

	pRead 		:= #_m.head.pCode^.aPara[0];
	pResData 	:= #_m.resu.aData[0]$UDINT;
	bSetNext^	:= TRUE;
	state		:= READY;

	CASE _m.head.pCode^.opCode OF

	//--------------------------------------------------------------------
	// Start Program parallel
	// <Start_prog> ,<Prognr><uiLabelNo>
	// <>						 <1>     <1>
	//--------------------------------------------------------------------

	I_STARTPROG:
		state	:= StartProgram(pRead^$USINT, (pRead+1)^$UINT );

	//--------------------------------------------------------------------
	// Run program, and wait for termination
	// <Start_prog> ,<Prognr>,<uiLabelNo>
	//--------------------------------------------------------------------

	I_RUNPROG:
		state	:= RunProgram(pRead^$USINT, (pRead+1)^$UINT );

	//--------------------------------------------------------------------
	// start  loadprogram  <length> <program-number>
	//	para[0]		<length>	4 byte
	//	para[4]		<#prog> 	4 byte
	//--------------------------------------------------------------------
	I_STOPPROG:
		state	:= StopProgram(pRead^$USINT);

	ELSE
		state := ERROR;
	END_CASE;

END_FUNCTION

#ifdef COMLINK_LASAL
FUNCTION	AWL BaseIp::AWLSetWorkState
 #ifdef _LSL_TARGETARCH_ARM
  // todo: wird momentan nicht aufgerufen
 #else
	S.AX      (EDI+comdata.Com._m.head.workstate+0)
 #endif 

END_FUNCTION
FUNCTION	AWL	BaseIp::AWLAddpCode
 #ifdef _LSL_TARGETARCH_ARM
  // todo: wird momentan nicht aufgerufen
 #else
	ADD.EBX    (EDI+comdata.Com._m.head.pCode) // load the pointer in the buffer
 #endif 

END_FUNCTION
FUNCTION	AWL BaseIp::AWLAddpResu
 #ifdef _LSL_TARGETARCH_ARM
  // todo: wird momentan nicht aufgerufen
 #else
	ADD.EBX    (edi+comdata.Com._m.head.pResu) // load the pointer in the buffer
 #endif 

END_FUNCTION
#endif // COMLINK_LASAL

FUNCTION GLOBAL BaseIp::StartProgram
VAR_INPUT
	uiPrgNo			: UINT;
	uiLabelNo		: UINT;
END_VAR
VAR_OUTPUT
	state			: IprStates;
END_VAR
VAR
	pIpr			: ^ProgIp;
	pHead			: ^IprHead;
END_VAR

	state		:= READY;

	IF	_m.head.funkSt = READY &
		uiPrgNo < OPS.pProg^.uiProgs THEN	// valid program number

		_m.head.funkst := BUSY;
		pIpr		:= IprMgr::GetInterpreter(uiPrgNo);
		pHead		:= pIpr^.GetHead();

		IF pIpr^.SetInstructionToProgStart(uiLabelNo) = BUSY THEN
			pHead^.funkSt := READY;		// started parallel program

			//Speichert im aufgerufenen Interpreter die Nummer des Ipr der ihn aufgerufen hat
			pIpr^.SetCalledFrom(GetInterpreterNumber());

		ELSE
			pHead^.funkSt := ERROR;
			state := ERROR;
		END_IF;

	ELSE					// invalid program number
		state		:= ERROR;
	END_IF;

END_FUNCTION

FUNCTION GLOBAL BaseIp::StartProgramOfs
	VAR_INPUT
		uiPrgNo 	: UINT;
		offset 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state 	: IprStates;
	END_VAR
VAR
	pIpr			: ^ProgIp;
	pHead			: ^IprHead;
END_VAR

	state		:= READY;

	IF	_m.head.funkSt = READY &
		uiPrgNo < OPS.pProg^.uiProgs THEN	// valid program number

		_m.head.funkst := BUSY;
		pIpr		:= IprMgr::GetInterpreter(uiPrgNo);
		pHead		:= pIpr^.GetHead();

		IF pIpr^.SetInstructionToProgStartOfs(offset) = BUSY THEN
			pHead^.funkSt := READY;		// started parallel program

			//Speichert im aufgerufenen Interpreter die Nummer des Ipr der ihn aufgerufen hat
			pIpr^.SetCalledFrom(GetInterpreterNumber());

		ELSE
			pHead^.funkSt := ERROR;
			state := ERROR;
		END_IF;

	ELSE					// invalid program number
		state		:= ERROR;
	END_IF;

END_FUNCTION

(*
  AmICalledFrom
    Wer hat mich gerufen ?
    Prüft, ob man vom angegebenen Interpreter direkt oder indirekt aufgerufen 
    worden ist.
*)
FUNCTION GLOBAL BaseIp::AmICalledFrom
VAR_INPUT
	pIpr			: ^ProgIp;
END_VAR
VAR_OUTPUT
	retVal : BOOL;
END_VAR
VAR
	uiMyIprNo		: UINT;
  uiHisCalledIpr : UINT;
	pIprCaller	: ^ProgIp;
END_VAR

  uiHisCalledIpr := pIpr^.GetCalledIpr();
  uiMyIprNo := GetInterpreterNumber();
  
  IF uiHisCalledIpr = uiMyIprNo THEN
    // der angegebene Interpreter hat mich aufgerufen
    retVal := TRUE;
  ELSIF uiHisCalledIpr = pIpr^.GetInterpreterNumber() THEN
    // der angegebene Interpreter hat keinen anstehenden I_RUNPROG Aufruf
    retVal := FALSE;
  ELSE
    // der angegebene Interpreter wurde von einem anderen aufgerufen
    pIprCaller := IprMgr::GetInterpreter(pIpr^.GetCalledIpr());
    IF pIprCaller = pIpr THEN
      // Das kann sich jetzt nur mehr um einen Fehler handeln.
      // Um nicht aufgrund eines endlosen rekursiven Aufrufs in einem Stackoverflow zu 
      // landen, wird hier einfach eine Exception ausgelöst.
      (0$^UDINT)^:=0;
    END_IF;
    retVal := pIpr^.AmICalledFrom(pIprCaller);
  END_IF;

END_FUNCTION

FUNCTION GLOBAL BaseIp::RunProgram
VAR_INPUT
	uiProgNo		: UINT;
	uiLabelNo		: UINT;
END_VAR
VAR_OUTPUT
	state			: IprStates;
END_VAR
VAR
	pIpr			: ^ProgIp;
	OtherWorkState	: IprStates;
	pHead			: ^IprHead;
  continueFlag : BOOL;
  checkStart : BOOL;
  checkFinished : BOOL;
END_VAR

	state		:= READY;

	IF uiProgNo < ops.pProg^.uiProgs THEN	// valid program number

		pIpr := IprMgr::GetInterpreter(uiProgNo);
		pHead := pIpr^.GetHead();
		OtherWorkState	:= pHead^.WorkState;

    // Wenn ein I_RUNPROG ausgeführt wird, dann müssen 2 Fälle unterschieden werden:
    //  a) Der Ziel Interpreter wurde noch nicht aufgerufen. Es muß geprüft werden, 
    //     ob ein Aufruf möglich ist -> checkStart
    //  b) Der Ziel Interpreter ist bereits aufgerufen worden. Es muß geprüft werden, 
    //     ob der Aufruf fertig ist -> checkFinished
    checkStart := FALSE;
    checkFinished := FALSE;
		CASE _m.head.funkst OF
		READY:
      checkStart := TRUE;
		#ifdef LSL_TEST
			IF OtherWorkState = BUSY THEN
			//---------------------------------------------------------------------------
			// Prompt warning if a function in a running interpreter is called.
			//---------------------------------------------------------------------------
			// This might happen if 2 interpreters are calling functions from a 3rd one
			// asynchronously. There is no semaphore or something similar available for
			// interpreter programs by now.
				TRACE_WARN("Reentrance is not supported!");
        LSLCLI_LoaderTracePrint("Reentrance is not supported!", 12);
			END_IF;
		#endif // LSL_TEST
		BUSY:
      checkFinished := TRUE;
		ELSE
			RETURN;		// don't start a program in state ERROR_BUSY
		END_CASE;

		_m.head.funkst := BUSY;

		IF checkStart THEN
			// other interpreter's status
			CASE pHead^.funkst OF
			ERROR:							// Interpreter, LabelNo
				IF pIpr^.SetInstructionToProgStart(uiLabelNo) = BUSY THEN
					IF _m.head.workstate = SINGLESTEP THEN
						pHead^.funkSt := SINGLESTEP;
						_m.head.workstate := READY;
					ELSIF _m.head.workstate = BUSY THEN
						_m.head.workstate := READY;
					ELSE
						pHead^.funkSt := READY;		// started sequential program
					END_IF;

					state := BUSY;		// process the run-command
					
					//Merken vom aufgerufenen Interpreter
					pIpr^.SetCalledFrom(GetInterpreterNumber());
					SetCalledIpr(uiProgNo);

				ELSE
					pHead^.workstate := READY;
					pHead^.funkSt := ERROR;
					state := ERROR;
				END_IF;
			
			SINGLESTEP:
				state := BUSY;
				RETURN;				
			ELSE		// other states of other ipr
				state	:= ERROR;
        IF pHead^.funkSt = BUSY & pHead^.pCode^.opCode = I_RUNPROG & AmICalledFrom(pIpr) THEN
          // ab 02.02.038: 
          // Ein seq. Programmstart wird zugelassen, wenn sich der Ziel Interpreter auf einem 
          // I_RUNPROG befindet und in der Aufrufhierarchie des Aufrufers vorhanden ist.
          IF pIpr^.PushSubStack() THEN
          
            IF pIpr^.SetInstructionToLabel(uiLabelNo) = BUSY THEN
              IF _m.head.workstate = SINGLESTEP THEN
                pHead^.funkSt := SINGLESTEP;
                _m.head.workstate := READY;
              ELSIF _m.head.workstate = BUSY THEN
                _m.head.workstate := READY;
              ELSE
                pHead^.funkSt := READY;		// started sequential program
              END_IF;
          
              state := BUSY;		// process the run-command
              
              //Merken vom aufgerufenen Interpreter
              pIpr^.SetCalledFrom(GetInterpreterNumber());
              SetCalledIpr(uiProgNo);
            END_IF;

          END_IF;
        END_IF;
			END_CASE;

			IF state <> ERROR THEN
				pHead^.workstate := BUSY;
      ELSE
        SetLastError(PROGIP_ERR_RUNPROGFAILED);
			END_IF;
    END_IF;        // checkStart

		IF checkFinished THEN
    
      continueFlag := FALSE;
			CASE pHead^.funkSt OF
			ERROR:		// after program termination
        continueFlag := TRUE;
			ELSE		// still running
        IF pHead^.funkSt = BUSY & pHead^.pCode^.opCode = I_RUNPROG & AmICalledFrom(pIpr) THEN
          // Wenn der andere Interpreter wieder auf einem I_RUNPROG steht und ich  
          // von diesem aufgerufen wurde, dann kann das nur heissen, daß ein vorheriger 
          // sequentieller Programmstart von mir fertig geworden ist.
          // Ausnahme: wenn der funkSt nicht BUSY ist, dann handelt es sich nicht um ein 
          // I_RUNPROG auf das zurückgesprungen wurde, sondern um ein I_RUNPROG im normalen 
          // Programmablauf.
          continueFlag := TRUE;
        END_IF;
			END_CASE;
      
			IF continueFlag THEN
				// Wenn er vom aufgerufenen Programm zurückspringt und im Singlestep war
				// dann soll er in hier weiter steppen 
				IF pHead^.workstate = SINGLESTEP THEN
					state := SINGLESTEP;
				ELSE// sonst soll der Interpreter ganz normal weiterlaufen
					state := READY;
				END_IF;
				pHead^.workstate := READY;
			ELSE		// still running
				state := BUSY;
			END_IF;

    END_IF;        // checkFinished

	ELSE			// invalid program number
		state		:= ERROR;
    SetLastError(PROGIP_ERR_RUNPROGFAILED);
	END_IF;

END_FUNCTION
FUNCTION GLOBAL BaseIp::StopProgram
VAR_INPUT
	uiProgNo		: UINT;
END_VAR
VAR_OUTPUT
	state			: IprStates;
END_VAR
VAR
	pIpr			: ^ProgIp;
	pThis			: ^VirtualBase;
	pRead			: ^void;
	pHead			: ^IprHead;
END_VAR

	_m.head.funkst := BUSY;
	state		:= READY;

	IF uiProgNo < ops.pProg^.uiProgs THEN	// valid program number

		pIpr	:= IprMgr::GetInterpreter(uiProgNo);
		pHead	:= pIpr^.GetHead();

    IF pHead^.funkst <> ERROR THEN
      // other interpreter processes a command
      CASE pHead^.pCode^.opCode OF
  
      I_CMD:
        // other interpreter's status
        CASE pHead^.funkst OF
        BUSY,
        ERROR_BUSY:
          pRead 		:= #pHead^.pCode^.aPara[0];
          pThis		:= ((pRead$^pVoid)^)$^VirtualBase;	// this
  
          pThis^.Kill();		// set RtWork to a kill-routine
          pHead^.funkst := ERROR_BUSY;
        ELSE
          pHead^.funkst := ERROR;
        END_CASE;
  
      I_RUNPROG:
        uiProgNo			:= pHead^.pCode^.aPara[0]$USINT;
        state				:= StopProgram(uiProgNo);
        pHead^.funkst	:= ERROR;	// this ip is also ready
  
      ELSE
        pHead^.funkst	:= ERROR;
      END_CASE;
      
  		// stop the axes if necessary
	  	pIpr^.KillActiveObjects();
      SetLastError(PROGIP_ERR_PROGSTOPPED);
    END_IF;        

		pHead^.workstate := READY;

	ELSE
		state	:= ERROR;	// invalid program number
	END_IF;

END_FUNCTION
// Ops stores, which IP-programs have to be copied from the
// temporary memory to the active working memory after download.
// The bit of the currently loaded program is cleared here.
//
FUNCTION BaseIp::ClearLoadBit
	VAR_INPUT
		nProgNo 	: UDINT;
	END_VAR

	OPS.uiProgsToLoad := OPS.uiProgsToLoad AND NOT (1 SHL nProgNo $ UINT);
  
  if( nProgNo < 32 )then
    uiProgsToLoad[ 0 ] := uiProgsToLoad[ 0 ] and not ( 1 shl nProgNo$uint );
  elsif( nProgNo < 64 )then
    uiProgsToLoad[ 1 ] := uiProgsToLoad[ 1 ] and not ( 1 shl ( nProgNo - 32 )$uint );
  end_if;

END_FUNCTION
// The bit of the currently loaded program is set here. The
// program has to be set as active on command (CHECK_FOR_LOAD)
//[>uiProgNo]	number of program which is to load later on
//
FUNCTION BaseIp::SetLoadBit
	VAR_INPUT
		nProgNo 	: UDINT;
	END_VAR

		// marks program for CHECK_FOR_LOAD
	OPS.uiProgsToLoad	:= OPS.uiProgsToLoad OR (1 SHL nProgNo $ UINT);
	OPS.udProgSize		:= 16#FFFFFFFF;		// .. stops LOAD_PROG
  if( nProgNo < 32 )then
    uiProgsToLoad[ 0 ] := uiProgsToLoad[ 0 ] or ( 1 shl nProgNo$uint );
  elsif( nProgNo < 64 )then
    uiProgsToLoad[ 1 ] := uiProgsToLoad[ 1 ] or ( 1 shl ( nProgNo - 32 )$uint );
  end_if;

END_FUNCTION


FUNCTION BaseIp::IsValidServer
	VAR_INPUT
		pSvr 	: ^SvrCh;
	END_VAR
	VAR_OUTPUT
		isValid 	: BOOL;
	END_VAR
  VAR
	  userDataEnd : ^USINT;
	  userProgEnd : ^USINT;
  END_VAR

	isValid := true;

	userDataEnd := _UserDataPointer + _UserDataSize;
	userProgEnd := _UserProgPointer + _UserProgSize;

	// 1.Bedingung: 
	//	Der Server muß im UserData Bereich liegen
	IF (pSvr$^USINT < _UserDataPointer$^USINT) | (pSvr$^USINT >= userDataEnd) THEN
    isValid := false;
    return;
	END_IF;

	// 2.Bedingung:
	//	Der Zeiger auf die Methodentabelle muss in den UserData Bereich zeigen
	IF (pSvr^.pMeth$^USINT < _UserDataPointer$^USINT) | (pSvr^.pMeth$^USINT >= userDataEnd) THEN
    isValid := false;
    return;
	END_IF;

	// 3.Bedingung:
	//	Die Read- und Write Methode in der Methodentabelle muß im UserCode Bereich liegen
	IF (pSvr^.pMeth^.pRd$^USINT < _UserProgPointer$^USINT) | (pSvr^.pMeth^.pRd$^USINT >= userProgEnd) THEN
    isValid := false;
    return;
	END_IF;
	IF (pSvr^.pMeth^.pWr$^USINT < _UserProgPointer$^USINT) | (pSvr^.pMeth^.pWr$^USINT >= userProgEnd) THEN
    isValid := false;
    return;
	END_IF;

END_FUNCTION


FUNCTION BaseIp::IsValidClient
	VAR_INPUT
		pClt 	: ^CltCh;
	END_VAR
	VAR_OUTPUT
		isValid 	: BOOL;
	END_VAR
  VAR
	  userDataEnd : ^USINT;
  END_VAR

	isValid := true;

	userDataEnd := _UserDataPointer + _UserDataSize;

	// 1.Bedingung: 
	//	Der Client muß im UserData Bereich liegen
	IF (pClt$^USINT < _UserDataPointer$^USINT) | (pClt$^USINT >= userDataEnd) THEN
    isValid := false;
		return;
	END_IF;

	// 2.Bedingung:
	//	Wenn der Client verbunden ist (d.h. pClt^.pCh zeigt nicht auf pClt^.pCmd), 
	//  dann muß pClt^.pCh auf einen Server zeigen.
	IF IsClientConnected(#pClt^.dData) & !!IsValidServer(pClt^.pCh)THEN
    isValid := false;
		return;
	END_IF;

END_FUNCTION

FUNCTION GLOBAL BaseIp::SetLastError
VAR_INPUT
  errorCode : DINT;
END_VAR
  m_lastErrorCode := errorCode;
END_FUNCTION

FUNCTION GLOBAL BaseIp::GetLastError
VAR_OUTPUT
  errorCode : DINT;
END_VAR
  errorCode := m_lastErrorCode;
END_FUNCTION


