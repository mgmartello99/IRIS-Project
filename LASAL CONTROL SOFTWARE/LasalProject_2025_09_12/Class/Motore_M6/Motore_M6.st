//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Motore_M6"
	Revision           = "0.0"
	GUID               = "{14E908F6-79AD-4D6C-9ADA-ED365917C663}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "100 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(720,180)">
	<Channels>
		<Server Name="ClassSvr" GUID="{B7C3A4E3-E1AF-4E8B-B587-88793A145C5D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ErrorState" GUID="{9C664935-2F6E-42F4-B030-CC3B229DC1A8}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="MotoreM6Step" GUID="{025723CB-68BA-428E-B245-29D9D0D7D670}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="s_M6_Coupled" GUID="{6962727B-8629-46E6-880B-F1ED8D31DA05}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="s_M6_Homed" GUID="{8E2571F2-0303-46C5-85BE-AE0F75A4CA5E}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="Comando_M6" Required="true" Internal="false"/>
		<Client Name="M6_LS_1" Required="false" Internal="false"/>
		<Client Name="M6_LS_2" Required="false" Internal="false"/>
		<Client Name="SetPosition_Controller" Required="true" Internal="false"/>
	</Channels>
</Class>
*)
Motore_M6 : CLASS
	TYPE
	  t_sequence_Cmd_motore_M6 :  //! <Type Public="true" Name="t_sequence_Cmd_motore_M6"/>
	  (
	    Cmd_motore_M6_idle,
	    Cmd_motore_M6_homing,
	    Cmd_motore_M6_phasing,
	    Cmd_motore_M6_movement,
	    Cmd_motore_M6_reset,
	    Cmd_motore_M6_stop,
	    Cmd_motore_M6_stopped,
	    Cmd_motore_M6_Error
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	MotoreM6Step 	: SvrCh_t_sequence_Cmd_motore_M6_PTofCls_Motore_M6;
	ErrorState 	: SvrCh__LMCAXIS_ERROR;
	s_M6_Homed 	: SvrCh_DINT;
	s_M6_Coupled 	: SvrCh_DINT;
  //Clients:
	Comando_M6 	: CltChCmd__LMCAxis;
	M6_LS_1 	: CltCh_DINT;
	M6_LS_2 	: CltCh_DINT;
	SetPosition_Controller 	: CltCh_DINT;
  //Variables:
		M6_homed 	: BOOL;
		M6_coupled 	: DINT;
		MotoreM6_Motion_Type 	: BOOL;
		HomingStep 	: DINT;
		v_ErrorState 	: DINT;
		MovementStep 	: DINT;
		v_StartHomingCase 	: DINT;
		v_StartPhasingCase 	: DINT;
		v_StartMovementCase 	: DINT;
		v_M6_LS_1 	: DINT;
		v_M6_LS_2 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetSequenceState
		VAR_INPUT
			Cmd_motore 	: t_sequence_Cmd_motore_M6;
			Motion_type 	: BOOL;
			StartCase 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetHomedState
		VAR_OUTPUT
			Homed 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetCoupledState
		VAR_OUTPUT
			Coupled 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetErrorState
		VAR_OUTPUT
			ErrorState 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL s_M6_Homed::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL s_M6_Coupled::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _LMCAxis


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Motore_M6::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_MOTORE_M6
0$UINT, 0$UINT, (SIZEOF(::Motore_M6))$UINT, 
5$UINT, 4$UINT, 0$UINT, 
TO_UDINT(325692506), "Motore_M6", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Motore_M6.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::Motore_M6.MotoreM6Step.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3917627865), "MotoreM6Step", 
(::Motore_M6.ErrorState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2975757027), "ErrorState", 
(::Motore_M6.s_M6_Homed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3082313045), "s_M6_Homed", 
(::Motore_M6.s_M6_Coupled.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1412653434), "s_M6_Coupled", 
//Clients:
(::Motore_M6.Comando_M6.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1897111888), "Comando_M6", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 114$UINT, 
(::Motore_M6.M6_LS_1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(51724704), "M6_LS_1", 
(::Motore_M6.M6_LS_2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2585530394), "M6_LS_2", 
(::Motore_M6.SetPosition_Controller.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(265130042), "SetPosition_Controller", 
END_FUNCTION


#define USER_CNT_Motore_M6 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Motore_M6] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Motore_M6::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Motore_M6, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_M6_Homed.pMeth			:= StoreMethod( #s_M6_Homed::Read(), #M_WR_DIRECT() );
	IF s_M6_Homed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	s_M6_Coupled.pMeth			:= StoreMethod( #s_M6_Coupled::Read(), #M_WR_DIRECT() );
	IF s_M6_Coupled.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL Motore_M6::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

//M6: Chamber: HA SOLO DUE POSIZIONI.

  v_M6_LS_1:=M6_LS_1.Read(); //COUPLED
  v_M6_LS_2:=M6_LS_2.Read(); //DECOUPLED
  
  s_M6_Coupled.Write(input:=M6_coupled);
  s_M6_Homed.Write(input:=M6_homed);
  
  case MotoreM6Step of
  
//===========================================================================================

    Cmd_motore_M6_idle:
    
    if Comando_M6.AxisError.HwError then
      v_ErrorState:=1;   
      MotoreM6Step:=Cmd_motore_M6_Error;
    end_if;

//===========================================================================================

    Cmd_motore_M6_homing:

    if Comando_M6.AxisError.HwError then
      v_ErrorState:=1;   
      HomingStep:=0;
      MotoreM6Step:=Cmd_motore_M6_Error;
    end_if;

    
    case HomingStep of
    0://idle
      HomingStep:=v_StartHomingCase;
    
    
    5:
      if (Comando_M6.AxisStatus.PowerOn=0) & (Comando_M6.AxisStatus.ReadyToPowerOn) then
        Comando_M6.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY); //può ruotare in entrambi i versi
      elsif Comando_M6.AxisStatus.PowerOn then
        HomingStep:=10;
      end_if;
    
    10:
      if v_M6_LS_2 then //Motore già disaccoppiato. Però per essere già accoppiato dovrebbe essere acceso.
        HomingStep:=14;
      else //il motore può essere accoppiato o in una qualsiasi posizione; è necessario comunque portarlo in pos disaccoppiata.
        HomingStep:=20;
      end_if;
    
    14:
      if v_M6_LS_2 then
        Comando_M6.MoveAbsolute(Position:=150000, Speed:=V_M6, Accel:=A_M6, Decel:=A_M6, Jerk:=J_M6);
        HomingStep:=15;
      end_if;
    
    15:
      if Comando_M6.AxisStatus.InPosition then
        HomingStep:=20;
      end_if;
      
    20:
      Comando_M6.MoveEndless(Speed:=-V_M6, Accel:=-A_M6, Jerk:=-J_M6);
      HomingStep:=30;  
    
    30:
    if v_M6_LS_2 then //quando tocca LS
      Comando_M6.StopMove(Decel:=A_M6, Jerk:=J_M6);
      
      HomingStep:=31;
    end_if;
    
    31:
      Comando_M6.MoveEndless(Speed:=0.5*V_M6, Accel:=0.5*A_M6, Jerk:=0.5*J_M6);
      HomingStep:=32;
      
    32:
      if v_M6_LS_2=0 then
        Comando_M6.StopMove(Decel:=A_M6, Jerk:=J_M6);
        SetPosition_Controller.Write(input:=0);
        HomingStep:=33;
      end_if;
      
    33:
      Comando_M6.MoveRelative(Position:=100000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=0.5*V_M6, Accel:=0.5*A_M6, Decel:=0.5*A_M6, Jerk:=0.5*J_M6);
      HomingStep:=34;
  
    34:
      if Comando_M6.AxisStatus.InPosition then
        HomingStep:=35;
      end_if;

    35:
    Comando_M6.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);//POWER OFF
    IF Comando_M6.AxisStatus.PowerOn=0 THEN
       HomingStep:=40;
    END_IF;
    
    40://Controllo che il motore si sia fermato
    
      if Comando_M6.AxisStatus.Standstill then
        M6_homed:=TRUE;
        M6_coupled:=0;
        MotoreM6Step:=Cmd_motore_M6_idle;
        v_StartHomingCase:=0;
      end_if;
      

    end_case; 
    
//===========================================================================   
    Cmd_motore_M6_movement:

    //I MOVIMENTI CHE PUO' FARE SONO CHE LO PORTA IN ACCOPPIATO/DISACCOPPIATO | 0: DISACCOPPIATO->ACCOPPIATO | 1: ACCOPPIATO->DISACCOPPIATO

    if Comando_M6.AxisError.HwError then
      v_ErrorState:=1;   
      MovementStep:=0;
      MotoreM6Step:=Cmd_motore_M6_Error;
    end_if;
  
    if MotoreM6_Motion_Type=0 then

      if v_M6_LS_1 & M6_coupled=2 then // condizione di M1_Coupled perchè altrimenti quando viene attivato il LS questa condizione viene attivata e il case interno non viene terminato
        M6_coupled:=2;  
      
      elsif M6_coupled=0 | M6_coupled=1 then
      
        
        case MovementStep of
      
          0: //IDLE
            MovementStep:=v_StartMovementCase;
            
        
          10:
            M6_coupled:=1;
            if (Comando_M6.AxisStatus.PowerOn=0) & (Comando_M6.AxisStatus.ReadyToPowerOn) then
              Comando_M6.PowerOn(Mode:=LMCAXIS_MOVE_POS_DIR);
            elsif Comando_M6.AxisStatus.PowerOn then
                MovementStep:=20;
            end_if;
        
          20:
            Comando_M6.MoveEndless(Speed:=1.3*V_M6, Accel:=A_M6, Jerk:=J_M6);
            MovementStep:=30;

          30:
            if v_M6_LS_1 then
               Comando_M6.StopMove(Decel:=A_M6, Jerk:=J_M6);
               MovementStep:=35;
            end_if;
          
          35: 
            MovementStep:=40;
            
          40:
          
            if Comando_M6.AxisStatus.Standstill then
              M6_coupled:=2;
              s_M6_Coupled.Write(input:=M6_coupled);
              MovementStep:=0;
              v_StartMovementCase:=0;
            end_if;

        end_case;
      
      end_if;
    
    elsif MotoreM6_Motion_Type=1 then
    //MOVIMENTO 1: ACCOPPIATO->DISACCOPPIATO
    
      if v_M6_LS_2 & M6_coupled=0 then
        M6_coupled:=0;  
      elsif M6_coupled | M6_coupled=1 then
        
        case MovementStep of
      
        0: //IDLE
          MovementStep:=v_StartMovementCase;
          
        10:
          M6_coupled:=1;
          Comando_M6.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
          if Comando_M6.AxisStatus.PowerOn=0 then
            MovementStep:=15;
          end_if;

        15: //case per accendere il motore nel caso in cui sia spento
        
          if (Comando_M6.AxisStatus.PowerOn=0) & (Comando_M6.AxisStatus.ReadyToPowerOn) then
              Comando_M6.PowerOn(Mode:=_LMCAXIS_MOVEDIRECTION::LMCAXIS_MOVE_ANY_WAY);
          elsif Comando_M6.AxisStatus.PowerOn then
            MovementStep:=20;
          end_if;
        
        20:
          Comando_M6.MoveEndless(Speed:=-V_M6, Accel:=-A_M6, Jerk:=-J_M6);
          MovementStep:=25;
        25:
        
          if v_M6_LS_2 then
            Comando_M6.StopMove(Decel:=-A_M6, Jerk:=-J_M6);
            MovementStep:=26;
          end_if;
        
        26:

          Comando_M6.MoveEndless(Speed:=0.5*V_M6, Accel:=0.5*A_M6, Jerk:=0.5*J_M6);
          MovementStep:=27;
      
        27:
          if v_M6_LS_2=0 then
            Comando_M6.StopMove(Decel:=A_M6, Jerk:=J_M6);
            SetPosition_Controller.Write(input:=0);
            MovementStep:=28;
          end_if;
          
        28:
          Comando_M6.MoveRelative(Position:=100000, Mode:=LMCAXIS_MOVE_RELATIVE_TO_POSITION, Speed:=0.5*V_M6, Accel:=0.5*A_M6, Decel:=0.5*A_M6, Jerk:=0.5*J_M6);
          MovementStep:=33;
  
          
        33:
        
          if Comando_M6.AxisStatus.InPosition then
            MovementStep:=35;
          end_if;  
          
        35: 
           Comando_M6.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
           MovementStep:=40;
            
        40:
          
          if Comando_M6.AxisStatus.Standstill & Comando_M6.AxisStatus.PowerOn=0 then          
            M6_coupled:=0;
            s_M6_Coupled.Write(input:=M6_coupled);
            MovementStep:=0;
            v_StartMovementCase:=0;
          end_if;
          
          
        end_case;
      
      end_if;
    
    else
      //errore
      MotoreM6Step:=Cmd_motore_M6_reset;
    
    end_if;
    
//===============================================================================

    Cmd_motore_M6_Error:
    
      ErrorState:=Comando_M6.AxisError; //AGGIORNAMENTO SERVER
      MotoreM6Step:=Cmd_motore_M6_stop;

//===============================================================================

    Cmd_motore_M6_stop:
      
      if Comando_M6.AxisStatus.Standstill & Comando_M6.AxisStatus.PowerOn=0 then
        MotoreM6Step:=Cmd_motore_M6_stopped;
      else
        Comando_M6.QuickStop(Decel:=1000000);//se asse in errore non esegue neppure l'operazione perchè spento (e in errore)
        Comando_M6.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
      end_if;

//===============================================================================

    Cmd_motore_M6_stopped:
    //ATTESA RESET
    
//===============================================================================
    Cmd_motore_M6_reset:
    
      Comando_M6.QuitError();
      M6_homed:=FALSE;
      v_ErrorState:=0;
      
      if Comando_M6.AxisStatus.FiltRdy then
        MotoreM6Step:=Cmd_motore_M6_idle;
      end_if;

      M6_coupled:=0;
      MotoreM6_Motion_Type:=FALSE;

      HomingStep:=0;
      MovementStep:=0;

      v_M6_LS_1:=0;
      v_M6_LS_2:=0;

      v_StartHomingCase:=0;
      v_StartPhasingCase:=0;
      v_StartMovementCase:=0;

v_ErrorState:=0;
//===============================================================================

  end_case;

	state := READY;
  
END_FUNCTION


FUNCTION GLOBAL Motore_M6::SetSequenceState
	VAR_INPUT
		Cmd_motore 	: t_sequence_Cmd_motore_M6;
		Motion_type 	: BOOL;
		StartCase 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  if Cmd_motore=Cmd_motore_M6_homing then
    v_StartHomingCase:=StartCase;
  elsif Cmd_motore=Cmd_motore_M6_phasing then
    v_StartPhasingCase:=StartCase;
  elsif Cmd_motore=Cmd_motore_M6_movement then
    v_StartMovementCase:=StartCase;
  end_if;


  MotoreM6Step:=Cmd_motore;
  MotoreM6_Motion_Type:=Motion_type;
  retcode:=true;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M6::Init
M6_homed:=FALSE;
M6_coupled:=FALSE;
MotoreM6_Motion_Type:=FALSE;

HomingStep:=0;
MovementStep:=0;

v_M6_LS_1:=0;
v_M6_LS_2:=0;

v_StartHomingCase:=0;
v_StartPhasingCase:=0;
v_StartMovementCase:=0;

v_ErrorState:=0;

END_FUNCTION


FUNCTION GLOBAL Motore_M6::GetHomedState
	VAR_OUTPUT
		Homed 	: BOOL;
	END_VAR
  
  Homed:=M6_homed;
END_FUNCTION


FUNCTION GLOBAL Motore_M6::GetCoupledState
	VAR_OUTPUT
		Coupled 	: DINT;
	END_VAR
  Coupled:=M6_coupled;
END_FUNCTION


FUNCTION GLOBAL Motore_M6::GetErrorState
	VAR_OUTPUT
		ErrorState 	: DINT;
	END_VAR
  ErrorState:=v_ErrorState;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M6::s_M6_Homed::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	output := s_M6_Homed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Motore_M6::s_M6_Coupled::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	output := s_M6_Coupled;

END_FUNCTION
