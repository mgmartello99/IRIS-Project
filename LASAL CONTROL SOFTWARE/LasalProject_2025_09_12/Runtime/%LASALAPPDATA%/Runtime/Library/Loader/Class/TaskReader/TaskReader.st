//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "TaskReader"
	Revision           = "0.0"
	GUID               = "{417BAE88-835B-4422-BD32-05880A97845B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
	</Channels>
	<Network Name="TaskReader">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{EDF74451-0DCF-4BCD-BB6E-D2D573DE44F1}"
				Class      = "ObjectReader"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Server0"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using ObjectReader

TaskReader : CLASS
: ObjectReader
  //Servers:
  //Clients:
  //Variables:
		pObjRd 	: ^ObjectReader;
		pObjRd2 	: ^ObjectReader;
  //Functions:
	
	FUNCTION GLOBAL ReadTasks
		VAR_INPUT
			pObjRd 	: ^ObjectReader;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION CreateTask
		VAR_INPUT
			pThis 	: ^VirtualBase;
			udRate 	: UDINT;
			dPrio 	: DINT;
			bMode 	: UDINT;
			core 	: DINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION CreateTaskOff
		VAR_INPUT
			bMode 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION CreateTaskObjNo
		VAR_INPUT
			bMode 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL BuildUpdateLists
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL InitModule;
	
	FUNCTION GLOBAL ReadTaskSlots
		VAR_INPUT
			pObjRd 	: ^ObjectReader;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GetSlotTaskObjNo
		VAR_INPUT
			udMode 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GetSlotTaskOff
		VAR_INPUT
			udMode 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION AddParamToTask
		VAR_INPUT
			pThis 	: ^VirtualBase;
			udParam 	: UDINT;
			udMode 	: UDINT;
			udParamType 	: DINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SearchObjekt
		VAR_INPUT
			pList 	: ^void;
			pThis 	: ^void;
		END_VAR
		VAR_OUTPUT
			pObjRet 	: ^OBJ_PARAM;
		END_VAR;
	
	FUNCTION GLOBAL FindTasks2
		VAR_INPUT
			pObjRd 	: ^ObjectReader;
		END_VAR
		VAR_OUTPUT
			found 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SkipTasks2
		VAR_INPUT
			pObjRd 	: ^ObjectReader;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB TaskReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_TASKREADER
0$UINT, 0$UINT, (SIZEOF(::TaskReader))$UINT, 
0$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2319213503), "TaskReader", //Class
TO_UDINT(1461090386), "ObjectReader", 0$UINT, 1$UINT, //Baseclass
//Servers:
//Clients:
END_FUNCTION


#define USER_CNT_TaskReader 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_TaskReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION TaskReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code	:= ObjectReader::@STD();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include <LSL_StiTask.h>
#include ".\RTOS_PrivHeader.h"
#include ".\RTOS_Mem.h"

#define OS_AddCyObj(p0,p1,p2,p3) _LSL_POS^.piTask^.AddCyclicObject $ P_AddObject(p0,p1,p2,p3)
#define OS_AddCyObjEx(p0,p1,p2,p3,p4) _LSL_POS^.piTask^.AddCyclicObjectEx $ P_AddObjectEx(p0,p1,p2,p3,p4)
#define OS_AddRtObj(p0,p1,p2,p3) _LSL_POS^.piTask^.AddRealTimeObject $ P_AddObject(p0,p1,p2,p3)
#define OS_AddRtObjEx(p0,p1,p2,p3,p4) _LSL_POS^.piTask^.AddRealTimeObjectEx $ P_AddObjectEx(p0,p1,p2,p3,p4)
//#define OS_ITASK_VERSION         _LSL_POS^.piTask^.udVersion $ UDINT

//	keywords for task lists
//#define _K_CYCLIC			  0	// add object to cyclic task list
//#define	_K_REAL				  1	// add object to realtime tasks
//#define _K_BACKGROUND		2	// add object to background task list

#define CYCLIC_TASK_ALWAYS	16#FFFFFFFF
#define TASK_OFF			0

// Parameter welcher dem Task hinzugefügt werden soll
#define PARAM_TASK_SLOT     1


FUNCTION GLOBAL _GetClsList
VAR_OUTPUT
	pCls		: ^CLSHDR;
END_VAR;

TYPE

  (* 
    Struktur, mit der die OS_AddCyObj/OS_AddRtObj Parameter zwischengespeichert 
    werden können. 
   *)
  OBJ_PARAM : STRUCT
    // die Taskpriorität
    dPrio	: DINT; 
    // die eigentlichen OS_AddCyObj/OS_AddRtObj Parameter
  	pObj	: pVoid;
  	udMode	: UDINT;
  	udTime	: UDINT;
    udSlot  : UDINT;
    core : DINT;
  END_STRUCT;
  
  (* Liste (dynamisches erweiterbar) mit OBJ_PARAM *)
  OBJ_PARAM_LIST : STRUCT
// Anzahl der Elemente die auf einmal allokiert werden, wenn die Liste vergrössert wird
#define OBJ_PARAM_LIST_CHUNK      300
    nbrAllocated : UDINT;
    nbrUsed : UDINT;
    el : ARRAY[0..0] OF OBJ_PARAM;
  END_STRUCT;

  SORT_PARAM : STRUCT
    li : DINT;
    re : DINT;
  END_STRUCT;

  SORT_STACK : STRUCT
    nbrAllocated : UDINT;
    nbrUsed : UDINT;
    el : ARRAY[0..0] OF SORT_PARAM;
  END_STRUCT;

END_TYPE

VAR_PRIVATE
  pCyObjList : pVoid;
  pCyObjList_undef : pVoid; // Liste mit Taskpriorität -1
  pRtObjList : pVoid;
  pRtObjList_undef : pVoid; // Liste mit Taskpriorität -1

  pSortStack : ^SORT_STACK;

  g_xPrio : DINT;
 #ifndef OTTOSPEED 
  g_TempObjParam : OBJ_PARAM;
 #endif 
  g_pSortList : ^OBJ_PARAM_LIST;
END_VAR
VAR_GLOBAL
//#define SORT_TEST
#ifdef SORT_TEST
  LDR_maxSortCallDepth : UDINT;// nur zur Kontrolle der Anzahl der Rekursionen in SortObjParamList
  LDR_timeStart : UDINT;
  LDR_timeEnd : UDINT;
  LDR_timeDiff : UDINT;
#endif  
END_VAR

FUNCTION AddObjDelayed
	VAR_INPUT
		ppObjList 	: ^pVoid;
    dPrio	: DINT; 
		pObj 	: pVoid;
		udMode 	: UDINT;
		udTime 	: UDINT;
    core : DINT;
	END_VAR
	VAR_OUTPUT
		ok 	: UDINT;
	END_VAR;

FUNCTION SortObjParamList
  VAR_INPUT
    l : DINT;
    r : DINT;
  #ifdef SORT_TEST
    callDepth : UDINT;
  #endif
  END_VAR;

FUNCTION SortObjParamList_NR
  VAR_INPUT
    l : DINT;
    r : DINT;
  END_VAR
  VAR_OUTPUT
    ok : UDINT;
  END_VAR;

(* Unit-Tests der OBJ_PARAM Liste *)
#ifdef SORT_TEST
FUNCTION TestAddObjDelayed
  VAR
    i : DINT;
    dPrio : DINT;
    oldPrio : DINT;
    rc : UDINT;
  END_VAR

  // Objekte einfügen
  FOR i := 0 TO 30000 DO
    IF i < 10000 THEN
      // richtige Reihenfolge
      dPrio := i;
    ELSIF i < 20000 THEN
      // beliebige Reihenfolge
      dPrio := i MOD 10;
    ELSE
      // umgedrehte Reihenfolge
      dPrio := 30000 - i;
    END_IF;
    rc := AddObjDelayed(#pCyObjList, dPrio, pObj := NIL, udMode := 0, udTime := 0);
    IF !!rc THEN
      (0$^UDINT)^ := 0;
    END_IF;
  END_FOR;

  g_pSortList := pCyObjList$^OBJ_PARAM_LIST;
  
  IF g_pSortList^.nbrUsed <> 30001 THEN
    (0$^UDINT)^ := 0;
  END_IF;

  // sortieren
  LDR_timeStart := OPS.tAbsolute;
#if 0
  SortObjParamList(0, g_pSortList^.nbrUsed$DINT - 1, 1);
  // Anm:
  // Die Aufruftiefe beim Sortieren (Variable LDR_maxSortCallDepth) erreicht hier 
  // den Wert 1865.
  // gemessene Zeiten: C_IPC: 0.8 Sek. für 30000 Einträge
#else  
  IF !!SortObjParamList_NR(0, g_pSortList^.nbrUsed$DINT - 1) THEN
    (0$^UDINT)^ := 0;
  END_IF;
  // gemessene Zeiten: C_IPC: 0.8 Sek. für 30000 Einträge
#endif  
  LDR_timeEnd := OPS.tAbsolute;
  LDR_timeDiff := LDR_timeEnd - LDR_timeStart;

  // Reihenfolge prüfen
  oldPrio := g_pSortList^.el[0].dPrio;
  FOR i := 1 TO 30000 DO
    dPrio := g_pSortList^.el[i].dPrio;
    IF dPrio < oldPrio THEN
      (0$^UDINT)^ := 0;
    END_IF;
    oldPrio := dPrio;
  END_FOR;

  IF pCyObjList <> NIL THEN
    _free(pCyObjList);
    pCyObjList := NIL;
  END_IF;

  IF pSortStack <> NIL THEN
    _free(pSortStack);
    pSortStack := NIL;
  END_IF;

END_FUNCTION
#endif

FUNCTION GLOBAL TaskReader::InitModule
  pCyObjList := NIL;
  pCyObjList_undef := NIL;
  pRtObjList := NIL;
  pRtObjList_undef := NIL;

  pSortStack := NIL;

#ifdef SORT_TEST
  LDR_maxSortCallDepth := 0;
  //Unit-Test
  TestAddObjDelayed();
#endif  
END_FUNCTION

(*
  Allokiert einen OBJ_PARAM Eintrag in der Liste
 *)
FUNCTION AllocObjParam
	VAR_INPUT
		ppObjList 	: ^pVoid;
  END_VAR
  VAR
    pObjList : ^OBJ_PARAM_LIST;
    nbrAlloc : UDINT;
  END_VAR  

  IF ppObjList^ = NIL THEN
    // erster Block
    nbrAlloc := OBJ_PARAM_LIST_CHUNK;
    ppObjList^ := _alloc(OBJ_PARAM_LIST.el + nbrAlloc * SIZEOF(OBJ_PARAM));
    IF ppObjList^ = NIL THEN
      RETURN;
    END_IF;
    pObjList := ppObjList^$^OBJ_PARAM_LIST;
    pObjList^.nbrAllocated := nbrAlloc;
    pObjList^.nbrUsed := 0;
  ELSE
    // Block vergrössern
    pObjList := ppObjList^$^OBJ_PARAM_LIST;
    IF pObjList^.nbrAllocated = pObjList^.nbrUsed THEN
      nbrAlloc := pObjList^.nbrAllocated + OBJ_PARAM_LIST_CHUNK;
      ppObjList^ := _realloc(pObjList, OBJ_PARAM_LIST.el + nbrAlloc * SIZEOF(OBJ_PARAM));
      IF ppObjList^ = NIL THEN
        RETURN;
      END_IF;
      pObjList := ppObjList^$^OBJ_PARAM_LIST;
      pObjList^.nbrAllocated := nbrAlloc;
    END_IF;
  END_IF;
 
END_FUNCTION

(*
  Nimmt die Parameter für OS_AddCyObj/OS_AddRtObj entgegen und speichert sie in einer 
  Liste, damit zu einem späteren Zeitpunkt die Liste nach Taskpriorität sortiert und in 
  dieser Reihenfolge ans Betriebssystem mittels OS_AddCyObj/OS_AddRtObj Aufruf übergeben 
  werden kann.
  
  Anm:
  Der Parameter udPhase wird nicht gespeichert, weil für diese Fälle immer der 
  Wert TASK_SCAN verwendet wird.
 *)
FUNCTION AddObjDelayed
	VAR_INPUT
		ppObjList 	: ^pVoid;
    dPrio	: DINT; 
		pObj 	: pVoid;
		udMode 	: UDINT;
		udTime 	: UDINT;
    core : DINT;
	END_VAR
	VAR_OUTPUT
		ok 	: UDINT;
	END_VAR
  VAR
    pObjList : ^OBJ_PARAM_LIST;
    pObjParam : ^OBJ_PARAM;
  END_VAR  
  
  ok := 0;
  
  AllocObjParam(ppObjList);
  IF ppObjList^ = NIL THEN
    RETURN;
  END_IF;
 
  pObjList := ppObjList^$^OBJ_PARAM_LIST;
  
  pObjParam := #pObjList^.el[pObjList^.nbrUsed];
  pObjParam^.dPrio  := dPrio;
  pObjParam^.pObj   := pObj;
  pObjParam^.udMode := udMode;
  pObjParam^.udTime := udTime;
  pObjParam^.udSlot := 0;
  pObjParam^.core := core;
  pObjList^.nbrUsed += 1;
  
  ok := 1;
 
END_FUNCTION 

(*
  Sortiert eine OBJ_PARAM_LIST nach Taskpriorität.
  Die zu sortierende Liste wird in der globalen Variablen g_pSortList angegeben, damit 
  wird die Stackbelastung reduziert, weil hier ein rekursiver Aufruf der Funktion 
  verwendet wird.

  Diese Version verwendet Rekursion, das kann zu einem Stackoverflow führen, 
  daher wird diese Funktion durch SortObjParamList_NR ersetzt !
 *)
#if 0
FUNCTION SortObjParamList
  VAR_INPUT
    l : DINT;
    r : DINT;
  #ifdef SORT_TEST
    callDepth : UDINT;
  #endif
  END_VAR
  VAR
    i : DINT;
    j : DINT;
  END_VAR

#ifdef SORT_TEST
  IF callDepth > LDR_maxSortCallDepth THEN
    LDR_maxSortCallDepth := callDepth;
  END_IF;
#endif

  IF l >= r THEN
    RETURN;
  END_IF;

  i := l;
  j := r;
  g_xPrio := g_pSortList^.el[(l + r) / 2].dPrio;
  
  REPEAT
  
    WHILE g_pSortList^.el[i].dPrio < g_xPrio DO
      i += 1;
    END_WHILE;
    WHILE g_xPrio < g_pSortList^.el[j].dPrio DO
      j -= 1;
    END_WHILE;
    
    IF i < j THEN
      
      
     #ifdef OTTOSPEED 
      _memswap(#g_pSortList^.el[i], #g_pSortList^.el[j], SIZEOF(OBJ_PARAM));
     #else
      _memcpy(#g_TempObjParam, #g_pSortList^.el[i], SIZEOF(OBJ_PARAM));
      _memcpy(#g_pSortList^.el[i], #g_pSortList^.el[j], SIZEOF(OBJ_PARAM));
      _memcpy(#g_pSortList^.el[j], #g_TempObjParam, SIZEOF(OBJ_PARAM));
     #endif
     
      i += 1;
      j -= 1;
      
    ELSIF i = j THEN

      i += 1;
      j -= 1;

    END_IF;
    
  UNTIL i > j END_REPEAT;

  IF l < j THEN
#ifdef SORT_TEST
    SortObjParamList(l, j, callDepth + 1);
#else
    SortObjParamList(l, j);
#endif
  END_IF;
  
  IF i < r THEN
#ifdef SORT_TEST
    SortObjParamList(i, r, callDepth + 1);
#else
    SortObjParamList(i, r);
#endif
  END_IF;

END_FUNCTION
#endif
  
(*
  Legt die Parameter l und r auf den am Heap allokierten Stack.
  Wird für den rekursionsfreien Sortieralgorithmus benötigt.
 *)
FUNCTION SortPush
  VAR_INPUT
    l : DINT;
    r : DINT;
  END_VAR
  VAR_OUTPUT
    ok : UDINT;
  END_VAR

  ok := 0;

  IF pSortStack = NIL THEN
    pSortStack := _alloc(SIZEOF(SORT_STACK))$^SORT_STACK;
    IF pSortStack = NIL THEN
      RETURN;
    END_IF;
    _memset(pSortStack, 0, SIZEOF(SORT_STACK));
  END_IF;

  IF pSortStack^.nbrUsed = pSortStack^.nbrAllocated THEN
    pSortStack^.nbrAllocated += 300;
    pSortStack := _realloc(pSortStack, SORT_STACK.el + pSortStack^.nbrAllocated * SIZEOF(SORT_PARAM))$^SORT_STACK;
    IF pSortStack = NIL THEN
      RETURN;
    END_IF;
  END_IF;

  pSortStack^.el[pSortStack^.nbrUsed].li := l;
  pSortStack^.el[pSortStack^.nbrUsed].re := r;

  pSortStack^.nbrUsed += 1;
  
  ok := 1;
  
END_FUNCTION

(*
  Holt die Parameter l und r von dem auf dem Heap allokierten Stack.
  Wird für den rekursionsfreien Sortieralgorithmus benötigt.
 *)
FUNCTION SortPop
  VAR_INPUT
    pl : ^DINT;
    pr : ^DINT;
  END_VAR
  VAR_OUTPUT
    ok : UDINT;
  END_VAR

  ok := 0;

  IF pSortStack = NIL | pSortStack^.nbrUsed = 0 THEN
    RETURN;
  END_IF;
  
  pSortStack^.nbrUsed -= 1;
  
  pl^ := pSortStack^.el[pSortStack^.nbrUsed].li;
  pr^ := pSortStack^.el[pSortStack^.nbrUsed].re;
  
  ok := 1;

END_FUNCTION

(*
  Sortiert eine OBJ_PARAM_LIST nach Taskpriorität.
  Die zu sortierende Liste wird in der globalen Variablen g_pSortList angegeben.
  
  Diese Version verwendet keine Rekursion
 *)
FUNCTION SortObjParamList_NR
  VAR_INPUT
    l : DINT;
    r : DINT;
  END_VAR
  VAR_OUTPUT
    ok : UDINT;
  END_VAR
  VAR
    i : DINT;
    j : DINT;
  END_VAR

  ok := 0;
  
  IF !!SortPush(l, r) THEN
    RETURN;
  END_IF;
  
  WHILE SortPop(#l, #r) DO
    IF l >= r THEN
      GOTO Continue_While;
    END_IF;
  
    i := l;
    j := r;
    g_xPrio := g_pSortList^.el[(l + r) / 2].dPrio;
    
    REPEAT
    
      WHILE g_pSortList^.el[i].dPrio < g_xPrio DO
        i += 1;
      END_WHILE;
      WHILE g_xPrio < g_pSortList^.el[j].dPrio DO
        j -= 1;
      END_WHILE;
      
      IF i < j THEN
        
       #ifdef OTTOSPEED 
        _memswap(#g_pSortList^.el[i], #g_pSortList^.el[j], SIZEOF(OBJ_PARAM));
       #else
        _memcpy(#g_TempObjParam, #g_pSortList^.el[i], SIZEOF(OBJ_PARAM));
        _memcpy(#g_pSortList^.el[i], #g_pSortList^.el[j], SIZEOF(OBJ_PARAM));
        _memcpy(#g_pSortList^.el[j], #g_TempObjParam, SIZEOF(OBJ_PARAM));
       #endif
       
        i += 1;
        j -= 1;
        
      ELSIF i = j THEN
  
        i += 1;
        j -= 1;
  
      END_IF;
      
    UNTIL i > j END_REPEAT;
  
    IF l < j THEN
      IF !!SortPush(l, j) THEN
        RETURN;
      END_IF;
    END_IF;
    
    IF i < r THEN
      IF !!SortPush(i, r) THEN
        RETURN;
      END_IF;
    END_IF;
    
Continue_While:    

  END_WHILE;

  ok := 1;

END_FUNCTION

FUNCTION Get_ITASK_Version
VAR_OUTPUT
	version : UDINT;
END_VAR
  
  // Anm.: Beim Salamander darf das udVersion Element aus der LSL_ITASK Struktur 
  // (Makro OS_ITASK_VERSION) erst ab 09.03.080 interpretiert werden, weil sonst 
  // keine Versionsnummer dahintersteckt, sondern ein Funktionszeiger auf eine Dummy-Funktion.
  // Die Versionen im Salamander, bei denen udVersion gültig ist:
  //  9.3 er Versionen:   ab 09.03.080
  //  9.2 er Versionen:   ab 09.03.049
  IF _RtOSVersion < 16#9000 | _RtOSVersion >= 16#9350 THEN
    version := OS_ITASK_VERSION;
  ELSIF _RtOSVersion < 16#9300 & _RtOSVersion >= 16#9231 THEN
    version := OS_ITASK_VERSION;
  ELSE
    version := 0;
  END_IF;
  
END_FUNCTION

#ifdef OTTOSPEED

FUNCTION AddCyRtObj
  VAR_INPUT 
    ptos : ^OBJ_PARAM_LIST;
    isRt : udint;
    sort : udint;
  END_VAR
  VAR_OUTPUT
    retcode : udint;
  END_VAR
  VAR
  	pobj : ^OBJ_PARAM;
    no : udint;
  END_VAR

  retcode     := 0;
  g_pSortList := ptos;
    
  if(sort) then
    // sortieren (die Liste mit Taskpriorität -1 wird nicht sortiert !)
    if !!SortObjParamList_NR(0, g_pSortList^.nbrUsed$DINT - 1) then
      return;
    end_if;
  end_if;
  
  no   := g_pSortList^.nbrUsed;
  pobj := #g_pSortList^.el[0];
    
  if(isRt) then
    while no DO
      if(OS_AddRtObj(pobj^.pObj, pobj^.udMode, pobj^.udTime, TASK_SCAN) = 0) then
        return;
      end_if;
      no   -= 1;
      pobj += sizeof(OBJ_PARAM);
    end_while;
  else
    while no DO
      if(OS_AddCyObj(pobj^.pObj, pobj^.udMode, pobj^.udTime, TASK_SCAN) = 0) then
        return;
      end_if;
      no   -= 1;
      pobj += sizeof(OBJ_PARAM);
    end_while;
  end_if;

  retcode := 1;

END_FUNCTION

FUNCTION GLOBAL TaskReader_ProcessStoredObjs
  VAR_OUTPUT
    ok : UDINT;
  END_VAR
  
  ok := 0;
   
  if(pCyObjList <> NIL) then
    if(AddCyRtObj(pCyObjList$^OBJ_PARAM_LIST, 0, 1) = 0) then
      return;
    end_if;
    _free(pCyObjList);
    pCyObjList := NIL;
  end_if;
  
  if(pRtObjList <> NIL) then
    if(AddCyRtObj(pRtObjList$^OBJ_PARAM_LIST, 1, 1) = 0) then
      return;
    end_if;
    _free(pRtObjList);
    pRtObjList := NIL;
  end_if;
  
  if(pCyObjList_undef <> NIL) then
    if(AddCyRtObj(pCyObjList_undef$^OBJ_PARAM_LIST, 0, 0) = 0) then
      return;
    end_if;
    _free(pCyObjList_undef);
    pCyObjList_undef := NIL;
  end_if;
  
  if(pRtObjList_undef <> NIL) then
    if(AddCyRtObj(pRtObjList_undef$^OBJ_PARAM_LIST, 1, 0) = 0) then
      return;
    end_if;
    _free(pRtObjList_undef);
    pRtObjList_undef := NIL;
  end_if;

  if(pSortStack <> NIL) then
    _free(pSortStack);
    pSortStack := NIL;
  end_if;

  ok := 1;
  
END_FUNCTION



#else 
 
(*
  Arbeitet die mit AddObjDelayed gespeicherten Informationen ab. 
  Die Einträge in der Liste werden nach Taskpriorität sortiert und danach wird für 
  jeden Eintrag OS_AddCyObj/OS_AddRtObj aufgerufen.
 *)
FUNCTION GLOBAL TaskReader_ProcessStoredObjs
  VAR_OUTPUT
    ok : UDINT;
  END_VAR
  VAR
    i, j : UDINT;
    rc : UDINT;
    pObjParam : ^OBJ_PARAM;
    sObjParamList : ITASK_PARAMLIST;
  END_VAR
  
  ok := 0;
  
  FOR i := 0 TO 3 DO
    CASE i OF
    0: g_pSortList := pCyObjList$^OBJ_PARAM_LIST;
    1: g_pSortList := pRtObjList$^OBJ_PARAM_LIST;
    2: g_pSortList := pCyObjList_undef$^OBJ_PARAM_LIST;
    3: g_pSortList := pRtObjList_undef$^OBJ_PARAM_LIST;
    END_CASE;
    
    // sortieren (die Liste mit Taskpriorität -1 wird nicht sortiert !)
    IF i < 2 THEN
      IF g_pSortList <> NIL THEN
#if 0
  #ifdef SORT_TEST
        SortObjParamList(0, g_pSortList^.nbrUsed$DINT - 1, 1);
  #else
        SortObjParamList(0, g_pSortList^.nbrUsed$DINT - 1);
  #endif
#else
        IF !!SortObjParamList_NR(0, g_pSortList^.nbrUsed$DINT - 1) THEN
          RETURN;
        END_IF;
#endif        
      END_IF;
    END_IF;
    
    // für jedes Listenelement jetzt OS_AddCyObj/OS_AddRtObj aufrufen
    IF g_pSortList <> NIL THEN
      FOR j := 0 TO g_pSortList^.nbrUsed - 1 DO
        pObjParam := #g_pSortList^.el[j];
        // RTK-Version unterstützt Timeslots und neue Interfacefunktion
        if (_RtOSVersion < 16#9000) & (OS_ITASK_VERSION >= 0x10) then
          sObjParamList.udVersion := 0x12;
          IF i MOD 2 = 0 THEN          
            sObjParamList.udTask  := _K_CYCLIC;
          else
            sObjParamList.udTask  := _K_REAL;
          end_if;
          sObjParamList.pObj    := pObjParam^.pObj;
          sObjParamList.pParam  := pObjParam^.pObj;
          sObjParamList.udIsFnc := 0;
          sObjParamList.udMode  := pObjParam^.udMode;
          sObjParamList.udTime  := pObjParam^.udTime;
          sObjParamList.udPhase := TASK_SCAN;
          sObjParamList.udSlot  := pObjParam^.udSlot;
          // ab udVersion 0x12
          sObjParamList.core    := pObjParam^.core;
          rc := OS_AddTask(#sObjParamList);          
        else
          IF i MOD 2 = 0 THEN          
            IF Get_ITASK_Version() >= 16#12 & _LSL_POS^.piTask^.AddCyclicObjectEx THEN
              rc := OS_AddCyObjEx(pObjParam^.pObj, pObjParam^.udMode, pObjParam^.udTime, TASK_SCAN, pObjParam^.core);          
            ELSE
              rc := OS_AddCyObj(pObjParam^.pObj, pObjParam^.udMode, pObjParam^.udTime, TASK_SCAN);          
            END_IF;
          ELSE
            IF Get_ITASK_Version() >= 16#12 & _LSL_POS^.piTask^.AddRealTimeObjectEx THEN
              rc := OS_AddRtObjEx(pObjParam^.pObj, pObjParam^.udMode, pObjParam^.udTime, TASK_SCAN, pObjParam^.core);
            ELSE
              rc := OS_AddRtObj(pObjParam^.pObj, pObjParam^.udMode, pObjParam^.udTime, TASK_SCAN);
            END_IF;
          END_IF;
        end_if;
        IF !!rc THEN
          RETURN;
        END_IF;
      END_FOR;
      _free(g_pSortList);
    END_IF;
  END_FOR;
  
  // Liste leeren
  pCyObjList := NIL;
  pCyObjList_undef := NIL;
  pRtObjList := NIL;
  pRtObjList_undef := NIL;

  IF pSortStack <> NIL THEN
    _free(pSortStack);
    pSortStack := NIL;
  END_IF;

  ok := 1;
  
END_FUNCTION
#endif

// Positioniert auf den 2.Teil der Taskkonfiguration
FUNCTION GLOBAL TaskReader::FindTasks2
VAR_INPUT
	pObjRd		: ^ObjectReader;
END_VAR
VAR_OUTPUT
  found : BOOL;
END_VAR

  WHILE pObjRd^.pTable < pObjRd^.pTableEnd DO
    IF (pObjRd^.pTable + 0)^$UDINT = 16#5C5C5C5C &      // "\\\\"
       (pObjRd^.pTable + 4)^$UDINT = 16#4B534154 &      // "TASK"
       (pObjRd^.pTable + 8)^$UDINT = 16#20203253 THEN   // "S2  "
      pObjRd^.pTable += 12;
      found := TRUE;
      RETURN;
    END_IF;
    pObjRd^.pTable += 1;
  END_WHILE;
  
  found := FALSE;
  
END_FUNCTION

// Überspringt den 2.Teil der Taskkonfiguration
FUNCTION GLOBAL TaskReader::SkipTasks2
VAR_INPUT
	pObjRd		: ^ObjectReader;
END_VAR
VAR
	v : UDINT;
END_VAR

  pObjRd^.pTable += 12; // "\\\\TASKS2  "

	v := pObjRd^.GetCount();     // TaskOff (_K_REAL)
  pObjRd^.SkipDints(1 * v);    //    coreNbr
	v := pObjRd^.GetCount();     // TaskObjNo (_K_REAL)
  pObjRd^.SkipDints(1 * v);    //    coreNbr

	v := pObjRd^.GetCount();     // TaskOff (_K_CYCLIC)
  pObjRd^.SkipDints(1 * v);    //    coreNbr
	v := pObjRd^.GetCount();     // TaskObjNo (_K_CYCLIC)
  pObjRd^.SkipDints(1 * v);    //    coreNbr

	v := pObjRd^.GetCount();     // TaskOff (_K_BACKGROUND)
  pObjRd^.SkipDints(1 * v);    //    coreNbr
	v := pObjRd^.GetCount();     // TaskObjNo (_K_BACKGROUND)
  pObjRd^.SkipDints(1 * v);    //    coreNbr

END_FUNCTION

//[#DEUTSCH]
//Liest alle Tasks für einen ON aus
FUNCTION GLOBAL TaskReader::ReadTasks
VAR_INPUT
	pObjRd		: ^ObjectReader;
END_VAR
VAR_OUTPUT
	ok		: BOOL;
END_VAR


	this^.pObjRd	:= pObjRd;
  
  // Eine Kopie des ObjektReaders erstellen, die dann auf den 2.Teil der Taskkonfiguration 
  // positioniert wird.
  pObjRd2 := LDR_alloc_descr(sizeof(ObjectReader)) $ ^ObjectReader;
  _memcpy(pObjRd2, this^.pObjRd, sizeof(ObjectReader));
  IF !!FindTasks2(pObjRd2) THEN
    _free(pObjRd2);
    pObjRd2 := NIL;
  END_IF;

	ok	:=	CreateTaskOff	  (_K_REAL) &
          CreateTaskObjNo	(_K_REAL) &
          CreateTaskOff	  (_K_CYCLIC) &
          CreateTaskObjNo	(_K_CYCLIC) &
          CreateTaskOff	  (_K_BACKGROUND) &
          CreateTaskObjNo	(_K_BACKGROUND);
  
  IF pObjRd2 <> NIL THEN
    _free(pObjRd2);
    pObjRd2 := NIL;
  END_IF;
  
END_FUNCTION //GLOBAL TaskReader::ReadTasks

//[#DEUTSCH]
//Liest eine bestimmte Task-Einstellung aus, und markiert das Objekt
//für das OS als eines mit zyklischer Funktion
//
//  ret_code := InstallTask(pObj, udRate, bRealTime);
//
// The function adds an object to a list of objects, for which
// the realtime-work or the cyclic-work method has to be called.
//
// -> pThis:			pointer to the object
// -> udRate: 	time intervall between function calls for the object
// -> bRealTime:(1).. RtWork is called, (0).. CyWork is called
// <- C_OK					: no problems
// <- C_OUTOF_NEAR	: max. number of objects in one list exeeded
//
FUNCTION GLOBAL InstallTask
VAR_INPUT
	pThis		: ^VirtualBase;
	udRate		: UDINT;
	bMode		: UDINT;
  dPrio	: DINT;
  bDelayed : BOOL;
  core : DINT;
END_VAR
VAR_OUTPUT
	ret_code		: ConfStates;
END_VAR
VAR
	udBackGrd			: UDINT;
	pHdr				: ^OBJ;
  ppObjList : ^pVoid;
	udMode 	: UDINT;
  udTime 	: UDINT;
  rc : UDINT;
END_VAR

	ret_code := C_OK;

 #ifndef _LSL_USECLISTI
  CriticalLoaderSectionStart();
 #endif

	pHdr := LSL_GetHdr(pThis);

	// install watchdog-objects differently
	IF pHdr^.pClsHdr^.pDsc^.ClsType AND CTY_WATCHDOG THEN
		udBackGrd	:= TASK_WATCHDOG;
	ELSE
		udBackGrd	:= 0;
	END_IF;
  
	// Revision by UN on Oct. 25, 2000:
	// Both real and cyclic tasks are only installed, if time is unequal to 0.
	// Cyclic tasks are evoked as often as possible when time is set to -1
	// Real or Cyclic-time task, see if need to install
	IF udRate <> TASK_OFF THEN
		CASE bMode OF
		_K_REAL:
			// Real time task installed ONLY if time > 0
      // bDelayed := FALSE;

      udMode := udBackGrd OR TASK_TIMED;
      IF !!bDelayed THEN
        IF Get_ITASK_Version() >= 16#12 & _LSL_POS^.piTask^.AddRealTimeObjectEx THEN
          rc := OS_AddRtObjEx(pThis, udMode, udRate, TASK_SCAN, core);
        ELSE
          rc := OS_AddRtObj(pThis, udMode, udRate, TASK_SCAN);
        END_IF;
      ELSE
        IF dPrio >= 0 THEN
          ppObjList := #pRtObjList;
        ELSE
          ppObjList := #pRtObjList_undef;
        END_IF;
        rc := AddObjDelayed(ppObjList, dPrio, pThis, udMode, udRate, core);
      END_IF;
      IF !!rc THEN
        TRACE0_ERR("Cannot install RT-task for object '{0}'", LSL_GetObjName(pThis));
        LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );
	      ret_code := C_OUTOF_NEAR;
			END_IF;

		_K_BACKGROUND:	// LSE-tasks with minor priority
			udBackGrd += TASK_BACKGRD;
			GOTO INSTALL_CY;

		_K_CYCLIC:
INSTALL_CY:
			IF udRate = CYCLIC_TASK_ALWAYS THEN
        // Install cyclic task that runs as fast as possible!
        udMode := udBackGrd OR TASK_ALWAYS;
        udTime := 0;
      ELSE
        // Install timed cyclic task
        udMode := udBackGrd OR TASK_TIMED;
        udTime := udRate;
      END_IF;
      IF !!bDelayed THEN
        IF Get_ITASK_Version() >= 16#12 & _LSL_POS^.piTask^.AddCyclicObjectEx THEN
          rc := OS_AddCyObjEx(pThis, udMode, udTime, TASK_SCAN, core);
        ELSE
          rc := OS_AddCyObj(pThis, udMode, udTime, TASK_SCAN);
        END_IF;
      ELSE
        IF dPrio >= 0 THEN
          ppObjList := #pCyObjList;
        ELSE
          ppObjList := #pCyObjList_undef;
        END_IF;
        rc := AddObjDelayed(ppObjList, dPrio, pThis, udMode, udTime, core);
      END_IF;
      IF !!rc THEN
        TRACE0_ERR("Cannot install CY-always-task for object '{0}'", LSL_GetObjName(pThis));
        LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
	      ret_code := C_OUTOF_NEAR;
      END_IF;
		END_CASE;
	END_IF;
  
 #ifndef _LSL_USECLISTI
  CriticalLoaderSectionStop();
 #endif
  
END_FUNCTION

FUNCTION  TaskReader::CreateTask
VAR_INPUT
	pThis		: ^VirtualBase;
	udRate		: UDINT;
  dPrio	: DINT;
  bMode		: UDINT;
  core : DINT;
END_VAR
VAR_OUTPUT
	ok		: BOOL;
END_VAR

  ok  := InstallTask(pThis, udRate, bMode, dPrio, bDelayed := TRUE, core) = C_OK;

END_FUNCTION // TaskReader::CreateTask
//[#DEUTSCH]
//Liest für ein Objekt, das über den Offset definiert ist, die Taskeinstellung aus
FUNCTION  TaskReader::CreateTaskOff
VAR_INPUT
	bMode		: UDINT;
END_VAR
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pThis	: ^VirtualBase;
	udRate	: UDINT;
	dPrio	: DINT;
  core : DINT;
END_VAR

	nCon	:= pObjRd^.GetCount();
  // pObjRd2 ist der ObjectReader, mit dem aus dem 2.Teil der Taskliste gelesen wird
  IF pObjRd2 THEN
    pObjRd2^.GetCount();
  END_IF;

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Initwerte einlesen

		pThis	:= pObjRd^.GetObjectOff();
		udRate	:= pObjRd^.GetCount();
		dPrio	:= (pObjRd^.GetCount()) $ DINT;
  // pObjRd2 ist der ObjectReader, mit dem aus dem 2.Teil der Taskliste gelesen wird
    IF pObjRd2 THEN
      core := (pObjRd2^.GetCount())$DINT AND 16#FF;
    ELSE
      core := 0;
    END_IF;

		IF CreateTask(pThis, udRate, dPrio, bMode, core) = FALSE THEN
			RETURN;
		END_IF;

		nCon	-= 1;

	END_WHILE;

	ok	:= TRUE;

END_FUNCTION // TaskReader::CreateTaskOff
//[#DEUTSCH]
//Liest für ein Objekt, das über seine Nummer definiert ist, die Taskeinstellung aus
FUNCTION  TaskReader::CreateTaskObjNo
VAR_INPUT
	bMode		: UDINT;
END_VAR
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pThis	: ^VirtualBase;
	udRate	: UDINT;
	dPrio	: DINT;
  core : DINT;
END_VAR

	nCon	:= pObjRd^.GetCount();
  // pObjRd2 ist der ObjectReader, mit dem aus dem 2.Teil der Taskliste gelesen wird
  IF pObjRd2 THEN
    pObjRd2^.GetCount();
  END_IF;

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Initwerte einlesen

		pThis	:= pObjRd^.GetObjectNo();
		udRate	:= pObjRd^.GetCount();
		dPrio	:= (pObjRd^.GetCount()) $ DINT;
    // pObjRd2 ist der ObjectReader, mit dem aus dem 2.Teil der Taskliste gelesen wird
    IF pObjRd2 THEN
      core := (pObjRd2^.GetCount())$DINT AND 16#FF;
    ELSE
      core := 0;
    END_IF;

		IF pThis <> NIL & 
      CreateTask(pThis, udRate, dPrio, bMode, core) = FALSE THEN
			RETURN;
		END_IF;

		nCon	-= 1;

	END_WHILE;

	ok	:= TRUE;

END_FUNCTION // TaskReader::CreateTaskObjNo
//
// Building lists of objects for which the CyWork-method 
// will be automatically called during operation.
//
FUNCTION GLOBAL TaskReader::BuildUpdateLists
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
VAR
	pCls			: ^CLSHDR;
	pObj			: ^OBJ;
	udClsType		: UDINT;	// automatic?
	udRate			: UDINT;	// lo/high-priority
	uiMode			: UINT;		// pre/post
END_VAR

	pCls	:= _GetClsList();
	ok	  := FALSE;

	WHILE pCls <> NIL DO	// check all classes for
                        // automatic update flag
		udClsType := pCls^.pDsc^.ClsType;

		IF udClsType AND UPD_AUTOMATIC THEN

			pObj := pCls^.pFirstObj;

			IF udClsType AND UPD_PRESCAN THEN
				uiMode := TASK_PRE;
			ELSE
				uiMode := TASK_POST;
			END_IF;

			IF udClsType AND UPD_HIPRIOR THEN
				udRate := UPD_T_HIPRIOR;	// 1 ms
				uiMode += TASK_HIPRIOR;
			ELSE
				udRate := UPD_T_LOPRIOR;	// 10 ms
			END_IF;

			WHILE pObj <> NIL DO	// add tasks for each object

        // Anm pr:
        // Es wurde festgelegt, dass die Cyworks, bei denen das Automatic-Flag 
        // aktiv ist, immer im Core 0 laufen.
        // Grund: Die Corenummer ist eine Objekteigenschaft, das Automatic-Flag 
        // aber eine Klasseneigenschaft. Man müßte daher die Klassenbeschreibung 
        // erweitern, wenn man Automatic Cyworks in einem anderen Code ablaufen lassen 
        // möchte.
        // Eine Besonderheit ist auch, dass bei jedem Automatic Objekt eine Always Cywork 
        // in der Taskliste eingetragen ist. Das hat die Auswirkung, dass bei einem 
        // Objekt mit gesetztem Automatic-Flag die Cywork immer 2x aufgerufen wird. 
        // Ich vermute, dass das nicht beabsichtigt ist. 
        IF !!OS_AddCyObj(LSL_GetPtr(pObj), TASK_TIMED, udRate, uiMode) THEN
          RETURN;
        END_IF;

				pObj	:= pObj^.pNxtObj;

			END_WHILE;

		END_IF;

		pCls	:= pCls^.pNxtCls;
	END_WHILE;
  
  ok  := TRUE;
  
END_FUNCTION
//}}LSL_IMPLEMENTATION



FUNCTION GLOBAL TaskReader::ReadTaskSlots
	VAR_INPUT
		pObjRd 	: ^ObjectReader;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR

	this^.pObjRd	:= pObjRd;

	ok	:=	GetSlotTaskOff	(_K_REAL) &
			GetSlotTaskObjNo(_K_REAL) &
			GetSlotTaskOff	(_K_CYCLIC) &
			GetSlotTaskObjNo(_K_CYCLIC);

END_FUNCTION


FUNCTION TaskReader::GetSlotTaskObjNo
	VAR_INPUT
		udMode 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
	VAR
		nCon	: UDINT;
		pThis	: ^VirtualBase;
		udSlot: UDINT;
	END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Initwerte einlesen

		pThis	:= pObjRd^.GetObjectNo();
		udSlot:= pObjRd^.GetCount();

		IF pThis <> NIL & 
			AddParamToTask(pThis, udSlot, udMode, PARAM_TASK_SLOT) = FALSE THEN
			RETURN;
		END_IF;

		nCon	-= 1;

	END_WHILE;

	ok	:= TRUE;

END_FUNCTION


FUNCTION TaskReader::GetSlotTaskOff
	VAR_INPUT
		udMode 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
	VAR
		nCon	: UDINT;
	END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

END_FUNCTION


(*
  Fügt einen Parameter einem Objekt hinzu.
  Das Objekt muss in einer der Listen sein,
  die verzögert an das OS gegeben werden.
*)
FUNCTION TaskReader::AddParamToTask
	VAR_INPUT
		pThis 	: ^VirtualBase;
		udParam 	: UDINT;
		udMode 	: UDINT;
		udParamType 	: DINT;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
	VAR
		pObjParam : ^OBJ_PARAM;
	END_VAR

	ok := FALSE;

	CASE udMode OF
		_K_REAL:
		// in der Realtime-Prio-Liste suchen
		pObjParam := SearchObjekt( pRtObjList, pThis$^void);
		if pObjParam = nil then
			// Wenn kein Objekt gefunden, noch in der undef-Liste suchen
			pObjParam := SearchObjekt( pRtObjList_undef, pThis$^void);      
		end_if;
		_K_CYCLIC:
		// in der Cyclic-Prio-Liste suchen
		pObjParam := SearchObjekt( pCyObjList, pThis$^void);
		if pObjParam = nil then
			// Wenn kein Objekt gefunden, noch in der undef-Liste suchen
			pObjParam := SearchObjekt( pCyObjList_undef, pThis$^void);      
		end_if;
	END_CASE;

	// Wenn Objekt gefunden, Parameter verändern
	if pObjParam <> nil then
		if udParamType = PARAM_TASK_SLOT then
			pObjParam^.udSlot := udParam;
			ok := TRUE;
		end_if;
	end_if;

END_FUNCTION

(*
  Sucht ein Objekt in der angegebenen Liste.
  Verglichen wird der hinterkegte This-Pointer (Objektnummer)
*)
FUNCTION TaskReader::SearchObjekt
	VAR_INPUT
		pList		: ^void;
		pThis		: ^void;
	END_VAR
	VAR_OUTPUT
		pObjRet		: ^OBJ_PARAM;
	END_VAR
	VAR
		pObjList	: ^OBJ_PARAM_LIST;
		pObjParam	: ^OBJ_PARAM;
		i			: UDINT;
	END_VAR

	pObjRet := nil;
	pObjList := pList$^OBJ_PARAM_LIST;

	for i:=0 to pObjList^.nbrUsed do
		pObjParam := #pObjList^.el[i];
		if pObjParam^.pObj = pThis then
			pObjRet :=  pObjParam;
			i := pObjList^.nbrUsed;
		end_if;
	end_for;

END_FUNCTION
