//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "ConnectReader"
	Revision           = "0.0"
	GUID               = "{71BBC843-8945-4563-85AD-D7491A841757}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
	</Channels>
	<Network Name="ConnectReader">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{7FFE2175-8C5C-4075-8A92-B6A2A5F8CEFD}"
				Class      = "ObjectReader"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Server0"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using ObjectReader

ConnectReader : CLASS
: ObjectReader
	TYPE
	  PRJCFG_ACTION :
	  (
	    PRJCFG_CONNECT,
	    PRJCFG_CREATE_INITVAL_DICT:=1,
	    PRJCFG_DESTROY_INITVAL_DICT:=2
	  )$USINT;
	END_TYPE
  //Servers:
  //Clients:
  //Variables:
		pObjRd 	: ^ObjectReader;
		bCheck 	: BOOL;
  //Functions:
	
	FUNCTION GLOBAL SetInternConnections
		VAR_INPUT
			pObjRd 	: ^ObjectReader;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetConOffOff
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetConOffOffObj
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetConOffString
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetConStringString
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetConObjNoStringObjNoString
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetConObjNoStringString
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetConObjNoStringObjNo
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SetExtConnection
		VAR_INPUT
			pObjRd 	: ^ObjectReader;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetExtConnectToClt
		VAR_INPUT
			pClt 	: ^CltCh;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL ChkOpenConnections
		VAR_INPUT
			pORds 	: ^ObjectReader;
			nEle 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION ConStringString
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION ConOffString
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION ConObjNoStringString
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL RedirectChs;
	
	FUNCTION RedirectChsForObjOfCls
		VAR_INPUT
			pCls 	: ^ClsHdr;
			pThis 	: ^VirtualBase;
		END_VAR;
	
	FUNCTION ChkOpenChsForObjOfCls
		VAR_INPUT
			pCls 	: ^ClsHdr;
			pThis 	: ^VirtualBase;
			pORds 	: ^ObjectReader;
			nEle 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION ChkReqChIsInit
		VAR_INPUT
			pThis 	: ^VirtualBase;
			ppCD 	: ^ChDsc;
			pORds 	: ^ObjectReader;
			nEle 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetMagicOffOffObj
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SetMagicObjNoClt_ObjNoClt
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL ProcessConnectionFile
		VAR_INPUT
			actionCode 	: PRJCFG_ACTION;
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;
		END_VAR;
	
	FUNCTION ParseLcfRec0
		VAR_INPUT
			pBuf 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION ParseLcfRec1
		VAR_INPUT
			pBuf 	: ^CHAR;
			ppSource 	: ^pChar;
			ppDest 	: ^pChar;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION ParseLcfRec4
		VAR_INPUT
			pBuf 	: ^CHAR;
			ppSource 	: ^pChar;
			pValue 	: ^UDINT;
			pLen 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION ParseLcfRec7
		VAR_INPUT
			pBuf 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION ScanQuotedString
		VAR_INPUT
			ppScan 	: ^pChar;
		END_VAR
		VAR_OUTPUT
			result 	: ^CHAR;
		END_VAR;
	
	FUNCTION LcfConnect
		VAR_INPUT
			pCltName 	: ^CHAR;
			pSvrName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL ScanInt
		VAR_INPUT
			pScan 	: pChar;
			pValue 	: ^UDINT;
			terminator 	: CHAR;
		END_VAR
		VAR_OUTPUT
			result 	: UDINT;
		END_VAR;
	
	FUNCTION ScanReal
		VAR_INPUT
			pScan 	: pChar;
			pValue 	: ^REAL;
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;
		END_VAR;
	
	FUNCTION LcfInit4ByteValue
		VAR_INPUT
			pObj 	: ^Obj;
			pSvrName 	: ^CHAR;
			value 	: DINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION LcfInitStringValue
		VAR_INPUT
			pObj 	: ^Obj;
			pSvrName 	: ^CHAR;
			pData 	: ^USINT;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION UT_ScanInt
		VAR_OUTPUT
			result 	: BOOL;
		END_VAR;
	
	FUNCTION UT_ScanReal
		VAR_OUTPUT
			result 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL InitByPrjcfg
		VAR_INPUT
			pObj 	: ^Obj;
			f4Byte 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL InitvalsInPrjcfg
		VAR_OUTPUT
			result 	: BOOL;
		END_VAR;
	
	FUNCTION UT_WildcardMatch
		VAR_OUTPUT
			result 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL SkipExtConnection
		VAR_INPUT
			pObjRd 	: ^ObjectReader;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION SkipConOffString;
	
	FUNCTION SkipConObjNoStringString;
	
	FUNCTION SkipSetMagicOffOffObj;
	
	FUNCTION SkipSetMagicObjNoClt_ObjNoClt;
	
	FUNCTION SkipSetExtConnectToClt;
	
	FUNCTION SkipGetChPtr;
	
	FUNCTION LookupSvrCh
		VAR_INPUT
			pSvrName 	: ^CHAR;
			ppObj 	: ^pVirtualBase;
			lookupIoEl 	: BOOL;
		END_VAR
		VAR_OUTPUT
			pObj_ChSvr 	: ^SvrCh;
		END_VAR;
	
	FUNCTION LookupCltCh
		VAR_INPUT
			pCltName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			pObj_ChClt 	: ^CltCh;
		END_VAR;
	
	FUNCTION ProcessConnectionFileRecord12
		VAR_INPUT
			src 	: ^CHAR;
			dest 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ConnectReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CONNECTREADER
0$UINT, 0$UINT, (SIZEOF(::ConnectReader))$UINT, 
0$UINT, 0$UINT, 0$UINT, 
TO_UDINT(536950631), "ConnectReader", //Class
TO_UDINT(1461090386), "ObjectReader", 0$UINT, 1$UINT, //Baseclass
//Servers:
//Clients:
END_FUNCTION


#define USER_CNT_ConnectReader 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ConnectReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ConnectReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code	:= ObjectReader::@STD();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include <RTOS_PrivHeader.h>
#include <RTOS_Mem.h>
#include <LSL_ST_OSFILE.H>
#include <LSL_ST_SYSSERNUM.H>
#include <LSL_ST_LSLFILE.H>
#include ".\include\HashTab.h"
#pragma using InitReader
#pragma using VirtualBaseInit

VAR_EXTERNAL
	sbCallInit		: TCallInit;	// call InitFromTable for VBI-objects
  // Flag, das gesetzt wird wenn eine optionale externe Verbindung 
  // zu einem Server eines nicht existierenden Objekts existiert
  LDR_bExtConnToCltOfNonExistentObj : BOOL; 
END_VAR

VAR_PRIVATE
  initvalDict : HashTable; // Verzeichnis mit prjcfg-Initialisierungszeilen (Key: Objekt, Value: Liste mit Init-Zeilen)
END_VAR

FUNCTION GLOBAL _LookUpObjLex
VAR_INPUT
	pLexem          : ^CLexem;
END_VAR
VAR_OUTPUT
	ret				: ^SvrCh;
END_VAR;

FUNCTION GLOBAL LDR_LookupEmbedded2
VAR_INPUT
	pObj            : ^VirtualBase;
	ppScan          : ^pChar;
	pObj_ch         : ^pVoid;
	ppObj           : ^pVirtualBase;
END_VAR
VAR_OUTPUT
	chMode          : CHMODE;
END_VAR;

FUNCTION GLOBAL LDR_LookupEmbedded3
VAR_INPUT
	pObj            : ^VirtualBase;
	ppScan          : ^pChar;
	pObj_ch         : ^pVoid;
	ppObj           : ^pVirtualBase;
END_VAR
VAR_OUTPUT
	chMode          : CHMODE;
END_VAR;

FUNCTION GLOBAL LDR_ReplaceIoElSvr
VAR_INPUT
	pKey : pChar;
	pValue : pChar;
  index : DINT;
END_VAR;

FUNCTION GLOBAL LDR_ReplaceIoElClt
VAR_INPUT
	pKey : pChar;
	pValue : pChar;
  index : DINT;
END_VAR;

FUNCTION GLOBAL LDR_AddIoElClt
VAR_INPUT
	pKey : pChar;
	pValue : pChar;
END_VAR;

FUNCTION GLOBAL LDR_AddIoElSvr
VAR_INPUT
	pKey : pChar;
	pValue : pChar;
END_VAR;

FUNCTION GLOBAL LDR_SearchIoElSvr
VAR_INPUT
	pKey : pChar;
  pIndex : ^DINT;
END_VAR
VAR_OUTPUT
	pValue : pChar;
END_VAR;

FUNCTION GLOBAL LDR_SearchIoElClt
VAR_INPUT
	pKey : pChar;
  pIndex : ^DINT;
END_VAR
VAR_OUTPUT
	pValue : pChar;
END_VAR;

FUNCTION GLOBAL LDR_SearchIoElAdv
VAR_INPUT
	pKey : pChar;
  pIndex : ^DINT;
END_VAR
VAR_OUTPUT
	pValue : pChar;
END_VAR;

FUNCTION GLOBAL LDR_SearchCltIoEl
VAR_INPUT
	pValue : pChar;
  pIndex : ^DINT;
END_VAR
VAR_OUTPUT
	pKey : pChar;
END_VAR;

FUNCTION GLOBAL LDR_GetIoElClt
VAR_INPUT
  index : DINT;
	ppKey : ^pChar;
END_VAR
VAR_OUTPUT
	pValue : pChar;
END_VAR;

FUNCTION GLOBAL LDR_ConnFile_Init
VAR_INPUT
  err : ^BOOL;
END_VAR
VAR_OUTPUT
  cfstate : pVoid;
END_VAR;

FUNCTION GLOBAL LDR_ConnFile_Release
VAR_INPUT
	cfstate : pVoid;
END_VAR;

FUNCTION GLOBAL LDR_ConnFile_ReadLine
VAR_INPUT
	cfstate : pVoid;
  ppBuf  : ^pCHAR;
END_VAR  
VAR_OUTPUT
  len  : DINT;
END_VAR;


//[#DEUTSCH]
//Alle Arten von internen Verbindungen im aktuellen ON setzen
FUNCTION  GLOBAL ConnectReader::SetInternConnections
VAR_INPUT
	pObjRd	: ^ObjectReader;
END_VAR
VAR_OUTPUT
	ok		: BOOL;
END_VAR

	this^.pObjRd	:= pObjRd;

	ok	:=	SetConOffOff() &
          SetConObjNoStringObjNo() &			// ObjNo.Client -> ObjNo (.Server0)
          SetConOffOffObj() &
          SetConObjNoStringObjNoString();		// ObjNo.Client -> ObjNo.Server

END_FUNCTION // ConnectReader::SetInternConnections
//[#DEUTSCH]
//Verbindung von einem Client zum obersten Server eines Objekts,
//Angabe von 2 Offsets
FUNCTION  ConnectReader::SetConOffOff
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pClt	: ^CltCh;
	pSvr	: ^SvrCh;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO			// alle angegebenen Verbindungspaare einlesen
		pClt	:= (pObjRd^.GetObjectOff()) $ ^CltCh;
		pSvr	:= (pObjRd^.GetObjectOff()) $ ^SvrCh;

		// Client und obersten Server eines Objekts verbinden
		pClt^.pCh	:= pSvr;
		pClt^.pCmd	:= pSvr $ ^VirtualBase;

		nCon	-= 1;
	END_WHILE;

	ok		:= TRUE;

END_FUNCTION // ConnectReader::SetConOffOff
//[#DEUTSCH]
//Verbindung zwischen einem Client und einem beliebigen Server
//eines anderen Objekts
FUNCTION  ConnectReader::SetConOffOffObj
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pClt	: ^CltCh;
	pSvr	: ^SvrCh;
	pObj	: ^VirtualBase;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	WHILE nCon > 0 DO
		pClt	:= (pObjRd^.GetObjectOff()) $ ^CltCh;
		pSvr	:= (pObjRd^.GetObjectOff()) $ ^SvrCh;
		pObj	:= pObjRd^.GetObjectOff();

		// Client und beliebigen Server eines Objekts verbinden
		pClt^.pCh	:= pSvr;
		pClt^.pCmd	:= pObj;

		nCon	-= 1;
	END_WHILE;

	ok		:= TRUE;

END_FUNCTION // ConnectReader::SetConOffOffObj
//[#DEUTSCH]
//Verbindungen eintragen, die auf der Server - Seite über einen
//String angegeben sind.
FUNCTION  ConnectReader::ConOffString
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pClt	: ^CltCh;
END_VAR

	ok	  := TRUE;
	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		RETURN;
	END_IF;

	WHILE nCon > 0 DO
		pClt	:= (pObjRd^.GetObjectOff()) $ ^CltCh;
    
    IF SetExtConnectToClt(pClt) = FALSE THEN
      ok  := FALSE;
      RETURN;
    END_IF;

		nCon	-= 1;
	END_WHILE;

END_FUNCTION // ConnectReader::ConOffString
FUNCTION ConnectReader::SetExtConnectToClt
  VAR_INPUT
    pClt    : ^CltCh;
  END_VAR
  VAR_OUTPUT
    ok      : BOOL;
  END_VAR
  VAR
    pLex  : ^CLexem;
    pSvr  : ^SvrCh;
    pObj  : ^VirtualBase;
    uiTry   : UINT;
  END_VAR
  
  uiTry := pObjRd^.GetUInt();
    
  pLex  := pObjRd^.ReadLexem();
  ok    := TRUE;
  
  // Aufruf mit dem Verbindungsstring der Art: Objekt.Kanal
  pObj  := _LookUpObjLex(pLex) $ ^VirtualBase;
  IF pObj = NIL THEN
    CASE uiTry OF
    C_TRY:    // die Verbindung ist zwar angegeben, sie ist aber gar nicht erforderlich
      TRACE0_ERR("Cannot enter connection to '{0}'", #pLex^.Text[0]);
      LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
      pObjRd^.ReadLexem();
      // Wenn externe Verbindungen zu Servern von nicht existierenden Objekten vorhanden sind, 
      // dann wird erst später abgebrochen, damit in der Debugger-Trace Ausgabe alle falschen 
      // Verbindungen angezeigt werden.
      LDR_bExtConnToCltOfNonExistentObj := TRUE;
    ELSE      // hier kann eigentlich nur C_DIR kommen, C_OBLI kommt nur bei fehlendem Connect - String
      TRACE0_ERR("Cannot enter connection to '{0}'", #pLex^.Text[0]);
      LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
      ok		:= FALSE;
    END_CASE;
  ELSE
		pSvr	:= (pObjRd^.GetChPtr(pObj)) $ ^SvrCh;
    IF pSvr = NIL THEN      // das Objekt gibt es, aber den Kanal nicht, 
                            // das kann später nicht mehr korrigiert werden
      TRACE0_ERR("Cannot enter connection to '{0}'", #pLex^.Text[0]);
      LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
      ok		:= FALSE;
    ELSE
      pClt^.pCh	  := pSvr;  // Client und beliebigen Server eines Objekts verbinden
      pClt^.pCmd	:= pObj;
    END_IF;
  END_IF;
  
END_FUNCTION

//[#DEUTSCH]
//Verbindungen eintragen, die sowohl auf der Client - Seite, als auch
//auf der Server - Seite über einen String angegeben sind.
FUNCTION  ConnectReader::ConStringString
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

END_FUNCTION // ConnectReader::ConStringString
//[#DEUTSCH]
//Verbindung: ObjNo.Client -> ObjNo.ServerX
FUNCTION  ConnectReader::SetConObjNoStringObjNoString
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pClt	: ^CltCh;
	pThis	: ^VirtualBase;
	pSvr	: ^SvrCh;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Verbindungspaare einlesen
		pThis	:= pObjRd^.GetObjectNo();
		pClt	:= pObjRd^.GetChPtr(pThis);
		IF pClt = NIL THEN
			RETURN;
		END_IF;

		pThis	:= pObjRd^.GetObjectNo();
		pSvr	:= (pObjRd^.GetChPtr(pThis)) $ ^SvrCh;
		IF pSvr = NIL THEN			// Angabe des Client-Kanals ist ungültig
			RETURN;
		END_IF;

		pClt^.pCh	:= pSvr;
		pClt^.pCmd	:= pThis;

		nCon	-= 1;
	END_WHILE;

	ok	:= TRUE;

END_FUNCTION // ConnectReader::SetConObjNoStringObjNoString
//[#DEUTSCH]
//Verbindung: ObjNo.Client -> ObjNo.Server
FUNCTION  ConnectReader::ConObjNoStringString
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pClt	: ^CltCh;
	pThis	: ^VirtualBase;
  iCltNr  : udint;
  cCltNr : array[ 0..8 ] of char;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;
  iCltNr := 0;

	WHILE nCon > 0 DO				// alle angegebenen Verbindungspaare einlesen
    iCltNr += 1;
		pThis	:= pObjRd^.GetObjectNo();
		pClt	:= pObjRd^.GetChPtr(pThis);
		IF pClt = NIL THEN
			RETURN;
		END_IF;

    IF SetExtConnectToClt(pClt) = FALSE THEN
      _itoa( iCltNr, #cCltNr[ 0 ] );
      TRACE1_ERR("Ext.connection from object '{0}' at client no. {1} failed", LSL_GetObjName(pThis), #cCltNr[ 0 ] );
      LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
      RETURN;
    END_IF;

		nCon	-= 1;
	END_WHILE;

	ok	:= TRUE;

END_FUNCTION // ConnectReader::ConObjNoStringString
//[#DEUTSCH]
//Verbindung: ObjNo.Client -> ObjNo[.Server0]
FUNCTION  ConnectReader::SetConObjNoStringObjNo
VAR_OUTPUT
	ok		: BOOL;
END_VAR
VAR
	nCon	: UDINT;
	pClt	: ^CltCh;
	pThis	: ^VirtualBase;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Verbindungspaare einlesen
		pThis	:= pObjRd^.GetObjectNo();
		pClt	:= pObjRd^.GetChPtr(pThis);
		IF pClt = NIL THEN
			RETURN;
		END_IF;

		pThis	:= pObjRd^.GetObjectNo();
    IF pThis <> NIL THEN
      pClt^.pCh	:= pThis $ ^SvrCh;
      pClt^.pCmd	:= pThis;
    END_IF;

		nCon	-= 1;
	END_WHILE;

	ok	:= TRUE;

END_FUNCTION // ConnectReader::SetConObjNoStringObjNo
//[#DEUTSCH]
//Alle Arten von Verbindungen setzen, die aus diesem ON hinausgehen
FUNCTION  GLOBAL ConnectReader::SetExtConnection
VAR_INPUT
	pObjRd	: ^ObjectReader;
END_VAR
VAR_OUTPUT
	ok		: BOOL;
END_VAR

	this^.pObjRd	:= pObjRd;
  bCheck  := FALSE;

	ok :=	ConOffString() &					// ConType, Off, CRC, Obj.Server
        ConObjNoStringString() &	// ConType, ObjNo.Client -> CRC, Obj.Server
   //     ConStringString() &				// ConType, String, String
        SetMagicOffOffObj() &
        SetMagicObjNoClt_ObjNoClt();
        
END_FUNCTION // ConnectReader::SetExternConnection
//[#DEUTSCH]
//Alle Verbindungen prüfen, die aus diesem ON hinausgehen. Solche mit dem Attribut
//C_OBLI müssen verbunden sein. Es werden alle Objekte aller Klassen untersucht.
//Problem: In L1 konnte die Required - Anforderung auch durch Vergabe eines Initwerts für
//den Client erfüllt werden (Verbindungstyp C_CONST). 
//Das könnte jetzt nur durch Abfrage des jeweiligen Datenelements auf ungleich 0 bewerkstelligt
//werden.
FUNCTION GLOBAL ConnectReader::ChkOpenConnections
	VAR_INPUT
		pORds 	: ^ObjectReader;
		nEle 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    pCls    : ^ClsHdr;
    pObj    : ^Obj;
  END_VAR

  pCls    := _GetClsList();
  ok      := TRUE;
  
  WHILE pCls <> NIL DO
  
    IF pCls^.nObjs > 0 THEN
    
      pObj  := pCls^.pFirstObj;
      
      WHILE pObj <> NIL DO
    
        IF ChkOpenChsForObjOfCls(pCls, LSL_GetPtr(pObj), pORds, nEle) = FALSE THEN
          ok  := FALSE;
        END_IF;
      
        pObj  := pObj^.pNxtObj;
    
      END_WHILE;
      
    END_IF;
    
    pCls  := pCls^.pNxtCls;
    
  END_WHILE;

END_FUNCTION

FUNCTION ConnectReader::ChkOpenChsForObjOfCls
	VAR_INPUT
		pCls 	: ^ClsHdr;
		pThis 	: ^VirtualBase;
    pORds:^ObjectReader;
    nEle:UDINT;
	END_VAR
  VAR_OUTPUT
    ok    : BOOL;
  END_VAR
  VAR
    pDsc    : ^ClsHdrConst;
    ppCD    : ^ChDsc;
    uiCh    : UINT;
    pCh     : ^CltCh;
  END_VAR

  pDsc  := pCls^.pDsc;
  
  uiCh 	:= pDsc^.nCltChs;
  ppCD	:= #pCls^.aDscChs[pDsc^.nSvrChs];
  ok    := TRUE;
  
  WHILE uiCh DO

    IF ppCD^.pDsc^.uiFlags.Required THEN   // alle Kanäle mit required - Flag prüfen
      pCh := pThis + ppCD^.pDsc^.uiOff;
        
      IF IsClientConnected(#pCh^.dData) = FALSE THEN
        IF ChkReqChIsInit(pThis, ppCD, pORds, nEle) = FALSE THEN
          TRACE1_ERR("Channel '{0}::{1}' must be connected!", LSL_GetObjName(pThis), #ppCD^.pDsc^.Name.Text[0]);
          LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
          ok  := FALSE;
        END_IF;
      END_IF;
        
    END_IF;
    
    uiCh  -= 1;
    ppCD  += sizeof(ChDsc);
    
  END_WHILE;
  
  pCls  := pCls^.pBaseCls;  // Kanäle der Basisklasse prüfen
  IF pCls <> NIL & ChkOpenChsForObjOfCls(pCls, pThis, pORds, nEle) = FALSE THEN
    ok  := FALSE;
  END_IF;
  
END_FUNCTION
// Mit dieser Funktion sollen alle Objektkanäle, die über einen magic client nach außen verbunden
// sind direkt auf das außen angeschlossene Objekt verpointert werden. Nach dem normalen Verbinden
// zeigt der pCmd auf das Objekt mit dem magic client. Der Benutzer erwartet sich aber eigentlich
// eine Verbindung auf das Objekt, das am magic client außen angeschlossen ist. Der Compile verhält
// sich genauso, er castet den pCmd sofort auf die Zielklasse. Das funktioniert nicht, daher wird
// diese Funktion aufgerufen.
//FUNCTION GLOBAL ConnectReader::RedirectChs

// Verbindungen eines Objektes einer bestimmten Klassen nach außen umleiten.
//
// Clients von embedded Objekten werden beim Hochfahren auf Magic Clients hin verbunden. Diese Magic Clients 
// funktionieren aber nicht so wie gedacht. Daher werden die Verbindungen hier wieder auf die Kanäle verdreht,
// auf die die magic clients selber zeigen.
//
// Eine Eigenschaft und ein Vorteil des magic clients war, dass bei nicht verbundenen, äußeren Kanälen die 
// inneren Kanäle die Werte vom magic client geholt hätten. Das kann man jetzt dadurch erreichen, dass der pCh
// des inneren Kanals auf den pCmd des magic client zeigt. Dann hat man die Methodenliste dieses Clients zur
// Verfügung, und bekommt daher auch die Werte dieses Clients geliefert.
// Wenn der magic client nach außen verbunden ist, dann kann man diese Verbindung auf den inneren Kanal hin
// übertragen.
// 1. Problem bei nicht verbundenen magic clients ist: die Funktion isClientCon funktioniert nicht mehr. Sie prüft ja,
// ob der pCh des Clients auf die Adresse des pCmd - Elements desselben Clients zeigt. Jetzt zeigt pCh auf irgend
// einen Client. Man müßte daher eine 2. Abfrage in isClientCon einbauen, und den inneren Kanal entsprechend
// konfigurieren. Eine Möglichkeit wäre, das pCmd - Element des inneren Kanals auf NIL zu setzen.
// Eine andere Möglichkeit wäre, als Bedingung für nicht verbunden, die Gleichheit von pCmd und der Methoden-
// liste von nicht verbunden Clients zu prüfen (generell, getestet, funktioniert).
// 2. Problem bei nicht verbundenen magic clients ist: es könnte jemand eine eigene Connected - Prüfung verwenden.
//
// Diese Abfrage kann auch über ein Flag in der Kanalbeschreibung der Klasse erfolgen.
// Dann gibt es aber folgendes Problem: ein Client zeigt auf einen anderen Client, der Client selbst hat aber
// keinen Descriptor. Daher muß man über die Klasse des verbundenen Objekts die Kanalbeschreibung 
// ermitteln. Erst dann weiß man, ob der verbundene Kanal ein magic client ist.
//
// Prüft, ob die Required-Anforderung für einen Kanal durch einen Init-Wert erfüllt worden ist.
FUNCTION ConnectReader::ChkReqChIsInit
	VAR_INPUT
		pThis 	: ^VirtualBase;
		ppCD 	: ^ChDsc;
		pORds 	: ^ObjectReader;
		nEle 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    pIniRd  : InitReader;
  END_VAR
  
  ok  := FALSE;
  
(* im Vergleich zu L1 zu strenge Prüfung  
  CASE ppCD^.pDsc^.uiMode OF
    _CH_CLT_CMD,    // Kommando-Client
    _CH_CLT_DATA:   // Daten-Client
    ELSE
      RETURN;       // nicht verbundener Kanal, kein normaler Client-Kanal
  END_CASE;
*)  
  WHILE nEle > 0 DO // alle ONs durchlaufen und Objekt suchen
    IF pORds^.pON < pThis & pThis < pORds^.pON + pORds^.nSize THEN  // Objekt liegt in diesem ON
      IF pIniRd.FindIniValue(pORds, pThis, ppCD) = TRUE THEN
        ok  := TRUE;  // nicht verbundener Reuqired-Kanal hat zumindest einen Init-Wert -> kein Fehler
      END_IF;
      RETURN;
    END_IF;
    pORds += sizeof(ObjectReader);
    nEle  -= 1;
  END_WHILE;

END_FUNCTION

// Verbindung von einem Client eines embedded Objekts zu einem Client des umhüllenden komlexen Objekts.
// Die Verbindung des äußeren Clients wird für den inneren übernommen.
FUNCTION ConnectReader::SetMagicOffOffObj
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
VAR
	nCon	: UDINT;
  pMagic,
	pClt	: ^CltCh;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	WHILE nCon > 0 DO
		pClt	  := (pObjRd^.GetObjectOff()) $ ^CltCh; // innerer Client
		pMagic	:= (pObjRd^.GetObjectOff()) $ ^CltCh; // äußerer Client
    // ToDo: es könnte die Angabe des 2. Objekts eingespart werden, weil es nicht verwendet wird
		pObjRd^.GetCount();   // komplexes Objekt mit dem äußeren Client überlesen

		// inneren Client gleich verbinden, wie den äußeren Client
    // falls der nicht verbunden ist, dann ist der innere Kanal eh schon als 'nicht verbunden' initialisiert
    IF IsClientConnected(#pMagic^.dData) = TRUE THEN
      pClt^.pCmd := pMagic^.pCmd;
      pClt^.pCh  := pMagic^.pCh;
    END_IF;

		nCon	-= 1;
	END_WHILE;

	ok		:= TRUE;

END_FUNCTION


//Verbindung: ObjNo.Client -> ObjNo.ServerX
FUNCTION ConnectReader::SetMagicObjNoClt_ObjNoClt
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  VAR
    nCon	: UDINT;
    pMagic,
    pClt	: ^CltCh;
    pThis	: ^VirtualBase;
  END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		ok	:= TRUE;
		RETURN;
	END_IF;

	ok		:= FALSE;

	WHILE nCon > 0 DO				// alle angegebenen Verbindungspaare einlesen
		pThis	:= pObjRd^.GetObjectNo();   // embedded Objekt
		pClt	:= pObjRd^.GetChPtr(pThis); // innerer Client, am embedded Objekt
		IF pClt = NIL THEN
			RETURN;
		END_IF;

		pThis	  := pObjRd^.GetObjectNo();   // äußeres, komplexes Objekt
		pMagic	:= (pObjRd^.GetChPtr(pThis)) $ ^CltCh;
		IF pMagic = NIL THEN			          // Angabe des Client-Kanals ist ungültig
			RETURN;
		END_IF;

		// inneren Client gleich verbinden, wie den äußeren Client
    // falls der nicht verbunden ist, dann ist der innere Kanal eh schon als 'nicht verbunden' initialisiert
    IF IsClientConnected(#pMagic^.dData) = TRUE THEN
      pClt^.pCmd := pMagic^.pCmd;
      pClt^.pCh  := pMagic^.pCh;
    END_IF;

		nCon	-= 1;
	END_WHILE;

	ok	:= TRUE;

END_FUNCTION


//#define UNIT_TEST
#ifdef UNIT_TEST
VAR_GLOBAL
  allocCnt : UDINT;
END_VAR
#endif

TYPE
  InitvalEntry : STRUCT
    objCrc : UDINT;       // CRC des Objekts
    chName : ^CHAR;       // Name des Channels (Client, Server)
    value : UDINT;        // Initialisierungswert (4 Byte Wert oder Zeiger auf einen Datenbereich)
    datalen : UDINT;      // Größe des Datenbereichs oder 0, wenn value ein 4 Byte Wert ist
    pNext : ^InitvalEntry;// Zeiger aufs nächste Element (verkettete Liste mit allen Einträgen pro Objekt)
  END_STRUCT;  
END_TYPE

(* Funktion, mit der ein Hashwert eines Initwert-Verzeichnisses gebildet wird *)
FUNCTION InitvalDictHash
VAR_INPUT
	Key : pVoid;  // ClsHdrConst
END_VAR  
VAR_OUTPUT
  idx : UDINT;
END_VAR
  
  idx := Key$UDINT; // der Key ist die CRC des Objekts und gleichzeitig der Hashwert

END_FUNCTION


(* Vergleichsfunktion für die Elemente in der Hashtabelle des Initwert-Verzeichnisses *)
FUNCTION InitvalDictCmp
VAR_INPUT
	Element : pVoid;
	Key : pVoid;
  cookie : pVoid;
END_VAR  
VAR_OUTPUT
  result : DINT;
END_VAR

  IF Element$UDINT = Key$UDINT THEN // der Key ist die CRC des Objekts
    result := 1;
  ELSE
    result := 0;
  END_IF;

END_FUNCTION


(* 
  Hängt an die Liste der Initwerte (pro Objekt gibt es eine solche Liste) ein Element an. 
  Diese Liste ist der Wert im Initwert-Verzeichnis (die Objekt-CRC ist der Key).
  Wenn die ursprüngliche Liste leer ist, dann wird das Element die neue Liste.
*)
FUNCTION InitvalListAppend
  VAR_INPUT
	  list : ^InitvalEntry;
    elem : ^InitvalEntry;
  END_VAR
  VAR_OUTPUT
	  newList : ^InitvalEntry;
  END_VAR
  
  IF list = NIL THEN
    newList := elem;
  ELSE
    WHILE list^.pNext <> NIL DO
      list := list^.pNext;
    END_WHILE;
    list^.pNext := elem;
  END_IF;

END_FUNCTION


(* Fügt einen Eintrag ins Initwert-Verzeichnis hinzu *)
FUNCTION InitvalDictAdd
  VAR_INPUT
    fString : BOOL;
    chName : ^CHAR;
    value : UDINT;
    datalen : UDINT;
  END_VAR
  VAR_OUTPUT
    ok : BOOL;
  END_VAR
  VAR
    pInitval : ^InitvalEntry;
	  list : ^InitvalEntry;
    objCrc : UDINT;
  	Lexem	: ARRAY [0..NLNG+1] OF CHAR;
    pScan : ^CHAR;
    searchRes : pVoid;
  END_VAR

  ok := TRUE;

  IF initvalDict = NIL THEN
    initvalDict := HashTable_Initialize(100, #InitvalDictHash(), #InitvalDictCmp());
  END_IF;
  IF initvalDict = NIL THEN
    ok := FALSE;
    RETURN;
  END_IF;

  // neues Initwert Element erstellen
  pInitval := _alloc_resize_LDR(SIZEOF(InitvalEntry))$^InitvalEntry;
#ifdef UNIT_TEST
  allocCnt += 1;
#endif
  IF pInitval = NIL THEN
    ok := FALSE;
    RETURN;
  END_IF;
  pInitval^.pNext := NIL;
  pInitval^.chName := _alloc_resize_LDR(_strlen(chName) + 1)$^CHAR;
#ifdef UNIT_TEST
  allocCnt += 1;
#endif
  IF pInitval^.chName = NIL THEN
    ok := FALSE;
    RETURN;
  END_IF;
  _strcpy(pInitval^.chName, chName);
  IF !!fString THEN
    // 4 Byte Initialisierungswert
    pInitval^.value := value;
    pInitval^.datalen := 0; // 0 bedeutet 4-Byte Variable
  ELSE
    // String Initialisierungswert
    pInitval^.value$pVoid := _alloc_resize_LDR(datalen);
#ifdef UNIT_TEST
    allocCnt += 1;
#endif
    IF pInitval^.value$pVoid = NIL THEN
      ok := FALSE;
      RETURN;
    END_IF;
    _memcpy(pInitval^.value$pVoid, value$pVoid, datalen);
    pInitval^.datalen := datalen;
  END_IF;
  
  // CRC des Objektnamens ermitteln
  pScan := chName;
  ScanLexem(#pScan, #Lexem[0]);
  objCrc := Crc32(#Lexem[0]);
  
  // Initwert Element in Initwert-Verzeichnis geben (mit der CRC als Key)
  searchRes := HashTable_Find(objCrc$pVoid, initvalDict, NIL);
  IF searchRes THEN
    list$pVoid := HashTable_RetrieveVal(searchRes);
  ELSE
    list := NIL;
  END_IF;
  IF list = NIL THEN
    IF HashTable_Insert(objCrc$pVoid, pInitval, initvalDict, NIL) < 0 THEN
      ok := FALSE;
      RETURN;
    END_IF;
  ELSE
    InitvalListAppend(list, pInitval);
  END_IF;

END_FUNCTION


(* Deallokiert alle Einträge des Initwert-Verzeichnis und das Verzeichnis selbst *)
FUNCTION InitvalDictFreeAll
  VAR
    iter_idx : DINT;
	  iter_node : pVoid;
    iter_res : pVoid;
	  pInitVal : ^InitvalEntry;
	  temp : ^InitvalEntry;
  END_VAR
  
  iter_idx := -1;
  iter_node := NIL;
  REPEAT
    iter_res := HashTable_Iter(initvalDict, #iter_idx, #iter_node);
    IF iter_res <> NIL THEN
      pInitVal$pVoid := HashTable_RetrieveVal(iter_res);
      WHILE pInitVal <> NIL DO 
        IF pInitVal^.datalen > 0 THEN
          _free(pInitVal^.value$pVoid);
#ifdef UNIT_TEST
          allocCnt -= 1;
#endif
        END_IF;
        _free(pInitVal^.chName);
#ifdef UNIT_TEST
        allocCnt -= 1;
#endif
        temp := pInitVal;
        pInitVal := pInitVal^.pNext;
        _free(temp);
#ifdef UNIT_TEST
        allocCnt -= 1;
#endif
      END_WHILE;
    END_IF;
  UNTIL iter_res = NIL END_REPEAT;

  HashTable_Destroy(#initvalDict);

END_FUNCTION


(* Verarbeitet den Record-Typ 1 und 2 (Client-Server bzw. IO-Element Verbindung 
   eines Connection-Files *)
FUNCTION ConnectReader::ProcessConnectionFileRecord12
  VAR_INPUT
    src : ^CHAR;
    dest : ^CHAR;
  END_VAR
  VAR_OUTPUT
    result 	: BOOL;
  END_VAR
  VAR
    pObj_ChClt : ^CltCh;
    pObj_ChSvr : ^SvrCh;
    pObjSvr	: ^VirtualBase;
  	svrName : pChar;
  	cltName : pChar;
  	advIoElObjName : pChar;
  	ioelName : pChar;
  	ioelName_temp : pChar;
    index : DINT;
    cltIndex : DINT;
    svrIndex : DINT;
  END_VAR
  
  result := FALSE;
  
  pObj_ChClt := LookupCltCh(src);
  pObj_ChSvr := LookupSvrCh(dest, #pObjSvr, FALSE(*lookupIoEl*));
  
  IF pObj_ChClt <> NIL & pObj_ChSvr <> NIL THEN
    // Da anhand von src,dest beides (Client und Server) gefunde wurde, handelt 
    // es sich um eine Client-Server Verbindung oder um eine Verbindung von 
    // einem Client zu einem Advanced-IOElement-Objekt. Bei einer Client-AdvIoElObj 
    // Verbindung wird nämlich im Connectionfile nicht der IOEl Name sondern der 
    // Name des dahinterliegenden Objekts angegeben und dieses wird mit 
    // LookupSvrCh gefunden.
    
    // Verbindung herstellen 
    pObj_ChClt^.pCh	:= pObj_ChSvr;
    pObj_ChClt^.pCmd	:= pObjSvr;
    
    // Wenn es ein IO-Element gibt, mit dem der Client verbunden ist, dann diesen 
    // Eintrag entfernen, weil ein Client nicht gleichzeitig mit einem Server und 
    // einem IO-Element verbunden sein kann.
    ioelName := LDR_SearchCltIoEl(src, #index);
    IF ioelName <> NIL THEN
      LDR_ReplaceIoElClt(ioelName, "", index);
    END_IF;
  ELSE
    // Es wurde anhand von src,dest nicht beides (Client und Server) gefunden. 
    // Es wird jetzt weiter geprüft, ob es sich um eine IO-Element Verbindung handelt.
    // Diese Fälle gibt es:
    // - IoEl,Server
    // - Client,IoEl
    // - AdvIoEl,Server
  
    IF pObj_ChSvr <> NIL THEN
      // Der zum IO-Element gehörende Name ist ein Server
      // src ist entweder ein IoEl oder ein AdvIoEl
      ioelName := src;
      svrName := LDR_SearchIoElSvr(ioelName, #svrIndex);
      cltName := LDR_SearchIoElClt(ioelName, #cltIndex);
      advIoElObjName := LDR_SearchIoElAdv(ioelName, NIL);
  
      IF (svrName = NIL) & (cltName = NIL) THEN
        // Den IO-Element Namen gibt es im Projekt nicht
        RETURN;
      END_IF;
      
      // Prüfen, ob sich der Servername vom bestehenden Eintrag unterscheidet 
      // (bei Gleichheit wird der Eintrag übersprungen, da nichts geändert werden muss)
      IF (svrName <> NIL) & _stricmp(svrName, dest) = 0 THEN
        result := TRUE;
        RETURN;
      END_IF;
      
      IF advIoElObjName = NIL THEN
        IF svrName = NIL THEN
          // Neues IO-Element-Server erstellen
          LDR_AddIoElSvr(ioelName, dest);
        ELSE
          // Beim IO-Element den Namen ändern
          LDR_ReplaceIoElSvr(ioelName, dest, svrIndex);
        END_IF;
      
        // Es handelt sich um ein herkömmliches IO-Element
        // Bei allen Clients, die mit diesem IO-Element verknüpft sind, 
        // Verbindung auf den neuen Server setzen.
        WHILE cltName <> NIL DO
          // cltName ist ein Leersting wenn durch eine Angabe einer Direktverbindung 
          // im .lcf File die Verbindung IO-Element zu einem Client aufgehoben wurde.
          IF cltName^ <> 0 THEN
            pObj_ChClt := LookupCltCh(cltName);
            pObj_ChClt^.pCh	:= pObj_ChSvr;
            pObj_ChClt^.pCmd := pObjSvr;
          END_IF;
          
          // Nächstes IO-Element
          cltIndex += 1;
          cltName := LDR_GetIoElClt(cltIndex, #ioelName_temp);
          IF (ioelName_temp <> NIL) & _stricmp(ioelName, ioelName_temp) <> 0 THEN
            // Schleifenabbruch, sobald der IO-Element-Name unterschiedlich ist
            cltName := NIL;
          END_IF;
        END_WHILE;
      ELSE
        // Es handelt sich um ein advanced IO-Element.
        // Es wird eine Verbindung vom Objekt, das mit dem advanced IO-Element verknüpft 
        // ist und dem Server hergestellt.
        //
        // Der Eintrag in der IOElementsTab IOEl,Server muss nicht aktualisiert werden, 
        // wei hier als Server das Objekt angegeben ist, das hinter dem IO-Element steckt.
        
        pObj_ChClt := LookupCltCh(advIoElObjName);
        pObj_ChClt^.pCh	:= pObj_ChSvr;
        pObj_ChClt^.pCmd := pObjSvr;
      END_IF;
    ELSE
      IF pObj_ChClt <> NIL THEN
        // Der zum IO-Element gehörende Name ist ein Client
        // dest ist ein IoEl
        ioelName := dest;
        svrName := LDR_SearchIoElSvr(ioelName, #svrIndex);
        cltName := LDR_SearchIoElClt(ioelName, #cltIndex);

        IF (svrName = NIL) & (cltName = NIL) THEN
          // Den IO-Element Namen gibt es im Projekt nicht
          RETURN;
        END_IF;

        // Prüfen, ob sich der Clientname von allen bestehenden Einträgen unterscheidet 
        // (bei gefundener Gleichheit wird der Eintrag übersprungen, da nichts geändert 
        // werden muss, da es diesen Eintrag schon gibt)
        WHILE cltName <> NIL DO
          IF _stricmp(cltName, src) = 0 THEN
            result := TRUE;
            RETURN;
          END_IF;
          
          // Nächstes IO-Element
          cltIndex += 1;
          cltName := LDR_GetIoElClt(cltIndex, #ioelName_temp);
          IF (ioelName_temp <> NIL) & _stricmp(ioelName, ioelName_temp) <> 0 THEN
            // Schleifenabbruch, sobald der IO-Element-Name unterschiedlich ist
            cltName := NIL;
          END_IF;
        END_WHILE;
        
        // Prüfen, ob es ein IO-Element gibt, mit dem der Client bis jetzt verbunden ist
        ioelName_temp := LDR_SearchCltIoEl(src, #cltIndex);
        IF ioelName_temp <> NIL THEN
          // Beim bisherigen IO-Element den Namen entfernen
          LDR_ReplaceIoElClt(ioelName_temp, "", cltIndex);
        END_IF;
        
        // Neuen IO-Element-Client Eintrag erstellen und einfügen
        LDR_AddIoElClt(ioelName, src);
        
        // Verbindung herstellen bzw. trennen (unter berücksichtigung der IO-Elemente)
        pObj_ChSvr := LookupSvrCh(ioelName, #pObjSvr, TRUE(*lookupIoEl*));
        IF pObj_ChSvr THEN
          pObj_ChClt^.pCh	:= pObj_ChSvr;
          pObj_ChClt^.pCmd := pObjSvr;
        ELSE
          pObj_ChClt^.pCh  := (#pObj_ChClt^.pCmd)$^SvrCh;
          pObj_ChClt^.pCmd := sbCallInit.pCltMeth$^VirtualBase;
        END_IF;
       
      ELSE
        // Das beim IO-Element angegebene Objekt ist kein Client und kein Server
        RETURN;
      END_IF;
    END_IF;
  END_IF;

  result := TRUE;

END_FUNCTION


(* 
  Liest die Textdatei 'c:\lsldata\prjcfg.lcf' ein und führt je nach dem Wert 
  des Parameters actionCode bestimmte Aktionen aus.
  Folgende actionCode Werte sind möglich:
    PRJCFG_CONNECT:
        Client-Server Verbindungen werden hergestellt
    PRJCFG_CREATE_INITVAL_DICT
        Das Verzeichnis mit den Initialisierungswerten (mit dem Objekt als Key) wird erstellt
    PRJCFG_DESTROY_INITVAL_DICT
        Das Verzeichnis mit den Initialisierungswerten wird zerstört
        
  Wenn die Datei fehlerfrei verarbeitet werden konnte, wird True zurückgegeben, 
  sonst False.

  Dateiformat:
    <Record-Typ>:"<Record-Daten>"
    .
    .
    usw.
    
  Record-Typ:
    0   .. Projektname
           Zwischen dem '0'-Zeichen und dem Prjojektnamen sind bei der neuen 
           Version mit Initwerten 2 ':' Zeichen als Trennzeichen vorhanden, 
           damit alte Loaderversionen ein neues Format mit Initwerten nicht 
           verarbeiten können.
    1,2 .. - Client-Server Verbindung oder
           - IOElement-Server Verbindung oder
           - Client-IOElement Verbindung
           (im Loader wird zw. Record-Typ 1 und 2 keine Unterscheidung gemacht - 
           ist nur fürs Lasal relevant)
    3   .. Filekennung (für Loader uninteressant)
    4   .. Initwert für Client (4Byte Wert, String)
    5   .. Initwert für Server (4Byte Wert, String)
    6   .. Kommentar (für Loader uninteressant)
    7   .. Versionsnummer (Major, Minor)
           Wenn Major einen Wert > als MAX_PRJCFG_MAJOR aufweist, wird ein 
           Fehler zurückgegeben.

Bsp.:  
0::"test"
1:"Class01.Client","Class02.ClassSvr"
1:"Class02.Client","Class01.Server"  
2:"Class03.Client","Class04.Server"  
4:"Class13.Client","-4"
4:"Class13.Client","real:3.14"
5:"Class14.ClassSvr","string:Hallo"
7:"1.0"

*)
FUNCTION GLOBAL ConnectReader::ProcessConnectionFile
  VAR_INPUT
    actionCode	: PRJCFG_ACTION;
  END_VAR
  VAR_OUTPUT
    result 	: BOOL;
  END_VAR
  VAR
    cfstate_ : pVoid;
    len  : DINT;
    pBuf : ^CHAR;
    rc : DINT;
    source : ^CHAR;
    dest : ^CHAR;
    value : UDINT;
    datalen : UDINT;
    fString : BOOL;
    err : BOOL;
  END_VAR
  
  result := TRUE;
  
  IF _rtosversion <= 16#537 | !!(LSLFILE_IsInstalled) THEN
    // Es gibt kein Filesystem, oder das OS ist so alt, dass es nicht weiß ob eines vorhanden ist
    RETURN;
  END_IF;
  
#ifdef UNIT_TEST
  IF !!UT_ScanInt() THEN
    result := FALSE;
    RETURN;
  END_IF;
  
  IF !!UT_ScanReal() THEN
    result := FALSE;
    RETURN;
  END_IF;
  
  IF !!UT_WildcardMatch() THEN
    result := FALSE;
    RETURN;
  END_IF;
#endif

  IF actionCode = PRJCFG_CREATE_INITVAL_DICT THEN
#ifdef UNIT_TEST
    allocCnt := 0;
#endif    
    initvalDict := NIL;
  END_IF;
  IF actionCode = PRJCFG_DESTROY_INITVAL_DICT THEN
    InitvalDictFreeAll();
#ifdef UNIT_TEST
    IF allocCnt <> 0 THEN
      result := FALSE;
    END_IF;
#endif
    RETURN;
  END_IF;

  cfstate_ := LDR_ConnFile_Init(#err);
  IF cfstate_ = NIL THEN
    IF err THEN
      TRACE_ERR("error reading prjcfg.lcf");
      result := FALSE;
    END_IF;
    RETURN; // File existiert nicht oder zuwenig Speicher
  END_IF;
  
  // Alle Zeilen einlesen und bearbeiten
  WHILE TRUE DO 
WhileContinue:  
    len := LDR_ConnFile_ReadLine(cfstate_, #pBuf);
    IF len < 0 THEN
      TRACE_ERR("error reading prjcfg.lcf");
      result := FALSE;
      EXIT;
    END_IF;
    IF len = 0 THEN
      EXIT; // Ende des Files
    END_IF;
    IF len < 3 THEN
      // Kürzere Zeilen als 3 Zeichen sind unbekannte Record-Typen und werden übersprungen
      // Zeichen: <Rec-Typ>,":","\0"
      GOTO WhileContinue; 
    END_IF;
    
    // Rec0: Projektname
    IF pBuf^ = '0' & (pBuf+1)^ = ':' THEN
      IF (pBuf+2)^ = ':' THEN
        rc := ParseLcfRec0(pBuf+3); // beim neuen Format werden 2 ':' als Trennzeichen verwendet
      ELSE
        rc := ParseLcfRec0(pBuf+2);
      END_IF;
      IF rc < 0 THEN
        TRACE0_ERR("prjcfg.lcf: parsing error 1, line: {0}", pBuf);
        LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
        result := FALSE;
        EXIT;
      END_IF;
      IF rc = 0 THEN
        TRACE_WARN("ignoring prjcfg.lcf (different project-name)");
        EXIT;
      END_IF;
      
    // Rec1,2: Clt-Svr Verbindung
    ELSIF (pBuf^ = '1' | pBuf^ = '2') & ((pBuf+1)^ = ':') & (actionCode = PRJCFG_CONNECT) THEN
      rc := ParseLcfRec1(pBuf+2, #source, #dest);
      IF rc < 0 THEN
        TRACE0_ERR("prjcfg.lcf: parsing error 2, line: {0}", pBuf);
        LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
        result := FALSE;
        EXIT;
      END_IF;
      
      IF !!ProcessConnectionFileRecord12(source, dest) THEN
        TRACE1_ERR("prjcfg.lcf: connect '{0}' to '{1}' failed", source, dest);
        LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
        result := FALSE;
        EXIT;
      END_IF;
      
    // Rec4,5: Initwerte
    ELSIF (pBuf^ = '4' | pBuf^ = '5') & ((pBuf+1)^ = ':') & (actionCode = PRJCFG_CREATE_INITVAL_DICT) THEN
      rc := ParseLcfRec4(pBuf+2, #source, #value, #datalen);
      IF rc < 0 THEN
        TRACE0_ERR("prjcfg.lcf: parsing error 3, line: {0}", pBuf);
        LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
        result := FALSE;
        EXIT;
      END_IF;
      IF rc = 1 THEN
        fString := FALSE;
      ELSIF rc = 2 THEN
        fString := TRUE;
      END_IF;
      IF !!InitvalDictAdd(fString, source, value, dataLen) THEN
        TRACE_ERR("prjcfg.lcf: InitvalDictAdd failed");
        LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
        result := FALSE;
        EXIT;
      END_IF;
        
    // Rec7: Versionsnummer (Major.Minor)
    ELSIF pBuf^ = '7' & (pBuf+1)^ = ':' THEN
      rc := ParseLcfRec7(pBuf+2);
      IF rc < 0 THEN
        TRACE0_ERR("prjcfg.lcf: parsing error 4, line: {0}", pBuf);
        LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
        result := FALSE;
        EXIT;
      END_IF;
      IF rc = 0 THEN
        TRACE_ERR("incompatible version of prjcfg.lcf");
        result := FALSE;
        EXIT;
      END_IF;
      
    END_IF;
    
  END_WHILE;

  LDR_ConnFile_Release(cfstate_);
  
END_FUNCTION


(* Liefert TRUE, wenn im prjcfg File Initwerte eingetragen sind, sonst FALSE *)
FUNCTION GLOBAL ConnectReader::InitvalsInPrjcfg
  VAR_OUTPUT
    result 	: BOOL;
  END_VAR
  
  IF initvalDict = NIL THEN
    result := FALSE;
  ELSE
    result := TRUE;
  END_IF;

END_FUNCTION


(* Initialisiert bei ienem Objekt den 4 Byte Wert mit dem im prjcfg vorhandenen Wert *)
FUNCTION GLOBAL ConnectReader::InitByPrjcfg
	VAR_INPUT
		pObj 	: ^Obj;
    f4Byte : BOOL; // Flag ist True wenn 4-Byte Werte initialisiert werden sollen (False bei einem String)
	END_VAR
  VAR
    CRC : UDINT;
	  pInitval : ^InitvalEntry;
    searchRes : pVoid;
  END_VAR

  CRC :=	pObj^.pObjDsc^.SymName.udCRC;

  searchRes := HashTable_Find(CRC$pVoid, initvalDict, NIL);
  IF searchRes THEN
    pInitval$pVoid := HashTable_RetrieveVal(searchRes);
    // Unter der CRC des Objekts ist eine Liste mit Initwerten gespeichert. 
    // Diese Liste wird jetzt durchgegangen die Channels werden mit diesen 
    // Werten initialisiert.
    WHILE pInitval <> NIL DO
      IF f4Byte & pInitval^.datalen = 0 THEN
        IF LcfInit4ByteValue(pObj, pInitval^.chName, pInitval^.value$DINT) <> C_OK THEN
          TRACE0_ERR("prjcfg.lcf: setting initvalue of '{0}' failed", pInitval^.chName);
          LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
        END_IF;
      END_IF;
      IF !!f4Byte & pInitval^.datalen <> 0 THEN
        IF LcfInitStringValue(pObj, pInitval^.chName, pInitval^.value$^USINT, pInitval^.datalen) <> C_OK THEN
          TRACE0_ERR("prjcfg.lcf: setting initvalue of '{0}' failed", pInitval^.chName);
          LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
        END_IF;
      END_IF;
      pInitval := pInitval^.pNext;
    END_WHILE;
  END_IF;

END_FUNCTION


(* Liest eine Zeile vom File in den angegebenen Buffer. 
   Das Zeilenende-Zeichen wird nicht in den Buffer gestellt.
   Leerzeilen werden übersprungen.
   Die eingelesene Zeile wird mit einem 0-Zeichen terminiert.
   
   Der Buffer wird in der Funktion am Heap allokiert bzw. reallokiert und 
   muss am Ende vom Aufrufer freigegeben werden. Beim ersten Aufruf kann 
   NIL als Buffer angegeben werden, bei den folgenden Aufrufen muss immer 
   wieder der gleiche Zeiger mitgegeben werden. 
   Die pBufLen Variable wird nur intern verwendet, um die allokierte Größe 
   des Buffers über mehrere Aufrufe hinweg mitzuführen.
   
   Zurückgegeben wird die Länge der Zeile oder 0 wenn das Fileende erreicht 
   ist. Bei einem Fehler wird ein neg.Wert zurückgegeben.
*)

FUNCTION WildcardMatch
  VAR_INPUT
    lpStrCheckPrj : ^CHAR;
    lpStrPrj : ^CHAR;
  END_VAR
  VAR_OUTPUT
    result : BOOL;
  END_VAR
  VAR
    cp : ^CHAR;
    mp : ^CHAR;
    cPrj : CHAR;
    cWild : CHAR;
  END_VAR

  result := FALSE;

  cp := NIL;
  mp := NIL;

  // Durchlaufen des zu überprüfenden Strings.
  WHILE lpStrPrj^ <> 0 DO
    cPrj := lpStrPrj^;
    cWild := lpStrCheckPrj^;

    // Wenn nötig Lowercase machen
    IF cPrj >= 'A' & cPrj <= 'Z' THEN
      cPrj -= ('A' - 'a');
    END_IF;

    // Wenn nötig Lowercase machen
    IF cWild >= 'A' & cWild <= 'Z' THEN
      cWild -= ('A' - 'a');
    END_IF;

    IF cWild = '*' THEN
      // Wildcard String am Ende? -> Match.
      lpStrCheckPrj += 1;
      IF lpStrCheckPrj^ = 0 THEN
        result := TRUE;
        RETURN;
      END_IF;

      mp := lpStrCheckPrj;
      cp := lpStrPrj + 1;
      
    // Stimmt das aktuelle zeichen überein?
    ELSIF (((cWild = cPrj) & (cWild <> '#'))
        | (cWild = '?')
        | ((cWild = '#') & (cPrj >= '0' & cPrj <= '9'))) THEN
      // Dann weiter im Text...
      lpStrCheckPrj += 1;
      lpStrPrj += 1;
      
    ELSE
      // Kam vorher ein '*'?
      IF mp <> NIL THEN
        lpStrCheckPrj := mp;
        lpStrPrj := cp;
        cp += 1;
      // Wenn nicht dann haben wir definitiv kein Match.
      ELSE
        RETURN;
      END_IF;
      
    END_IF;
  END_WHILE;

  // Der zu überprüfende String ist fertig durchlaufen
  // -> Alle '*' im Wildcardstring überspringen.

  WHILE lpStrCheckPrj^ = '*' DO
    lpStrCheckPrj += 1;
  END_WHILE;

  // Wildcardstring am Ende? -> Match
  IF lpStrCheckPrj^ = 0 THEN
    result := TRUE;
  END_IF;


END_FUNCTION


(* Parst einen LasalConnectionFile Record 0 ("Projektname") 

   Return:
    1 .. der Projektname im lcf-File stimmt mit dem aktuellen Projekt überein
    0 .. der Projektname im lcf-File stimmt mit dem aktuellen Projekt nicht überein
   <0 .. Fehler
   
*)
FUNCTION ConnectReader::ParseLcfRec0
	VAR_INPUT
		pBuf 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR
  VAR
  	pISysSernum : ^LSL_ISYSSERNUM;
    plcinfo : ^LSL_PLCINFO;
    prjname : ^CHAR;
  END_VAR
  
  OS_CILGet("ISYSSERNUM", #pISysSernum$void);
  IF pISysSernum = NIL THEN
    result := -1;             // Projektname kann nicht ermittelt werden
    RETURN;
  END_IF;

  prjname := ScanQuotedString(#pBuf);
  IF prjname = NIL THEN
    result := -1;
    RETURN;
  END_IF;
  
  // aktuellen Projektnamen ermitteln und mit dem im prjcfg File angegebenen Namen vergleichen
  plcinfo := ISYSSERNUM_SERNUMGETPLCINFO();
  IF WildcardMatch(prjname, #plcinfo^.szApplication[0]) THEN
    result := 1;
  ELSE
    result := 0;
  END_IF;

END_FUNCTION


(* Parst einen LasalConnectionFile Record 1 ("Quelle","Ziel") 

   Return:
    0 .. ok
   <0 .. Fehler
   
*)
FUNCTION ConnectReader::ParseLcfRec1
	VAR_INPUT
		pBuf 	: ^CHAR;
		ppSource 	: ^pChar;
		ppDest 	: ^pChar;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR
  
  ppSource^ := ScanQuotedString(#pBuf);
  IF ppSource^ = NIL THEN
    result := -1;
    RETURN;
  END_IF;
  
  IF pBuf^ <> ',' THEN
    result := -1;
    RETURN;
  END_IF;
  pBuf += 1;

  ppDest^ := ScanQuotedString(#pBuf);
  IF ppDest^ = NIL THEN
    result := -1;
    RETURN;
  END_IF;

  result := 0;

END_FUNCTION


FUNCTION strncmp
  VAR_INPUT
    str1 : pChar;
    str2 : pChar;
    cnt : UDINT;
  END_VAR
  VAR_OUTPUT
    result : DINT;
  END_VAR
  
  result := 0;
  
  WHILE cnt > 0 DO 
    result := str1^ - str2^;
    IF (result <> 0) | (str1^ = 0) THEN
      RETURN;
    END_IF;
    cnt -= 1;
    str1 += 1;
    str2 += 1;
  END_WHILE;
  
END_FUNCTION


(* Parst einen LasalConnectionFile Record 4 ("Quelle","Initwert") 

   Das Ergebnis wird auf pValue und pLen geschrieben.
   Bei einem 4 Byte Initwert:
     Der Wert steht auf pValue, pLen wird nicht gesetzt
   Bei einem String Initwert:
     Der Zeiger auf den String steht auf pValue, die Länge (inkl. 0-Zeichen) auf pLen

   Return:
    1 .. 4-Byte Initwert
    2 .. String Initwert
   <0 .. Fehler
*)
FUNCTION ConnectReader::ParseLcfRec4
	VAR_INPUT
		pBuf 	: ^CHAR;
		ppSource 	: ^pChar;
		pValue 	: ^UDINT;
		pLen 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR
  VAR
		pPart2 	: pChar;
  END_VAR
  
  ppSource^ := ScanQuotedString(#pBuf);
  IF ppSource^ = NIL THEN
    result := -1;
    RETURN;
  END_IF;
  
  IF pBuf^ <> ',' THEN
    result := -1;
    RETURN;
  END_IF;
  pBuf += 1;

  pPart2 := ScanQuotedString(#pBuf);
  IF pPart2 = NIL THEN
    result := -1;
    RETURN;
  END_IF;

  IF strncmp(pPart2, "string:", 7) = 0 THEN
    pValue^ := (pPart2 + 7)$UDINT;
    pLen^ := _strlen(pPart2 + 7) + 1;
    result := 2;
    RETURN;
  END_IF;

  IF strncmp(pPart2, "real:", 5) = 0 THEN
    IF !!ScanReal(pPart2 + 5, pValue$^REAL) THEN
      result := -1;
    ELSE
      result := 1;
    END_IF;
    RETURN;
  END_IF;

  IF !!ScanInt(pPart2, pValue, 0) THEN
    result := -1;
  ELSE
    result := 1;
  END_IF;

END_FUNCTION


#define LCF_MAX_MAJOR_VER   1
(* Parst einen LasalConnectionFile Record 7 ("Majorver.Minorver") 

   Return:
    1 .. es handelt sich um eine kompatible Version (Majorver ist klein genug)
    0 .. es handelt sich um eine inkompatible Version (Majorver ist zu groß)
   <0 .. Fehler
   
*)
FUNCTION ConnectReader::ParseLcfRec7
	VAR_INPUT
		pBuf 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR
  VAR
    majorVer : UDINT;
    minorVer : UDINT;
		quotStr 	: pChar;
    nScanned : UDINT;
  END_VAR
  
  quotStr := ScanQuotedString(#pBuf);
  IF quotStr = NIL THEN
    result := -1;
    RETURN;
  END_IF;
  
  nScanned := ScanInt(quotStr, #majorVer, '.');
  IF !!nScanned THEN
    result := -1;
    RETURN;
  END_IF;
  
  quotStr := quotStr + nScanned + 1;
  
  IF !!ScanInt(quotStr, #minorVer, 0) THEN
    result := -1;
    RETURN;
  END_IF;
  

  IF majorVer <= LCF_MAX_MAJOR_VER THEN
    result := 1;
  ELSE
    result := 0;
  END_IF;

END_FUNCTION


(* Fischt einen String zwischen zwei Hochkommas heraus.
   
   Zurückgegeben wird der String nach dem ersten Hochkomma, dabei werden 
   die Escape-Sequenzen '\"' und '\\' zu den Einzelzeichen '"' und '\' 
   reduziert. Am Ende wird ein 0-Zeichen eingetragen.
   Im Fehlerfall wird NIL zurückgegeben.

   Der Ein-/Ausgangs-Parameter ppScan wird auf das erste Zeichen nach dem 
   abschließenden Hochkomma gestellt.
*)
FUNCTION ConnectReader::ScanQuotedString
	VAR_INPUT
		ppScan 	: ^pChar;
	END_VAR
	VAR_OUTPUT
		result 	: ^CHAR;
	END_VAR
  VAR
		pScan 	: ^CHAR;
    pReduced : ^CHAR;
  END_VAR

  pScan := ppScan^;
  // erstes Hochkamma prüfen
  IF pScan^ <> '"' THEN
    result := NIL;
    RETURN;
  END_IF;
  
  pScan += 1; // erstes Hochkomma überspringen
  result := pScan;
  pReduced := pScan;
  
  WHILE TRUE DO 
  
    IF pScan^ = 0 THEN
      // das Stringende wurde vorzeitig erkannt -> zurück mit Fehler
      result := NIL;
      RETURN;
    END_IF;

    IF pScan^ = '\' THEN
      // es wurde ein Escape-Zeichen gefunden 
      IF (pScan + 1)^ = '\' | (pScan + 1)^ = '"' THEN
        // es handelt sich um eine gültige Esc-Sequenz -> das Escape-Zeichen übersprungen
        pScan += 1;
      END_IF;
    ELSIF pScan^ = '"' THEN
      // das 2.Hochkomma wurde gefunden -> Schleife abbrechen
      EXIT;
    END_IF;
    
    pReduced^ := pScan^; // Zeichen umkopieren
    
    pScan += 1;
    pReduced += 1;
    
  END_WHILE;

  pReduced^ := 0; // Abschliessendes 0-Zeichen eintragen
  ppScan^ := pScan + 1;

END_FUNCTION


#ifdef UNIT_TEST
FUNCTION ConnectReader::UT_WildcardMatch
  VAR_OUTPUT
    result : BOOL;
  END_VAR
  
  IF !!WildcardMatch("", "") THEN
    TRACE_ERR("WildcardMatch failed 1");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("a", "A") THEN
    TRACE_ERR("WildcardMatch failed 2");
    result := FALSE;
  END_IF;
  
  IF WildcardMatch("a", "b") THEN
    TRACE_ERR("WildcardMatch failed 3");
    result := FALSE;
  END_IF;
  
  IF WildcardMatch("A", "") THEN
    TRACE_ERR("WildcardMatch failed 4");
    result := FALSE;
  END_IF;
  
  IF WildcardMatch("", "A") THEN
    TRACE_ERR("WildcardMatch failed 5");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("*", "") THEN
    TRACE_ERR("WildcardMatch failed 6");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("*", "a") THEN
    TRACE_ERR("WildcardMatch failed 7");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("*", "ab") THEN
    TRACE_ERR("WildcardMatch failed 8");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("a*", "a") THEN
    TRACE_ERR("WildcardMatch failed 9");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("a*", "ab") THEN
    TRACE_ERR("WildcardMatch failed 10");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("a*", "abc") THEN
    TRACE_ERR("WildcardMatch failed 11");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("a*c", "ac") THEN
    TRACE_ERR("WildcardMatch failed 12");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("a*c", "abc") THEN
    TRACE_ERR("WildcardMatch failed 13");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("*c", "abc") THEN
    TRACE_ERR("WildcardMatch failed 14");
    result := FALSE;
  END_IF;
  
  IF WildcardMatch("*a", "b") THEN
    TRACE_ERR("WildcardMatch failed 15");
    result := FALSE;
  END_IF;
  
  IF WildcardMatch("a*", "b") THEN
    TRACE_ERR("WildcardMatch failed 16");
    result := FALSE;
  END_IF;
  
  IF WildcardMatch("a*a", "a") THEN
    TRACE_ERR("WildcardMatch failed 17");
    result := FALSE;
  END_IF;
  
  IF WildcardMatch("a*a*", "a") THEN
    TRACE_ERR("WildcardMatch failed 18");
    result := FALSE;
  END_IF;
  
  IF WildcardMatch("*a*a*", "abc") THEN
    TRACE_ERR("WildcardMatch failed 19");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("*a*a*", "aba") THEN
    TRACE_ERR("WildcardMatch failed 20");
    result := FALSE;
  END_IF;
  
  IF WildcardMatch("?", "") THEN
    TRACE_ERR("WildcardMatch failed 21");
    result := FALSE;
  END_IF;
  
  IF !!WildcardMatch("?", "a") THEN
    TRACE_ERR("WildcardMatch failed 22");
    result := FALSE;
  END_IF;
  
  IF WildcardMatch("a?", "a") THEN
    TRACE_ERR("WildcardMatch failed 23");
    result := FALSE;
  END_IF;
  
  IF WildcardMatch("?a", "a") THEN
    TRACE_ERR("WildcardMatch failed 24");
    result := FALSE;
  END_IF;
  
END_FUNCTION

FUNCTION ConnectReader::UT_ScanInt
  VAR_OUTPUT
    result : BOOL;
  END_VAR
  VAR
    value : UDINT;
  END_VAR
  
  result := TRUE;

  IF !!ScanInt("1", #value, 0) or (value <> 1) THEN
    TRACE_ERR("ScanInt failed 1");
    result := FALSE;
  END_IF;
  IF !!ScanInt("4294967295", #value, 0) or (value <> 4294967295) THEN // max.UDINT
    TRACE_ERR("ScanInt failed 2");
    result := FALSE;
  END_IF;
  IF ScanInt("4294967296", #value, 0)  THEN // max.UDINT + 1   -> Fehler
    TRACE_ERR("ScanInt failed 3");
    result := FALSE;
  END_IF;
  IF !!ScanInt("-1", #value, 0) or (value$DINT <> -1) THEN
    TRACE_ERR("ScanInt failed 4");
    result := FALSE;
  END_IF;
  IF !!ScanInt("2147483647", #value, 0) or (value$DINT <> 2147483647) THEN // max.+DINT
    TRACE_ERR("ScanInt failed 5");
    result := FALSE;
  END_IF;
  IF !!ScanInt("-2147483648", #value, 0) or (value$DINT <> -2147483648) THEN // max.-DINT
    TRACE_ERR("ScanInt failed 6");
    result := FALSE;
  END_IF;
  IF !!ScanInt("2147483648", #value, 0) or (value <> 2147483648) THEN // max.+DINT + 1   -> kein Fehler, da beim Scan bei pos. Werten nicht zwischen UDINT und DINT unterschieden wird
    TRACE_ERR("ScanInt failed 7");
    result := FALSE;
  END_IF;
  IF ScanInt("-2147483649", #value, 0) THEN // max.-DINT - 1   -> Fehler
    TRACE_ERR("ScanInt failed 8");
    result := FALSE;
  END_IF;
  
END_FUNCTION


FUNCTION ConnectReader::UT_ScanReal
  VAR_OUTPUT
    result : BOOL;
  END_VAR
  VAR
    value : UDINT;
  END_VAR
  
  result := TRUE;

  IF !!ScanReal(".", #value$REAL) or (value$REAL <> 0.0) THEN
    TRACE_ERR("ScanReal failed 1");
    result := FALSE;
  END_IF;
  IF !!ScanReal("1.", #value$REAL) or (value$REAL <> 1.0) THEN
    TRACE_ERR("ScanReal failed 2");
    result := FALSE;
  END_IF;
  IF !!ScanReal(".1", #value$REAL) or (value$REAL <> 0.1) THEN
    TRACE_ERR("ScanReal failed 3");
    result := FALSE;
  END_IF;
  IF !!ScanReal("-1.", #value$REAL) or (value$REAL <> -1.0) THEN
    TRACE_ERR("ScanReal failed 4");
    result := FALSE;
  END_IF;
  IF !!ScanReal("-.1", #value$REAL) or (value$REAL <> -0.1) THEN
    TRACE_ERR("ScanReal failed 5");
    result := FALSE;
  END_IF;
  IF !!ScanReal("12345.6789", #value$REAL) or (value$REAL <> 12345.6789) THEN
    TRACE_ERR("ScanReal failed 6");
    result := FALSE;
  END_IF;
  IF !!ScanReal("-12345.6789", #value$REAL) or (value$REAL <> -12345.6789) THEN
    TRACE_ERR("ScanReal failed 7");
    result := FALSE;
  END_IF;
  IF ScanReal("-12345.a789", #value$REAL) or (value$REAL <> -12345.6789) THEN
    TRACE_ERR("ScanReal failed 8");
    result := FALSE;
  END_IF;
  
END_FUNCTION
#endif // UNIT_TEST


(* Scant einen Integer Wert (pos. oder neg.). 
   Liefert die Anzahl der gescannten Zeichen, wenn ein Wert gescannt werden konnte, sonst 0
*)
FUNCTION GLOBAL ConnectReader::ScanInt
  VAR_INPUT
    pScan 	: pChar;
    pValue 	: ^UDINT;
    terminator : CHAR;
  END_VAR
  VAR_OUTPUT
    result 	: UDINT;
  END_VAR
  VAR
  	sign : INT;
    value : UDINT;
    oldValue : UDINT;
    pFirstChar 	: pChar;
  END_VAR

  result := 0;
  pFirstChar := pScan;
  
  IF pScan^ = '-' THEN
    sign := -1;
    pScan += 1;
  ELSE
    sign := 1;
  END_IF;
  
  value := 0;
  WHILE (pScan^ >= '0' & pScan^ <= '9') DO 
    oldValue := value;
    value := value * 10 + pScan^ - '0';
    IF oldValue > value THEN
      (* overflow *)
      RETURN;
    END_IF;
    pScan += 1;
  END_WHILE;
  
  IF pScan^ <> terminator THEN
    RETURN;
  ELSE
    IF sign < 0 THEN
      IF value > 0x80000000 THEN
        (* overflow *)
        RETURN;
      END_IF;
      pValue$^DINT^ := -(value$DINT);
    ELSE
      pValue^ := value;
    END_IF;
  END_IF;
  
  result := pScan$UDINT - pFirstChar$UDINT;
    
END_FUNCTION


(* Scant einen Real Wert (pos. oder neg., keine Exponentialdarstellung). 
   Liefert True, wenn ein Wert gescannt werden konnte.
*)
FUNCTION ConnectReader::ScanReal
  VAR_INPUT
    pScan 	: pChar;
    pValue 	: ^REAL;
  END_VAR
  VAR_OUTPUT
    result 	: BOOL;
  END_VAR
  VAR
  	sign : INT;
    value : REAL;
    decimals : INT;
  END_VAR

  IF pScan^ = '-' THEN
    sign := -1;
    pScan += 1;
  ELSE
    sign := 1;
  END_IF;
  
  value := 0.0;
  WHILE (pScan^ >= '0' & pScan^ <= '9') DO 
    value := value * 10.0 + pScan^ - '0';
    pScan += 1;
  END_WHILE;
  
  IF pScan^ = '.' THEN
    pScan += 1;
    decimals := 0;
    WHILE (pScan^ >= '0' & pScan^ <= '9') DO 
      value := value * 10.0 + pScan^ - '0';
      pScan += 1;
      decimals += 1;
    END_WHILE;
    WHILE decimals > 0 DO 
      value := value / 10.0;
      decimals -= 1;
    END_WHILE;
  END_IF;
    
  IF pScan^ <> 0 THEN
    result := FALSE;
  ELSE
    pValue^ := value * sign;
    result := TRUE;
  END_IF;
    
END_FUNCTION


(* Liefert die Adresse eines Clients (ohne bei den IO-Elementen nachzuschauen).
  Return: Adresse des Servers oder NIL wenn nicht gefunden *)
FUNCTION ConnectReader::LookupCltCh
	VAR_INPUT
		pCltName : ^CHAR;
	END_VAR
	VAR_OUTPUT
    pObj_ChClt : ^CltCh;
	END_VAR
  VAR
    eChMode : ChMode;
  END_VAR
  
  eChMode := LDR_LookupEmbedded3(NIL, #pCltName, #pObj_ChClt, NIL);

  CASE eChMode OF
  _CH_NONE:
    pObj_ChClt := NIL;
    RETURN;					// unknown channel or object name
  _CH_OBJ,
  _CH_SVR,
  _CH_CMD,
  _CH_SVR_OBJ:
    pObj_ChClt := NIL;
    RETURN;					// a server channel can't be connected
  END_CASE;
  
END_FUNCTION


(* Liefert die Adresse eines Servers, wobei angegeben werden kann, ob bei den 
  den IO-Elementen nachgeschaut wird oder nicht.
  Return: Adresse des Servers oder NIL wenn nicht gefunden *)
FUNCTION ConnectReader::LookupSvrCh
	VAR_INPUT
		pSvrName 	: ^CHAR;
		ppObj 	: ^pVirtualBase;
    lookupIoEl : BOOL;
	END_VAR
	VAR_OUTPUT
		pObj_ChSvr 	: ^SvrCh;
	END_VAR
  VAR
    eChMode : ChMode;
  END_VAR
  
  IF lookupIoEl THEN
    eChMode := _LookupEmbedded(#pSvrName, #pObj_ChSvr, ppObj);
  ELSE
    eChMode := LDR_LookupEmbedded3(NIL, #pSvrName, #pObj_ChSvr, ppObj);
  END_IF;

  CASE eChMode OF
  _CH_NONE,
  _CH_CLT_CMD,
  _CH_CLT_DATA,
  _CH_CLT_EMB,
  _CH_CLT_OBJ:
    pObj_ChSvr := NIL;
    RETURN;                     // a server channel can't be connected
  END_CASE;
  
END_FUNCTION


(* Stellt die Verbindung zw. dem Client und dem Server her *)
FUNCTION ConnectReader::LcfConnect
	VAR_INPUT
		pCltName 	: ^CHAR;
		pSvrName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		ret_code 	: CONFSTATES;
	END_VAR
  VAR
    eChMode			: ChMode;
    pObj_ChClt		: ^CltCh;
    pObj_ChSvr		: ^SvrCh;
    pObjSvr			: ^VirtualBase;
  END_VAR

  eChMode := _LookupEmbedded(#pCltName, #pObj_ChClt, NIL);

  CASE eChMode OF
  _CH_NONE:
    ret_code := C_UNKNOWN_CHNL;
    RETURN;					// unknown channel or object name
  _CH_OBJ,
  _CH_SVR,
  _CH_CMD,
  _CH_SVR_OBJ:
    ret_code := C_UNKNOWN_CHNL;
    RETURN;					// a server channel can't be connected
  END_CASE;

  eChMode := _LookupEmbedded(#pSvrName, #pObj_ChSvr, #pObjSvr);

  CASE eChMode OF
  _CH_NONE,
  _CH_CLT_CMD,
  _CH_CLT_DATA,
  _CH_CLT_EMB,
  _CH_CLT_OBJ:
    ret_code := C_UNKNOWN_CHNL;
    RETURN;                     // a server channel can't be connected
  END_CASE;

  pObj_ChClt^.pCh	:= pObj_ChSvr;
  pObj_ChClt^.pCmd	:= pObjSvr;

  ret_code := C_OK;
  
END_FUNCTION


(* Initialisiert einen Server mit einem 4 Byte Wert *)
FUNCTION ConnectReader::LcfInit4ByteValue
  VAR_INPUT
    pObj 	: ^Obj;
    pSvrName 	: ^CHAR;
    value : DINT;
  END_VAR
  VAR_OUTPUT
    ret_code 	: CONFSTATES;
  END_VAR
  VAR
    eChMode			: ChMode;
    pObj_ChSvr		: ^SvrCh;
    pObjSvr			: ^VirtualBase;
  END_VAR

  eChMode := LDR_LookupEmbedded2(LSL_GetPtr(pObj), #pSvrName, #pObj_ChSvr, #pObjSvr);

  CASE eChMode OF
  _CH_NONE:
    ret_code := C_UNKNOWN_CHNL;
    RETURN;                     
  END_CASE;

  pObj_ChSvr^.dData := value;

  ret_code := C_OK;
  
END_FUNCTION


(* Initialisiert einen Server mit einem String *)
FUNCTION ConnectReader::LcfInitStringValue
  VAR_INPUT
    pObj 	: ^Obj;
    pSvrName 	: ^CHAR;
    pData		: ^USINT;
    udLen		: UDINT;
  END_VAR
  VAR_OUTPUT
    ret_code 	: CONFSTATES;
  END_VAR
  VAR
    eChMode			: ChMode;
    pObj_ChSvr		: ^SvrCh;
    pObjSvr			: ^VirtualBase;
  END_VAR

  eChMode := LDR_LookupEmbedded2(LSL_GetPtr(pObj), #pSvrName, #pObj_ChSvr, #pObjSvr);

  CASE eChMode OF
  _CH_NONE:
    ret_code := C_UNKNOWN_CHNL;
    RETURN;                     
  END_CASE;

	pObj_ChSvr$^VirtualBaseInit^.InitFromTable(udLen, pData);

  ret_code := C_OK;
  
END_FUNCTION


FUNCTION GLOBAL ConnectReader::SkipExtConnection
	VAR_INPUT
		pObjRd 	: ^ObjectReader;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  
  this^.pObjRd	:= pObjRd;

	SkipConOffString();				// ConType, Off, CRC, Obj.Server
  SkipConObjNoStringString();	// ConType, ObjNo.Client -> CRC, Obj.Server
  SkipSetMagicOffOffObj();
  SkipSetMagicObjNoClt_ObjNoClt();
  
  ok := TRUE;

END_FUNCTION

FUNCTION  ConnectReader::SkipConOffString
VAR
	nCon	: UDINT;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		RETURN;
	END_IF;

	WHILE nCon > 0 DO
     pObjRd^.GetCount(); //objectoff
    SkipSetExtConnectToClt();
		nCon	-= 1;
	END_WHILE;

END_FUNCTION // ConnectReader::SkipConOffString

FUNCTION  ConnectReader::SkipConObjNoStringString
VAR
	nCon	: UDINT;
  iCltNr  : udint;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		RETURN;
	END_IF;

  iCltNr := 0;

	WHILE nCon > 0 DO				// alle angegebenen Verbindungspaare einlesen
    iCltNr += 1;
    pObjRd^.GetCount(); // objnummer
    SkipGetChPtr(); //GetChPtr
    SkipSetExtConnectToClt();
		nCon	-= 1;
	END_WHILE;


END_FUNCTION // ConnectReader::SkipConObjNoStringString
FUNCTION ConnectReader::SkipSetMagicOffOffObj
VAR
	nCon	: UDINT;
END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		RETURN;
	END_IF;

	WHILE nCon > 0 DO
    pObjRd^.GetCount();
    pObjRd^.GetCount();
		pObjRd^.GetCount();   
		nCon	-= 1;
	END_WHILE;


END_FUNCTION
FUNCTION ConnectReader::SkipSetMagicObjNoClt_ObjNoClt
  VAR
    nCon	: UDINT;
  END_VAR

	nCon	:= pObjRd^.GetCount();

	IF nCon = 0 THEN
		RETURN;
	END_IF;

	WHILE nCon > 0 DO				// alle angegebenen Verbindungspaare einlesen
		pObjRd^.GetCount();   // embedded Objekt
    SkipGetChPtr();
		pObjRd^.GetCount();   // äußeres, komplexes Objekt
    SkipGetChPtr();
		nCon	-= 1;
	END_WHILE;

END_FUNCTION

FUNCTION ConnectReader::SkipSetExtConnectToClt
  
  pObjRd^.GetUInt(); // uitry 
     
  pObjRd^.ReadLexem(); 
 
  SkipGetChPtr();
  
END_FUNCTION


FUNCTION ConnectReader::SkipGetChPtr
 
  IF pObjRd^.pTable^ $ char = 0 THEN    // wenn ein 0-String angegeben ist, dann wird das Objekt angesprochen
    pObjRd^.pTable  += 1;               // 0-er überlesen
  ELSE
    pObjRd^.SkipText();	// Kanalnamen überlesen
  END_IF;
 
END_FUNCTION
