//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#include "RTOS_IprIntern.h"

#pragma using ProgIp
#pragma using DebugIp
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "IprMgr"
	Revision           = "0.0"
	GUID               = "{059F1587-0A4E-4CDE-B7C1-CAE5F33D400B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{FDC3DB0C-C3A1-460F-83BF-450D24CC0FD0}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
</Class>
*)
IprMgr : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION GLOBAL StartInit
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bInitFound 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL StartMain
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bMainFound 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL StartInterpreter
		VAR_INPUT
			nActProg 	: UDINT;
			bProgChanged 	: BOOL;
			usMode 	: USINT := LOAD_DEFAULT;
		END_VAR;
	
	FUNCTION GLOBAL ProgSequences;
	
	FUNCTION GLOBAL GetInterpreter
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pp 	: ^ProgIp;
		END_VAR;
	
	FUNCTION GLOBAL GetIpObj
		VAR_INPUT
			useOsResources 	: BOOL;
		END_VAR
		VAR_OUTPUT
			ptCom 	: ^DebugIp;
		END_VAR;
	
	FUNCTION GLOBAL KillProgs;
	
	FUNCTION GLOBAL StartLabel
		VAR_INPUT
			nProgNo 	: UDINT;
			pName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			bFound 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetRegInterpreter
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pp 	: ^ProgIp;
		END_VAR;
	
	FUNCTION GLOBAL InitModule;
	
	FUNCTION GLOBAL HaltProgsImmediately;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB IprMgr::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_IPRMGR
0$UINT, 0$UINT, (SIZEOF(::IprMgr))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2191328620), "IprMgr", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::IprMgr.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
END_FUNCTION


#define USER_CNT_IprMgr 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_IprMgr] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION IprMgr::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

#pragma usingLtd DebugIp
#pragma usingLtd ProgIp

//{{LSL_IMPLEMENTATION
#include "RTOS_PrivDefs.h"
#include "RTOS_MemIntern.h"
#include ".\LoaderItf.h"

#pragma using ProgMgr

VAR_PRIVATE
  g_maxProgSeqDuration_ms : UDINT;  // max. Dauer für die Abarbeitung der Interpreterprogramme
  g_progSeqCycleTime_ms : UDINT;    // Zykluszeit für den Progsequences Aufruf (Abarbeitung der Interpreterprogramme)
  g_uiLastIpr : UINT;
  g_lastProgSeqCall : UDINT;
  g_maxNbrIprCmds : UDINT;   // max. Anzahl von Interpreterprogramm-Kommandos in einem Durchlauf (16#FFFFffff = kein Limit)

  // Millisekundenzähler, der nicht nur auf ops.tAbsolute sondern auch auf OS_GetMicroSec basiert
  // (wird benötigt, da ops.tAbsolute nicht aktualisiert wird, wenn der Realtime auf einem 
  // Breakpoint anhält)
	g_milliSecs_elapsed : UDINT; 
  g_nbrOfOpsTAbsoluteAccesses : UDINT;
  g_opsTAbsolute_start : UDINT;
  g_microSecs_start : UDINT;
END_VAR

(* 
  Setzt die Variablen für die Zeitmessung mit GetElapsedMillisecs zurück. 
  Mit ResetElapsedMilliSecs kann dann die verstrichenen Zeit in Millisekunden abgefragt werden.
*)
FUNCTION ResetElapsedMilliSecs
  g_milliSecs_elapsed := 0;
  g_nbrOfOpsTAbsoluteAccesses := 0;
  g_opsTAbsolute_start := ops.tAbsolute;
  g_microSecs_start := OS_GetMicroSec();
END_FUNCTION

(* 
  Aktualisiert die Variable g_milliSecs_elapsed.
  
  Im Unterschied zu ops.tAbsolute wird g_milliSecs_elapsed auch aktualisiert, wenn 
  der Realtime auf einem Breakpoint anhält.
*)
FUNCTION UpdateElapsedMilliSecs
VAR
	milliSecs_elapsed : UDINT;
END_VAR

  // Da OS_GetMicroSec länger braucht wie ein Zugriff auf ops.tAbsolute, wird 
  // OS_GetMicroSec nur 1 mal pro 100 Aufrufe verwendet.

  IF g_nbrOfOpsTabsoluteAccesses < 100 THEN
    g_nbrOfOpsTabsoluteAccesses += 1;
    milliSecs_elapsed := ops.tAbsolute - g_opsTAbsolute_start;
  ELSE
    g_nbrOfOpsTabsoluteAccesses := 0;
    milliSecs_elapsed := (OS_GetMicroSec() - g_microSecs_start) / 1000;
  END_IF;    

  IF milliSecs_elapsed > g_milliSecs_elapsed THEN
    g_milliSecs_elapsed := milliSecs_elapsed;
  END_IF;

END_FUNCTION

(*
  Liefert die seit dem Aufruf von ResetElapsedMilliSecs verstrichenen Millisekunden zurück.
*)
FUNCTION GetElapsedMillisecs
VAR_OUTPUT
	milliSecs : UDINT;
END_VAR

  UpdateElapsedMilliSecs();
  milliSecs := g_milliSecs_elapsed;

END_FUNCTION

// Initialisierungsfunktion für dieses Modul
FUNCTION GLOBAL IprMgr::InitModule

  g_maxProgSeqDuration_ms := 16#7FFFffff; // default: kein Limit
  g_progSeqCycleTime_ms := 0;
  g_maxNbrIprCmds := 16#FFFFffff; // default: kein Limit
  g_uiLastIpr := 16#ffff;
  g_lastProgSeqCall := 0;
  
END_FUNCTION

//Startet die Initfunktion eines Interpreters, falls eine vorhanden ist
FUNCTION IprMgr::StartInit
VAR_INPUT
	nProgNo	: UDINT;
END_VAR
VAR_OUTPUT
	bInitFound	: BOOL;
END_VAR
	
	bInitFound := StartLabel(nProgNo, "INIT");

END_FUNCTION

//Startet die MainFunktion eines Interpreters, falls vorhanden
FUNCTION GLOBAL IprMgr::StartMain
	VAR_INPUT
		nProgNo 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bMainFound 	: BOOL;
	END_VAR
  
  bMainFound  := StartLabel(nProgNo, "Main");

END_FUNCTION

FUNCTION GLOBAL IprMgr::StartLabel
	VAR_INPUT
		nProgNo 	: UDINT;
		pName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		bFound 	: BOOL;
	END_VAR
  VAR
    nLabelNr	: UDINT;
    pIpr		: ^ProgIp;
    pHead		: ^IprHead;
  END_VAR
	
	nLabelNr := ProgMgr::GetLabelNumber(nProgNo, pName);
	IF nLabelNr = INVALID_LABEL THEN
		bFound := FALSE;
		RETURN;
	END_IF;

	pIpr := IprMgr::GetInterpreter(nProgNo);
	pHead := pIpr^.GetHead();
	IF pIpr^.SetInstructionToProgStart(nLabelNr $ UINT) THEN
		pHead^.funkSt := READY;
	ELSE
		pHead^.funkSt := ERROR;
	END_IF;

	bFound := TRUE;

END_FUNCTION

FUNCTION GLOBAL IprMgr_StartLabel
	VAR_INPUT
		nProgNo 	: UDINT;
		pName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		bFound 	: BOOL;
	END_VAR
  
  bFound := IprMgr::StartLabel(nProgNo, pName);
  
END_FUNCTION

FUNCTION GLOBAL IprMgr::StartInterpreter
	VAR_INPUT
		nActProg 	: UDINT;
		bProgChanged 	: BOOL;
		usMode 	: USINT;
	END_VAR
  VAR
    pIpr		: ^ProgIp;
    pHead		: ^IprHead;
  END_VAR

	pIpr := GetInterpreter(nActProg);// get address of interpreter
	pHead := pIpr^.GetHead();

	// wenn ein IPR-Programm das 1.Mal gestartet wird, dann,
	// falls vorhanden, die Funktion INIT aufrufen
	IF bProgChanged & StartInit(nActProg) THEN
		RETURN;
	END_IF;

	// sonst falls vorhanden die Funktion MAIN aufrufen
	IF StartMain(nActProg) = FALSE THEN
		IF usMode = LOAD_ALWAYS THEN
			pHead^.FunkSt := READY;
		ELSE
			pHead^.FunkSt := ERROR;
		END_IF;
	END_IF;

END_FUNCTION

// returns a pointer to the interpreter program with the given number
//
FUNCTION GLOBAL IprMgr::GetInterpreter
	VAR_INPUT
		nProgNo 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pp 	: ^ProgIp;
	END_VAR

	pp := (#Ops.pSequDir^.pFirstIpr + nProgNo * sizeof(pProgIp))^$^ProgIp;

END_FUNCTION

// returns a pointer to the regular interpreter program with the given number
// when the number points to a temporary program, then the correpsonding regular 
// program is returned.
//
FUNCTION GLOBAL IprMgr::GetRegInterpreter
	VAR_INPUT
		nProgNo 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pp 	: ^ProgIp;
	END_VAR

	IF nProgNo >= MAX_IP_PROGS THEN
		nProgNo -= MAX_IP_PROGS;
	END_IF;
  
	pp := GetInterpreter(nProgNo);

END_FUNCTION

FUNCTION GLOBAL IprMgr_GetInterpreter
	VAR_INPUT
		nProgNo 	: UDINT;
	END_VAR
	VAR_OUTPUT
    pp 	: pVoid;
	END_VAR

	pp := IprMgr::GetInterpreter(nProgNo);

END_FUNCTION

//    
//    Controls the logic interpreter programs
//
FUNCTION GLOBAL IprMgr::ProgSequences
	VAR
		uiIpr 	: UINT;
		uiCnt 	: UINT;
		pIpr 	: ^ProgIp;
		tEnd 	: UDINT;
		tEndAllProgs 	: UDINT;
		bSetNext 	: UDINT;
		pHead 	: ^iprHead;
    oldFunkSt : iprStates;
    nbrIprCmdsAll : UDINT; // Zähler für die Anzahl von ausgeführten Interpreterkommandos (für alle Interpreter)
    nbrIprCmds : UDINT;    // Zähler für die Anzahl von ausgeführten Interpreterkommandos (pro Interpreter)
    maxNbrIprCmds : UDINT;
	END_VAR

  IF OPS.pProg = NIL THEN
    RETURN;
  END_IF;
  
  IF (OPS.tAbsolute - g_lastProgSeqCall) < g_progSeqCycleTime_ms THEN
    RETURN;
  END_IF;
  g_lastProgSeqCall := OPS.tAbsolute;

  // Now try to load the interpreter to the working memory
  // (diesen Aufruf gibt es seit der Loaderversion 01.01.035)
  BaseIp::CheckForLoad();
    
	uiCnt := 0;

  ResetElapsedMilliSecs();
  tEndAllProgs := g_maxProgSeqDuration_ms; // maximum time for all interpreter program
  nbrIprCmdsAll := 0;
  
  // Die IPR-Programme werden nicht von 0 bis (uiProgs-1) abgearbeitet sondern 
  // von der beim letzten Durchlauf abgearbeiteten Programmnummer g_uiLastIpr +1 
  // und von da an werden uiProgs Programme abgearbeitet.
  // Damit wird vermieden, daß ein loopendes Programm die Abarbeitung der 
  // dahinterliegenden Programme verhindert.
  uiIpr := g_uiLastIpr;
	WHILE (uiCnt < OPS.pProg^.uiProgs) 
      & ((tEndAllProgs - GetElapsedMillisecs())$DINT > 0) 
      & ((g_maxNbrIprCmds = 16#FFFFffff) | (nbrIprCmdsAll < g_maxNbrIprCmds))
  DO
    uiIpr := ((uiIpr$INT + 1) MOD OPS.pProg^.uiProgs)$UINT;
		pIpr  := GetInterpreter(uiIpr);
		pHead := pIpr^.GetHead();
		tEnd  := GetElapsedMillisecs() + pIpr^.GetMaxProgSeqDuration_ms(); // maximum time for one interpreter program
    IF (tEnd - tEndAllProgs)$DINT > 0 THEN
      // Die End-Zeit eines Programms darf nicht hinter der End-Zeit aller Programme liegen
      tEnd := tEndAllProgs;
    END_IF;
		IF (tEnd - GetElapsedMillisecs())$DINT <= 0 THEN
      // Wenn die End-Zeit schon abgelaufen ist, dann Schleife verlassen damit g_uiLastIpr 
      // nicht mehr aktualisiert wird.
      EXIT;
    END_IF;
    
    nbrIprCmds := 0;
    // Maximum der Interpreterkommandos für diesen Interpreter berechnen
    IF g_maxNbrIprCmds = 16#FFFFffff THEN
      maxNbrIprCmds := 16#FFFFffff;
    ELSE
      maxNbrIprCmds := g_maxNbrIprCmds - nbrIprCmdsAll;
    END_IF;
    IF pIpr^.GetMaxNbrIprCmds() < maxNbrIprCmds THEN
      maxNbrIprCmds := pIpr^.GetMaxNbrIprCmds();
    END_IF;

    g_uiLastIpr := uiIpr;
    
    oldFunkSt := pHead^.FunkSt;
    
		WHILE (tEnd - GetElapsedMillisecs())$DINT > 0 
        & ((maxNbrIprCmds = 16#FFFFffff) | (nbrIprCmds < maxNbrIprCmds))
    DO   

			CASE pHead^.FunkSt OF
			ERROR:
				EXIT;

			ERROR_BUSY:

				// stop on going commands (i.e. movements, I_CMD)
				CASE pIpr^.BefIpr(#bSetNext) OF
				READY,
				ERROR:
					pHead^.FunkSt	:= ERROR;
					pHead^.WorkState := READY;	// stop interpreter completly


				BUSY:
					pHead^.FunkSt 	:= ERROR_BUSY;

				QUIT:
					GOTO RESTART_IPR;
				STOP_BP:
					pHead^.FunkSt := STOP_BP;
				SINGLESTEP:
					pHead^.FunkSt := SINGLESTEP;
				END_CASE;

				// stop the axes if necessary
				pIpr^.KillActiveObjects();
				EXIT;

			//-----------------------------------------------------------------
			// Decode a new instruction
			//-----------------------------------------------------------------
			READY:

				CASE pIpr^.BefIpr(#bSetNext) OF
				READY:
					IF bSetNext THEN
						pIpr^.SetNextInstruction();
					END_IF;
					IF pHead^.funkst <> STOP_BP & 
						pHead^.funkst <> SINGLESTEP THEN
						pHead^.FunkSt := READY;
					END_IF;

				BUSY:
					pHead^.FunkSt := BUSY;
					EXIT;

				ERROR:
					pHead^.FunkSt := ERROR;
					EXIT;

				QUIT:
					GOTO RESTART_IPR;
				STOP_BP:
					pHead^.FunkSt := STOP_BP;
				SINGLESTEP:
					pHead^.FunkSt := SINGLESTEP;
				END_CASE;

			BUSY:

				CASE pIpr^.BefIpr(#bSetNext) OF
				READY:
					IF bSetNext THEN
						pIpr^.SetNextInstruction();
					END_IF;
					IF pHead^.funkst <> STOP_BP &
						pHead^.funkst <> SINGLESTEP THEN
						pHead^.FunkSt := READY;
					END_IF;
				BUSY:
					pHead^.FunkSt := BUSY;
					EXIT;

				ERROR:
					pHead^.FunkSt := ERROR;
					EXIT;

				QUIT:
RESTART_IPR:		pHead^.FunkSt := ERROR;
				STOP_BP:
					pHead^.FunkSt := STOP_BP;
				SINGLESTEP:
					pHead^.FunkSt := SINGLESTEP;
          pIpr^.SetNextInstruction();
				END_CASE;

			STOP_BP:
				EXIT;
			SINGLESTEP:
				EXIT;
				
			END_CASE;
      
      nbrIprCmds += 1;

			IF pIpr^.EndOfCode() THEN
        IF (oldFunkSt <> pHead^.FunkSt & pHead^.FunkSt = ERROR) | pIpr^.GetLastError() <> PROGIP_NO_ERROR THEN
          pIpr^.HandleError();
        END_IF;
				GOTO L_ENDPROG;        
			END_IF;

		END_WHILE;

    IF (oldFunkSt <> pHead^.FunkSt & pHead^.FunkSt = ERROR) | pIpr^.GetLastError() <> PROGIP_NO_ERROR THEN
      pIpr^.HandleError();
    END_IF;

    nbrIprCmdsAll += nbrIprCmds;
		uiCnt += 1;
	END_WHILE;

	L_ENDPROG:

END_FUNCTION

FUNCTION GLOBAL IprMgr::HaltProgsImmediately
  VAR
    uiIpr		: UINT;
    pIpr		: ^ProgIp;
    pHead		: ^IprHead;
  END_VAR
  
  IF OPS.pProg = NIL THEN
    RETURN;
  END_IF;
  
	uiIpr:= 0;
	WHILE uiIpr < OPS.pProg^.uiProgs DO
		pIpr := GetInterpreter(uiIpr);
    IF pIpr = NIL THEN
      RETURN;
    END_IF;
		pHead := pIpr^.GetHead();
    IF pHead = NIL THEN
      RETURN;
    END_IF;

    pHead^.funkst		:= ERROR;
    pHead^.WorkState	:= READY;

		uiIpr += 1;

	END_WHILE;
  
END_FUNCTION

//    
//    ----------------------------------------------------------
//    Kill All progs
//    ----------------------------------------------------------
//
FUNCTION GLOBAL IprMgr::KillProgs
  VAR
    uiIpr		: UINT;
    pIpr		: ^ProgIp;
    bSetNext	: UDINT;
    pHead		: ^IprHead;
  END_VAR

	uiIpr:= 0;
	WHILE uiIpr < OPS.pProg^.uiProgs DO
		pIpr := GetInterpreter(uiIpr);
		pHead := pIpr^.GetHead();

		CASE pHead^.FunkSt OF

		ERROR_BUSY,
		BUSY:
			pHead^.FunkSt	:= ERROR_BUSY;

			CASE pIpr^.BefIpr(#bSetNext) OF
			ERROR,
			READY:
				pHead^.funkst		:= ERROR;
				pHead^.WorkState	:= READY;
			ELSE
				pHead^.funkst		:= ERROR_BUSY;
			END_CASE;

		ELSE
			pHead^.funkst	:= ERROR;
		END_CASE;

		uiIpr += 1;

	END_WHILE;

END_FUNCTION

FUNCTION GLOBAL IprMgr_KillProgs

	IprMgr::KillProgs();

END_FUNCTION


// allocates and initializes an IP-object
FUNCTION GLOBAL IprMgr::GetIpObj
  VAR_INPUT
	  useOsResources	: BOOL;
  END_VAR
	VAR_OUTPUT
		ptCom 	: ^DebugIp;
	END_VAR

  IF useOsResources THEN
    ptCom := OS_SysMalloc(SIZEOF(DebugIp))$^DebugIp;
  ELSE
    ptCom := _alloc_resize_LDR(SIZEOF(DebugIp))$^DebugIp;
  END_IF;

	IF ptCom THEN
		ptCom^.InitCode(useOsResources);
	END_IF;

END_FUNCTION

FUNCTION GLOBAL IprMgr_SetMaxProgSeqDurationAll_ms
VAR_INPUT
  maxProgSeqDuration_ms : UDINT;
END_VAR
  g_maxProgSeqDuration_ms := maxProgSeqDuration_ms;
END_FUNCTION

FUNCTION GLOBAL IprMgr_SetProgSeqCycleTime_ms
VAR_INPUT
  progSeqCycleTime_ms : UDINT;
END_VAR
  g_progSeqCycleTime_ms := progSeqCycleTime_ms;
END_FUNCTION

FUNCTION GLOBAL IprMgr_SetMaxNbrIprCmds
VAR_INPUT
  maxNbrIprCmds : UDINT;
END_VAR
  g_maxNbrIprCmds := maxNbrIprCmds;
END_FUNCTION
