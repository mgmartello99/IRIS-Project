//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#include "RTOS_IprIntern.h"
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "ProgMgr"
	Revision           = "0.0"
	GUID               = "{BC5EB553-3888-4E05-B36B-30C4DAEC2F47}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Server0" GUID="NULL" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
</Class>
*)
ProgMgr : CLASS
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION GLOBAL GetProgramPtr
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pp 	: ^pNewSubPrgHead;
		END_VAR;
	
	FUNCTION GetProgramObj
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pPrgObj 	: ^RAMex;
		END_VAR;
	
	FUNCTION GLOBAL GetProgramHead
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pp 	: pNewSubPrgHead;
		END_VAR;
	
	FUNCTION GLOBAL GetProgram
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pp 	: pSubPrgHead;
		END_VAR;
	
	FUNCTION GLOBAL GetProgramChkSum
		VAR_INPUT
			pPrg 	: pSubPrgHead;
		END_VAR
		VAR_OUTPUT
			udChkSum 	: UDINT;
		END_VAR;
	
	FUNCTION SetUnlinkedProgramChkSum
		VAR_INPUT
			pPrg 	: pSubPrgHead;
		END_VAR;
	
	FUNCTION GLOBAL GetUnlinkedProgramChkSum
		VAR_INPUT
			pPrg 	: pSubPrgHead;
		END_VAR
		VAR_OUTPUT
			udChkSum 	: UDINT;
		END_VAR;
	
	FUNCTION SetProgramChkSum
		VAR_INPUT
			nProgNo 	: UDINT;
			bBTnoRun 	: BOOL := FALSE;
		END_VAR;
	
	FUNCTION GLOBAL AllocProg
		VAR_INPUT
			udPrgSize 	: UDINT;
			nProgNo 	: UDINT;
			szProgName 	: ^CHAR := NIL;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL FreeProgram
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR;
	
	FUNCTION LinkVariables
		VAR_INPUT
			nProgNo 	: UDINT;
			pSubPrg 	: ^SubPrgHead;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetProgramNumber
		VAR_INPUT
			sProgName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			nProgNo 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetLabelNumber
		VAR_INPUT
			nProgNo 	: UDINT;
			pLabelName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			nLabelNr 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL LinkAllProgs
		VAR_INPUT
			nMaxProg 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION LinkPrograms
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL ProgLoad
		VAR_INPUT
			pRead 	: pSubPrgHead;
			nProgSrc 	: UDINT;
			nProgNo 	: UDINT;
			bDoNotLink 	: BOOL := FALSE;
			bBTnoRun 	: BOOL := FALSE;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL LinkVarias
		VAR_INPUT
			nProgNo 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION AllocProg2
		VAR_INPUT
			udPrgSize 	: UDINT;
			nProgNo 	: UDINT;
			szProgName 	: ^CHAR;
			useRamex 	: BOOL;
			allocSizeFix 	: BOOL;
		END_VAR
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL CreateIprProg
		VAR_INPUT
			flags 	: UDINT;
			preAllocSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			prgNbr 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL LoadIprProg
		VAR_INPUT
			prgNbr 	: UINT;
			pProg 	: ^SubPrgHead;
			prgSize 	: UDINT;
			bCheck 	: BOOL;
			bDoNotLink 	: BOOL := FALSE;
			bBTnoRun 	: BOOL := FALSE;
		END_VAR
		VAR_OUTPUT
			retVal 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ProgMgr::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_PROGMGR
0$UINT, 0$UINT, (SIZEOF(::ProgMgr))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(1635829664), "ProgMgr", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::ProgMgr.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
END_FUNCTION


#define USER_CNT_ProgMgr 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ProgMgr] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ProgMgr::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

#pragma usingLtd RAMex

//{{LSL_IMPLEMENTATION

#include ".\include\L2_Ipr.h"
#include ".\RTOS_PrivHeader.h"
#include ".\LoaderItf.h"

#pragma using BaseIp
#pragma using DebugIp
#pragma using ProgIp
#pragma using IprMgr

#pragma using ObjectReader
#pragma using ClassReader

TYPE
	_LinkOff		: UDINT;		// offset of fixups
END_TYPE

// Calculates the checksum for a interpreter program

FUNCTION AWL GLOBAL      CRC16_BUFFER
VAR_INPUT
	ptr				: ^CHAR;
	count			: UINT;
END_VAR
VAR_OUTPUT
	crc_16			: UINT;
END_VAR;

FUNCTION TAB _CheckSum_CRC16Table
 
  16#0000$UINT,  16#C0C1$UINT,  16#C181$UINT,  16#0140$UINT,
	16#C301$UINT,  16#03C0$UINT,  16#0280$UINT,  16#C241$UINT,
	16#C601$UINT,  16#06C0$UINT,  16#0780$UINT,  16#C741$UINT,
	16#0500$UINT,  16#C5C1$UINT,  16#C481$UINT,  16#0440$UINT,
	16#CC01$UINT,  16#0CC0$UINT,  16#0D80$UINT,  16#CD41$UINT,
	16#0F00$UINT,  16#CFC1$UINT,  16#CE81$UINT,  16#0E40$UINT,
	16#0A00$UINT,  16#CAC1$UINT,  16#CB81$UINT,  16#0B40$UINT,
	16#C901$UINT,  16#09C0$UINT,  16#0880$UINT,  16#C841$UINT,
	16#D801$UINT,  16#18C0$UINT,  16#1980$UINT,  16#D941$UINT,
	16#1B00$UINT,  16#DBC1$UINT,  16#DA81$UINT,  16#1A40$UINT,
	16#1E00$UINT,  16#DEC1$UINT,  16#DF81$UINT,  16#1F40$UINT,
	16#DD01$UINT,  16#1DC0$UINT,  16#1C80$UINT,  16#DC41$UINT,
	16#1400$UINT,  16#D4C1$UINT,  16#D581$UINT,  16#1540$UINT,
	16#D701$UINT,  16#17C0$UINT,  16#1680$UINT,  16#D641$UINT,
	16#D201$UINT,  16#12C0$UINT,  16#1380$UINT,  16#D341$UINT,
	16#1100$UINT,  16#D1C1$UINT,  16#D081$UINT,  16#1040$UINT,
	16#F001$UINT,  16#30C0$UINT,  16#3180$UINT,  16#F141$UINT,
	16#3300$UINT,  16#F3C1$UINT,  16#F281$UINT,  16#3240$UINT,
	16#3600$UINT,  16#F6C1$UINT,  16#F781$UINT,  16#3740$UINT,
	16#F501$UINT,  16#35C0$UINT,  16#3480$UINT,  16#F441$UINT,
	16#3C00$UINT,  16#FCC1$UINT,  16#FD81$UINT,  16#3D40$UINT,
	16#FF01$UINT,  16#3FC0$UINT,  16#3E80$UINT,  16#FE41$UINT,
	16#FA01$UINT,  16#3AC0$UINT,  16#3B80$UINT,  16#FB41$UINT,
	16#3900$UINT,  16#F9C1$UINT,  16#F881$UINT,  16#3840$UINT,
	16#2800$UINT,  16#E8C1$UINT,  16#E981$UINT,  16#2940$UINT,
	16#EB01$UINT,  16#2BC0$UINT,  16#2A80$UINT,  16#EA41$UINT,
	16#EE01$UINT,  16#2EC0$UINT,  16#2F80$UINT,  16#EF41$UINT,
	16#2D00$UINT,  16#EDC1$UINT,  16#EC81$UINT,  16#2C40$UINT,
	16#E401$UINT,  16#24C0$UINT,  16#2580$UINT,  16#E541$UINT,
	16#2700$UINT,  16#E7C1$UINT,  16#E681$UINT,  16#2640$UINT,
	16#2200$UINT,  16#E2C1$UINT,  16#E381$UINT,  16#2340$UINT,
	16#E101$UINT,  16#21C0$UINT,  16#2080$UINT,  16#E041$UINT,
	16#A001$UINT,  16#60C0$UINT,  16#6180$UINT,  16#A141$UINT,
	16#6300$UINT,  16#A3C1$UINT,  16#A281$UINT,  16#6240$UINT,
	16#6600$UINT,  16#A6C1$UINT,  16#A781$UINT,  16#6740$UINT,
	16#A501$UINT,  16#65C0$UINT,  16#6480$UINT,  16#A441$UINT,
	16#6C00$UINT,  16#ACC1$UINT,  16#AD81$UINT,  16#6D40$UINT,
	16#AF01$UINT,  16#6FC0$UINT,  16#6E80$UINT,  16#AE41$UINT,
	16#AA01$UINT,  16#6AC0$UINT,  16#6B80$UINT,  16#AB41$UINT,
	16#6900$UINT,  16#A9C1$UINT,  16#A881$UINT,  16#6840$UINT,
	16#7800$UINT,  16#B8C1$UINT,  16#B981$UINT,  16#7940$UINT,
	16#BB01$UINT,  16#7BC0$UINT,  16#7A80$UINT,  16#BA41$UINT,
	16#BE01$UINT,  16#7EC0$UINT,  16#7F80$UINT,  16#BF41$UINT,
	16#7D00$UINT,  16#BDC1$UINT,  16#BC81$UINT,  16#7C40$UINT,
	16#B401$UINT,  16#74C0$UINT,  16#7580$UINT,  16#B541$UINT,
	16#7700$UINT,  16#B7C1$UINT,  16#B681$UINT,  16#7640$UINT,
	16#7200$UINT,  16#B2C1$UINT,  16#B381$UINT,  16#7340$UINT,
	16#B101$UINT,  16#71C0$UINT,  16#7080$UINT,  16#B041$UINT,
	16#5000$UINT,  16#90C1$UINT,  16#9181$UINT,  16#5140$UINT,
	16#9301$UINT,  16#53C0$UINT,  16#5280$UINT,  16#9241$UINT,
	16#9601$UINT,  16#56C0$UINT,  16#5780$UINT,  16#9741$UINT,
	16#5500$UINT,  16#95C1$UINT,  16#9481$UINT,  16#5440$UINT,
	16#9C01$UINT,  16#5CC0$UINT,  16#5D80$UINT,  16#9D41$UINT,
	16#5F00$UINT,  16#9FC1$UINT,  16#9E81$UINT,  16#5E40$UINT,
	16#5A00$UINT,  16#9AC1$UINT,  16#9B81$UINT,  16#5B40$UINT,
	16#9901$UINT,  16#59C0$UINT,  16#5880$UINT,  16#9841$UINT,
	16#8801$UINT,  16#48C0$UINT,  16#4980$UINT,  16#8941$UINT,
	16#4B00$UINT,  16#8BC1$UINT,  16#8A81$UINT,  16#4A40$UINT,
	16#4E00$UINT,  16#8EC1$UINT,  16#8F81$UINT,  16#4F40$UINT,
	16#8D01$UINT,  16#4DC0$UINT,  16#4C80$UINT,  16#8C41$UINT,
	16#4400$UINT,  16#84C1$UINT,  16#8581$UINT,  16#4540$UINT,
	16#8701$UINT,  16#47C0$UINT,  16#4680$UINT,  16#8641$UINT,
	16#8201$UINT,  16#42C0$UINT,  16#4380$UINT,  16#8341$UINT,
	16#4100$UINT,  16#81C1$UINT,  16#8081$UINT,  16#4040$UINT,

END_FUNCTION

FUNCTION _CheckSum_CRC16
                VAR_INPUT
                               pBuffer                : ^CHAR;
                               len          : UDINT;
                               CrcStart                : UINT;
                END_VAR
                VAR_OUTPUT
                               checksum            : UINT;
                END_VAR
  VAR
    ptrTable : ^udint;
    ptrData  : ^uint;
    totallen : udint;
    z :uint;
    y  :uint;
  END_VAR

  ptrTable := #_CheckSum_CRC16Table();
  totallen := ptrTable^;
  ptrData := (ptrTable +4)$^uint;
  CrcStart := CrcStart XOR 16#FFFF;

  while len do
    z:= pBuffer^;
    pBuffer +=1;
    z := z XOR CrcStart;
    z := z AND 16#FF;
    y := (ptrData + ( z*sizeof(uint)))^;
    CrcStart := y xor ( CrcStart shr 8 );
    len -=1;
  end_while;

  checksum := CrcStart;
END_FUNCTION

FUNCTION ProgMgr::GetProgramChkSum
VAR_INPUT
	pPrg			: pSubPrgHead;
END_VAR
VAR_OUTPUT
	udChkSum		: UDINT;
END_VAR

	IF pPrg^.udLng >= sizeof(SubPrgHead) THEN 
		udChkSum := to_udint(_CheckSum_CRC16(#pPrg^.szName[0], pPrg^.udLng-TO_UDINT(SubPrgHead.szName), 0));
	ELSE
		udChkSum := 0;
	END_IF;

END_FUNCTION
FUNCTION GLOBAL ProgMgr::GetUnlinkedProgramChkSum
VAR_INPUT
	pPrg			: pSubPrgHead;
END_VAR
VAR_OUTPUT
	udChkSum		: UDINT;
END_VAR

	IF pPrg^.udLng >= sizeof(SubPrgHead) THEN 
		udChkSum := to_udint(_CheckSum_CRC16(pPrg$^char+sizeof(SubPrgHead), pPrg^.udLng-TO_UDINT(sizeof(SubPrgHead)), 0));
	ELSE
		udChkSum := 0;
	END_IF;

END_FUNCTION
FUNCTION ProgMgr::SetUnlinkedProgramChkSum
VAR_INPUT
	pPrg		:pSubPrgHead;
END_VAR

	IF pPrg^.udLng >= sizeof(SubPrgHead) THEN 
	  pPrg^.udCRCorig := GetUnlinkedProgramChkSum(pPrg);
	END_IF;

END_FUNCTION
// Function returns a pointer to the program pointer in the 
// OPS with the given number
//
FUNCTION GLOBAL ProgMgr::GetProgramPtr
VAR_INPUT
	nProgNo			: UDINT;
END_VAR
VAR_OUTPUT
	pp				: ^pNewSubPrgHead;
END_VAR

	pp := #Ops.pProg^.pProg1 + nProgNo*Sizeof(pNewSubPrgHead);

END_FUNCTION

FUNCTION GLOBAL ProgMgr_GetProgramPtr
VAR_INPUT
	nProgNo			: UDINT;
END_VAR
VAR_OUTPUT
	pp				: ^pNewSubPrgHead;
END_VAR

	pp := ProgMgr::GetProgramPtr(nProgNo);

END_FUNCTION

// Function returns a pointer to the RAMex-object, which
// stores the IPR-Program
FUNCTION ProgMgr::GetProgramObj
VAR_INPUT
	nProgNo		: UDINT;
END_VAR
VAR_OUTPUT
	pPrgObj		: ^RamEx;
END_VAR

	pPrgObj	:= GetProgramPtr(nProgNo)^$ ^RamEx;

END_FUNCTION
FUNCTION ProgMgr::GetProgramHead
VAR_INPUT
	nProgNo         : UDINT;
END_VAR
VAR_OUTPUT
	pp              : pNewSubPrgHead;
END_VAR
VAR
	pPrgObj			: ^RAMex;
	Paras			: CmdStruct;	// parameter buffer
	Results			: Results;		// result buffer
END_VAR

	pPrgObj	:= GetProgramObj(nProgNo);

	Paras.uiCmd	:= MerkerEx::GET_DATA_PTR;
	
	IF pPrgObj^.NewInst(#Paras, #Results) <> READY |
	   Results.uiLng < sizeof(pVoid) THEN
		pp	:= NIL;
	ELSE
		pp	:= (Results.aData[0])$pNewSubPrgHead;
	END_IF;

END_FUNCTION
// Function returns a pointer to the program with the given number

FUNCTION GLOBAL ProgMgr::GetProgram
VAR_INPUT
	nProgNo         : UDINT;
END_VAR
VAR_OUTPUT
	pp              : pSubPrgHead;
END_VAR
VAR
	pProgHead		: pNewSubPrgHead;
END_VAR

	pProgHead := GetProgramHead(nProgNo);
	IF pProgHead = NIL THEN
		pp := NIL;
	ELSE
		pp	:= #pProgHead^.subProgHead;
	END_IF;

END_FUNCTION

FUNCTION GLOBAL ProgMgr_GetProgram
VAR_INPUT
	nProgNo         : UDINT;
END_VAR
VAR_OUTPUT
	pp              : pSubPrgHead;
END_VAR

  pp := ProgMgr::GetProgram(nProgNo);

END_FUNCTION

//    
//    ----------------------------------------------------------
//       this program only makes space within the progbuffer
//    ----------------------------------------------------------
//    
//    
//    prg_size = new size
//    prgnr =    program number to be stored valid MAX_PROGS+1 to 2*MAX_PROGS
//               (only for the loadbuffer valid)
//
FUNCTION ProgMgr::AllocProg2
	VAR_INPUT
		udPrgSize 	: UDINT;
		nProgNo 	: UDINT;
    szProgName		: ^char;
    useRamex		: BOOL;
    allocSizeFix    : BOOL;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
VAR
	pProg			: ^pNewSubPrgHead;
	pPrgObj			: ^MerkerEx;
	pIpr		: ^ProgIp;
  pCls      : ^ClsHdr;
END_VAR

  ok := FALSE;
  
  IF LDR_SetConfigFlags(0) AND LDR_DO_NOT_USE_RAMEX_FOR_IPRPROG THEN
    useRamex := FALSE;
  END_IF;


	// test if the size is ok minimum 4
	IF udPrgSize  >= MIN_PROG_SIZE THEN

		pIpr  := IprMgr::GetRegInterpreter(nProgNo);
    IF pIpr = NIL THEN
      RETURN;
    END_IF;

		// get address of current program
		pPrgObj 	:= GetProgramObj(nProgNo);

		// create new program
		IF pPrgObj = NIL THEN

      pCls := _LookupCls("MerkerEx");
      IF ((pCls <> NIL) & (pCls^.pDsc^.udRev.Hi < 1) & (pCls^.pDsc^.udRev.Lo < 20)) THEN
        TRACE_ERR("Incompatible version of class MerkerEx. Update to revision >= 1.20");
        LSLCLI_LoaderTracePrint("Incompatible version of class MerkerEx. Update to revision >= 1.20", 12);
        RETURN;
      END_IF;

      #ifdef _LSL_TARGETARCH_X86
      IF useRamex THEN
        pPrgObj	:= ObjectReader::NewObj("RamEx", szProgName) $ ^MerkerEx;
      ELSE
        pPrgObj	:= NewObj("MerkerEx", szProgName) $ ^MerkerEx;
      END_IF;
      #else // Umstellung auf MerkerEx für ARM um SRAM zugriffe zu vermeiden(UnalignedAcces).
      pPrgObj	:= NewObj("MerkerEx", szProgName) $ ^MerkerEx;
      #Endif

			IF pPrgObj = NIL THEN
				RETURN;
			END_IF;
      
			IF allocSizeFix THEN
				// Die Größe des Programm-Objekts wird jetzt festgelegt 
				// und kann sich ab jetzt nicht mehr ändern
				IF pPrgObj^.SetSize(udPrgSize + TO_UDINT(NewSubPrgHead.subProgHead)) <> C_OK THEN
          RETURN;
				END_IF;
        pIpr^.m_udPrgSize := udPrgSize;
				pIpr^.m_allocSizeFix := TRUE;
			END_IF;
      
		ELSE
			IF pIpr^.m_allocSizeFix THEN
				// Wenn sich die Größe nicht mehr ändern darf, dann wird kein 
				// Fehler zurückgegeben wenn eine kleinere Größe angefordert wird.
        (*pr:
          Die GetSize Methode der MerkerEx Klasse kann hier im Gegensatz zu 
          SetSize nicht verwendet werden, da GetSize keine virtuelle Methode 
          ist, SetSize aber schon. Bei einer nicht virtuellen Methode muß der 
          Linker die Adresse der Methode in den Code eintragen, bei einer 
          virtuellen Methode trägt der Class-Loader die Adresse in die Methoden- 
          tabelle ein.
          Bei einem Projekt, das keine MerkerEx beinhaltet (z.B. eines ohne IPR 
          Programm) käme es daher zu einem Linkerfehler, wenn die GetSize Funktion 
          aufgerufen wird.
          -> Lösung: 
            Die allokierte Größe des MerkerEx/RamEx wird nicht über die GetSize 
            Methode abgefragt, sondern sie wird im bei jedem SetSize Aufruf 
            im ProgIp Objekt mit abgespeichert (m_udPrgSize).
        *)
				IF (pIpr^.m_udPrgSize + TO_UDINT(NewSubPrgHead.subProgHead)) < 
           (udPrgSize + TO_UDINT(NewSubPrgHead.subProgHead)) THEN
					RETURN;
				END_IF;
      ELSE
        IF pPrgObj^.SetSize(udPrgSize + TO_UDINT(NewSubPrgHead.subProgHead)) <> C_OK THEN
          RETURN;
        END_IF;
        pIpr^.m_udPrgSize := udPrgSize;
      END_IF;
		END_IF;

		pProg	:= GetProgramPtr(nProgNo);
		pProg^	:= pPrgObj$pNewSubPrgHead;

		ok	:= TRUE;
	END_IF;

END_FUNCTION

FUNCTION GLOBAL ProgMgr::AllocProg
VAR_INPUT
	udPrgSize		: UDINT;
	nProgNo			: UDINT;
	szProgName		: ^char := NIL;
END_VAR
VAR_OUTPUT
	ok				: BOOL;
END_VAR

	ok := AllocProg2(udPrgSize, nProgNo, szProgName, useRamex := TRUE, allocSizeFix := FALSE);
  (*
	// Anm.: 
  // Im Lasal1 wurde MerkerEx anstatt RamEx verwendet, wenn das #define COMLINK_LASAL  
  // nicht definiert war, weil in diesem Fall angenommen wurde daß es sich um ein Billion 
  // Projekt handelt. Mit RamEx hat es dabei irgendwelche Probleme gegeben.
	ok := AllocProg2(udPrgSize, nProgNo, szProgName, useRamex := FALSE, allocSizeFix := FALSE);
  *)

END_FUNCTION

(*
Legt ein Interpreterprogramm Objekt an

Parameter
  flags     76543210
            !    !!!
            !    !! \_ 0 = MerkerEx, 
			      !    !!    1 = vorbereitet für Ramex, dzt. nicht implementiert !!!
            !    ! \__ 0 = dynamisch erweiterbar, 
      			!    !     1 = fix allokiert, Größe und Speicherort kann sich nicht mehr ändern
             \____\___ 0 = reserviert
  preAllocSize  .. Ein Wert <>0 gibt an mit welcher Größe der Speicher für das 
                   IPR-Programm vorallokiert wird.
				   Es wird die Größe des SubPrgHead + Code und Tabellen angegeben.
				   NewSubPrgHead zählt nicht dazu.
Return
  prgNbr        .. >=0: Programmnummer, <0: Fehler                      
*)
FUNCTION GLOBAL ProgMgr::CreateIprProg
VAR_INPUT
	flags : UDINT;     
	preAllocSize : UDINT; 
END_VAR
VAR_OUTPUT
	prgNbr : UINT;        
END_VAR
VAR
	pp			: pProgIp;
	pDir		: ^pProgIp;
  ppBp		: ^RamEx;
	szName		: ARRAY [0..80] OF CHAR;
	useRamex : BOOL;
	allocSizeFix : BOOL;
	prgNbrWork : USINT;
	prgNbrTemp : USINT;
	i : INT;
	pHead		: ^IprHead;
	allocSize : UDINT; 
  pReqCls : ^ClsHdr;
END_VAR

	prgNbr := 16#ffff;

  IF Ops.pSequDir = NIL THEN
    allocSize := IprDir.pFirstIpr + MAX_IP_PROGS*SIZEOF(pVoid);
    OPS.pSequDir := _alloc_align(allocSize) $ ^IprDir;
    IF OPS.pSequDir = NIL THEN
      RETURN;
    END_IF;
  END_IF;
  IF Ops.pProg = NIL THEN
    allocSize := PrgHead.pProg1 + MAX_IP_PROGS * (2*sizeof(pNewSubPrgHead));
    Ops.pProg	:= _alloc_align(allocSize)$^PrgHead;
    IF ops.pProg = NIL THEN
      RETURN;
    END_IF;
  END_IF;

	IF (Ops.pSequDir^.uiIprCnt >= MAX_IP_PROGS) | 
	   (Ops.pProg^.uiProgs >= MAX_IP_PROGS) THEN
		RETURN;
	END_IF;

	IF flags AND 1 THEN
		// dzt. nicht implementiert da nicht benötigt
		RETURN;
	ELSE
		useRamex := FALSE;
	END_IF;

	IF flags AND 2 THEN
		allocSizeFix := TRUE;
	ELSE
		allocSizeFix := FALSE;
	END_IF;

	IF _LookupCls("RAMEX") = NIL THEN
    TRACE_WARN("Make sure the <RamEx>-class is part of Your project!");
    LSLCLI_LoaderTracePrint("Make sure the <RamEx>-class is part of Your project!", 12);
    RETURN;
	END_IF;
(*
  // RAMEX wird in jedem Fall benötigt, da die Breakpoints in RamEx gespeichert werden
	IF useRamex & _LookupCls("RAMEX") = NIL THEN
    TRACE("Make sure the <RamEx>-class is part of Your project!");
    RETURN;
	END_IF;

	IF !!useRamex & _LookupCls("MerkerEx") = NIL THEN
    TRACE("Make sure the <MerkerEx>-class is part of Your project!");
    RETURN;
	END_IF;
*)

  pReqCls := _LookupCls("MerkerEx");
	IF ((pReqCls <> NIL) & (pReqCls^.pDsc^.udRev.Hi < 1) & (pReqCls^.pDsc^.udRev.Lo < 20)) THEN
		TRACE_ERR("Incompatible version of class MerkerEx. Update to revision >= 1.20");
		LSLCLI_LoaderTracePrint("Incompatible version of class MerkerEx. Update to revision >= 1.20", 12);
		RETURN;
	END_IF;

	IF _LookupCls("ProgIp") = NIL THEN
    IF ClassReader::NewCls("ProgIp") = NIL THEN
      RETURN;
    END_IF;
	END_IF;

	prgNbrWork := Ops.pSequDir^.uiIprCnt$USINT;

	_strcpy(#szName[0], "ProgIp");

	_itoa(prgNbrWork, #szName[6]);
	pp:= NewObj("ProgIp", #szName[0]) $ pProgIp;//create a new interpreter
	IF pp = NIL THEN
		RETURN;
	END_IF;

  // Embedded Client anlegen. Das muß im Gegensatz zu Lasal1 manuell gemacht 
  // werden, weil kein ON existiert.
  _strcat(#szName[0], "\m_Breakpoints");
  ppBp := NewObj("RamEx", #szName[0]) $ ^RamEx;
	IF ppBp = NIL THEN
		RETURN;
	END_IF;
  pp^.m_Breakpoints.pCh := ppBp $ ^SvrChCmd_UDINT;
  pp^.m_Breakpoints.pCmd := ppBp;

  // Wenn diese Funktion aus einer Init-Methode aufgerufen wurde, dann wird 
  // mit dem Flag m_bNotFromTable verhindert, daß der nachfolgende Aufruf der 
  // Funktion IprReader::LoadProgsFromTable für dieses Interpreterobjekt versucht 
  // das Programm aus einer Lasal-Tabelle nachzuladen.
  pp^.m_bNotFromTable := TRUE;  
  
	//add it to the "ops" struct
	pDir	:= #Ops.pSequDir^.pFirstIpr + Ops.pSequDir^.uiIprCnt * sizeof(pProgIp);
	pDir^	:= pp;
	Ops.pSequDir^.uiIprCnt += 1;

	FOR i := 0 TO 1 DO	

		IF i = 0 THEN
			prgNbrTemp := prgNbrWork;					// reguläres Prog.Obj
		ELSE
			prgNbrTemp := prgNbrWork + MAX_IP_PROGS;	// temporäres Prog.Obj
		END_IF;

		IF preAllocSize > 0 | allocSizeFix THEN
			allocSize := preAllocSize;
		ELSE
			allocSize := MIN_PROG_SIZE;
		END_IF;
    
		// Der 1.Aufruf von AllocProg2 legt das Programmobjekt nur an, 
		// setzt aber nicht die Größe.
		IF !!AllocProg2(allocSize, prgNbrTemp, NIL, useRamex, allocSizeFix) THEN
      Ops.pSequDir^.uiIprCnt -= 1;
			RETURN;
		END_IF;

		// Der 2.Aufruf von AllocProg2 setzt die Größe des Programmobjekts
		IF !!AllocProg2(allocSize, prgNbrTemp, NIL, useRamex, allocSizeFix) THEN
      Ops.pSequDir^.uiIprCnt -= 1;
			RETURN;
		END_IF;
	END_FOR;

	pHead := pp^.GetHead();
	pHead^.FunkSt := ERROR;

	OPS.pProg^.uiProgs += 1;
  
	prgNbr := prgNbrWork;

END_FUNCTION

FUNCTION GLOBAL ProgMgr_CreateIprProg
VAR_INPUT
	flags : UDINT;     
	preAllocSize : UDINT; 
END_VAR
VAR_OUTPUT
	prgNbr : UINT;        
END_VAR

  prgNbr := ProgMgr::CreateIprProg(flags, preAllocSize);

END_FUNCTION

(*
  Lädt einen Interpretercode in den temporären Interpreterprogrammspeicher
  
  Parameter
    prgNbr        .. Programmnummer
    pProg         .. Programm (SubPrgHead + Tabellen + Code)
    prgSize       .. Größe des Programms
    bCheck        .. TRUE=vor dem Laden wird gelinkt, um Fehler zu erkennen
    bDoNotLink    .. TRUE=das zu ladende Programm ist bereits von der Applikation gelinkt worden
  Return
    retVal        .. >=0: o.k, <0: Fehler      
*)        
FUNCTION GLOBAL ProgMgr::LoadIprProg
	VAR_INPUT
		prgNbr 	: UINT;
		pProg 	: ^SubPrgHead;
		prgSize 	: UDINT;
    bCheck		: BOOL;
		bDoNotLink 	: BOOL;
    bBTnoRun    : BOOL; // := FALSE
	END_VAR
  VAR_OUTPUT
    retVal : DINT;
  END_VAR
  VAR
    tempPrgNbr : UINT;
    pDestProg : pSubPrgHead;
    pPrgIp			: ^ProgIp;
  END_VAR

  retVal := -1;
  
  tempPrgNbr := MAX_IP_PROGS + prgNbr;

  IF ProgMgr::AllocProg(prgSize, tempPrgNbr) = FALSE THEN
    RETURN;
  END_IF;

  // bit will be set when the program is completly 
  // transmitted into temporary memory
	OPS.uiProgsToLoad := OPS.uiProgsToLoad AND NOT (1 SHL prgNbr $ UINT);

  if( prgNbr < 32 )then
    uiProgsToLoad[ 0 ] := uiProgsToLoad[ 0 ] and not ( 1 shl prgNbr$uint );
  elsif( prgNbr < 64 )then
    uiProgsToLoad[ 1 ] := uiProgsToLoad[ 1 ] and not ( 1 shl ( prgNbr - 32 )$uint );
  end_if;

  pDestProg := ProgMgr::GetProgram(tempPrgNbr);
	_MEMCPY(pDestProg, pProg, prgSize);

  pPrgIp := IprMgr::GetInterpreter(prgNbr);
  IF pPrgIp^.LoadProgFromTemp(prgNbr, bCheck, bDoNotLink, bBTnoRun) <> C_OK THEN
    RETURN;	// i.e. linker error
  END_IF;
  pPrgIp^.InitVariables();

  retVal := 0;

END_FUNCTION

FUNCTION GLOBAL ProgMgr_LoadIprProg
	VAR_INPUT
		prgNbr 	: UINT;
		pProg 	: ^SubPrgHead;
		prgSize 	: UDINT;
    bCheck		: BOOL;		// := TRUE
	END_VAR
  VAR_OUTPUT
    retVal : DINT;
  END_VAR

  retVal := ProgMgr::LoadIprProg(prgNbr, pProg, prgSize, bCheck);

END_FUNCTION

FUNCTION GLOBAL ProgMgr_LoadIprProg2
	VAR_INPUT
		prgNbr 	: UINT;
		pProg 	: ^SubPrgHead;
		prgSize 	: UDINT;
    bCheck		: BOOL;		// := TRUE
		bDoNotLink 	: BOOL; // := FALSE
    bBTnoRun    : BOOL; // := FALSE
	END_VAR
  VAR_OUTPUT
    retVal : DINT;
  END_VAR

  retVal := ProgMgr::LoadIprProg(prgNbr, pProg, prgSize, bCheck, bDoNotLink, bBTnoRun);

END_FUNCTION

// Recalculates the checksum for a interpreter program and sets it
//
FUNCTION ProgMgr::SetProgramChkSum
VAR_INPUT
	nProgNo		: UDINT;
  bBTnoRun  : BOOL; // := FALSE
END_VAR
VAR
	pSubPrgHeadPtr	: ^NewSubPrgHead;
	pSubPrg			: ^SUBPRGHEAD;
	pIpr			: ^ProgIp;
	pHead			:^IprHead;
END_VAR

	pSubPrgHeadPtr := GetProgramHead(nProgNo);
 	pSubPrg := #pSubPrgHeadPtr^.subProgHead;

	pIpr := IprMgr::GetInterpreter(nProgNo);// get address of interpreter
	pIpr^.SetPrgHead( pSubPrgHeadPtr );	// cross reference ipr&prg

	// set code pointer to 1st instruction
	pIpr^.SetCodePointer((pSubPrg+pSubPrg^.udOffCode)$UDINT);

	// recalculate the CRC
	IF pSubPrg^.udLng >= sizeof(SubPrgHead) THEN 
		pSubPrg^.udCRC := GetProgramChkSum(pSubPrg);
	END_IF;

	// IPR is now ready to run
	pHead	:= pIpr^.GetHead();
  
  if( bBTnoRun )then
    return;
  end_if;
  
	pHead^.FunkSt	:= READY;

END_FUNCTION
// Frees the program's memory and sets the length to min.
//[>usPrgNo] index of the program that is to free
FUNCTION GLOBAL ProgMgr::FreeProgram
	VAR_INPUT
		nProgNo 	: UDINT;
	END_VAR
VAR
	pPrgObj		: ^MerkerEx;
	pSubPrg		: pSubPrgHead;
	pIpr		: ^ProgIp;
END_VAR

  pIpr  := IprMgr::GetRegInterpreter(nProgNo);
	IF !!pIpr^.m_allocSizeFix THEN
    pPrgObj	:= GetProgramObj(nProgNo);
    pPrgObj^.SetSize(MIN_PROG_SIZE + TO_UDINT(NewSubPrgHead.subProgHead));
    pIpr^.m_udPrgSize := MIN_PROG_SIZE;
    pSubPrg	:= GetProgram(nProgNo);
    pSubPrg^.udLng	:= MIN_PROG_SIZE;
  END_IF;

END_FUNCTION
FUNCTION ProgMgr::LinkVariables
VAR_INPUT
	nProgNo			: UDINT;
	pSubPrg			: ^SUBPRGHEAD;
END_VAR
VAR_OUTPUT
  ok  : BOOL;
END_VAR
VAR
	ptr				  : ^UINT;
	nVaria			: UDINT;
	nActVaria		: UDINT;
	pCode			  : ^UDINT;
	lName			  : UDINT;
	pCh				  : ^SVRCH;
	pAddrRef		: ^pSvrCh;
	nLinks			: UDINT;
	nActLink		: UDINT;
END_VAR
	//--------------------------------------------------------------------
	// Build up Linkerlist
	//--------------------------------------------------------------------

	ptr					:= pSubPrg + pSubPrg^.udOffLinks;
	nVaria			:= ptr^;	// number of different channels
	ptr					+= sizeof(UINT);
	nActVaria		:= 0;
	pCode				:= pSubPrg + pSubPrg^.udOffCode;

	// recalculate the CRC
	//SetUnlinkedProgramChkSum(pSubPrg);

  ok  := TRUE;

	WHILE nActVaria < nVaria DO

		ptr				+= sizeof(UINT)(*len*);
		pAddrRef		:= ptr$^pSvrCh;	// Adresse von Platzhalter f. ID
		ptr 			+= sizeof(UDINT)(*ID*);

		lName			:=	_STRLEN(ptr$^CHAR)+1;
		CASE _LookUpEmbed_C(ptr$^CHAR, #pCh, NIL) OF
      _CH_NONE,
      _CH_CLT_DATA,
      _CH_CLT_CMD,
      _CH_CLT_EMB,
      _CH_CLT_OBJ: 
        ok  := FALSE;
        TRACE0_ERR("Cannot resolve link to '{0}'", ptr $ ^char);
        LSLCLI_LoaderTracePrint( #FormattedText[0], 12 );					
//			RETURN;		// display as many errors as possible
		END_CASE;
		
		pAddrRef^		:= pCh; // in Platzhalter Adresse schreiben
		ptr				  += lName;
		nLinks			:=	ptr^;
		ptr				  +=  sizeof(UINT)(*nLinks*);
		nActVaria		+=	1;
		nActLink		:=	0;

		WHILE nActLink < nLinks DO
			pAddrRef		:= pCode + ptr^$_LinkOff;
			pAddrRef^		:= pCh;
			ptr				  += sizeof(_LinkOff);   // point to next link
			nActLink		+=	1;
		END_WHILE;

	END_WHILE;

END_FUNCTION
#define PRG_NAME_LENGTH 32

FUNCTION ProgMgr::GetProgramNumber
VAR_INPUT
	sProgName	: ^char;
END_VAR
VAR_OUTPUT
	nProgNo		: UDINT;
END_VAR
VAR
	pActPrg			: pSubPrgHead;
  nProgs      : UDINT;
END_VAR

	nProgNo	:= 0;
  IF OPS.pProg = NIL THEN
    nProgNo := 16#FFFF_FFFF;
    RETURN;
  END_IF;
  nProgs  := OPS.pProg^.uiProgs;

	//Programmnummer auslesen
	WHILE nProgNo < nProgs DO

		pActPrg := GetProgram(nProgNo);

	 	IF 	pActPrg <> NIL &
			pActPrg^.udLng > sizeof(SubPrgHead) THEN

			IF _stricmp(sProgName, #pActPrg^.szName[0]) = 0 THEN
				RETURN;
			END_IF;	

		END_IF;			

		nProgNo += 1;

	END_WHILE;

	nProgNo := 16#FFFF_FFFF;

END_FUNCTION
FUNCTION ProgMgr::GetLabelNumber
VAR_INPUT
	nProgNo		: UDINT;
	pLabelName	: ^CHAR;
END_VAR
VAR_OUTPUT
	nLabelNr	: UDINT;
END_VAR
VAR
	pLabels		: ^UDINT;
	pSubPrg		: ^SUBPRGHEAD;
	nLabelCnt	: UDINT;
	udNameLength : UDINT;
END_VAR
	
	pSubPrg	:= GetProgram(nProgNo);

	IF 	pSubPrg <> NIL &
		pSubPrg^.udLng > sizeof(SubPrgHead) THEN
	
		pLabels := pSubPrg + pSubPrg^.udOffLbl;

		nLabelNr	:= 0;
		nLabelCnt 	:= pLabels^$UINT;
		pLabels		+= sizeof(UINT);

		WHILE nLabelNr < nLabelCnt DO
	
			pLabels			+= sizeof(UINT);// 2 Byte Zeilennummer
			pLabels 		+= sizeof(DINT);// 4 Byte Offset

			nLabelNr 		+= 1;

		END_WHILE;

		nLabelNr 	:= 0;

		WHILE nLabelNr < nLabelCnt DO

			udNameLength 	:=	_STRLEN(pLabels$^CHAR)+1;

			IF _stricmp(pLabels$^CHAR, pLabelName) = 0 THEN
				RETURN;
			END_IF;

			pLabels			+= udNameLength;

			nLabelNr		+= 1;
	
		END_WHILE;

	END_IF;	
	
	nLabelNr := INVALID_LABEL;

END_FUNCTION
// Get the program and label numbers of the labels, which are
// used in the other interpreter programs
//
FUNCTION ProgMgr::LinkPrograms
VAR_INPUT
	nProgNo			: UDINT;
END_VAR
VAR_OUTPUT
  ok  : BOOL;
END_VAR
VAR
	ptr				: ^UINT;
	lName			: UDINT;
	pCode			: ^UDINT;
	cActPrg			: UDINT;
	uiActProg		: UINT;
	uiProgCnt		: UINT;
	uiActUse		: UINT;
	uiUseCnt		: UINT;	
	uiActLink		: UINT;
	uiLinkLength	: UINT;
	uiLinkCnt		: UINT;
	nLabelNr		: UDINT;
	pChar			: ^CHAR;
	pSubPrg			: ^SubPrgHead;
	pAddrLabel		: ^UINT;
END_VAR

  ok  := FALSE;
  
 	pSubPrg := GetProgram(nProgNo);

	// test if the size is ok, minimum length
 	IF	pSubPrg^.udOffProgLinks	<= sizeof(SubPrgHead) |
		pSubPrg^.udLng 			<= sizeof(SubPrgHead) THEN
		RETURN;
	END_IF;

	ptr					:= pSubPrg + pSubPrg^.udOffProgLinks;
	uiProgCnt			:= ptr^;	// number of different channels
	ptr					+= sizeof(UINT);
	uiActProg			:= 0;
	pCode				:= pSubPrg + pSubPrg^.udOffCode;

	WHILE uiActProg < uiProgCnt DO

		cActPrg		:= 	GetProgramNumber(ptr $ ^char);
		IF cActPrg = 16#FFFF_FFFF THEN
			RETURN;   // ein Verweis auf ein z.B. noch nicht geladenes Programm
		END_IF;

		ptr			+= PRG_NAME_LENGTH;
		// Programmnummer eintragen
		ptr^$BYTE	:= cActPrg;
		ptr 		+= sizeof(CHAR);
		
		uiLinkCnt	:= ptr^;
		ptr			+= sizeof(UINT);

		uiActLink	:= 0;

		WHILE uiActLink < uiLinkCnt DO
		
			uiLinkLength	:= ptr^;
			ptr				+= sizeof(UINT);//Länge
			pAddrLabel		:= ptr;
			ptr 			+= sizeof(UINT);//Labelnr
			lName			:= _STRLEN(ptr$^CHAR)+1;
			nLabelNr		:= GetLabelNumber(cActPrg, ptr $ ^char);
			pAddrLabel^		:= nLabelNr $ UINT;
			ptr				+= lName;
			uiUseCnt		:= ptr^;
			ptr				+= sizeof(UINT);

			uiActUse		:= 0;
			
			WHILE uiActUse < uiUseCnt DO

				pChar			:= (pCode$UDINT + ptr$^_LinkOff^)$^CHAR;
				pChar^			:= cActPrg $ char;
				pChar$UDINT		+= sizeof(CHAR);
				pChar$^UINT^	:= nLabelNr $ UINT;

				ptr				+= sizeof(_LinkOff);
				uiActUse 		+= 1;

			END_WHILE;

			uiActLink		+= 1;

		END_WHILE;

		uiActProg	+= 1;

	END_WHILE;
  
  ok := TRUE;

END_FUNCTION
// Get the program and label numbers, which are used in all other 
// interpreter programs
//
FUNCTION ProgMgr::LinkAllProgs
VAR_INPUT
	nMaxProg	: UDINT;
END_VAR
VAR_OUTPUT
  ok  : BOOL;
END_VAR
VAR
	nProgNo		: UDINT;
END_VAR

  ok  := FALSE;
  
	IF OPS.pProg^.uiProgs = 0 THEN
		RETURN;
	END_IF;

	nProgNo := OPS.pProg^.uiProgs-1;
	IF nProgNo < nMaxProg THEN
		nMaxProg := nProgNo;
	END_IF;

	FOR nProgNo := 0 TO nMaxProg DO
		IF LinkPrograms(nProgNo) = FALSE THEN
			RETURN;
		END_IF;
	END_FOR;
  
  ok  := TRUE;

END_FUNCTION
//    
//  -> prgnr = program number to be stored, valid 0- MAX_PROGS-1
//    
//    ----------------------------------------------------------
//               link programnumber
//    ----------------------------------------------------------
//      CRC is also calculated once more

FUNCTION ProgMgr::LinkVarias
VAR_INPUT
	nProgNo			: UDINT;
END_VAR
VAR_OUTPUT
	ok  		: BOOL;
END_VAR
VAR
	pSubPrg			: ^SUBPRGHEAD;
END_VAR

 	pSubPrg := GetProgram(nProgNo);

	// test if the size is ok, minimum length
 	IF pSubPrg^.udLng > sizeof(SubPrgHead) THEN

		//link variables
		ok := LinkVariables(nProgNo, pSubPrg);
    
  ELSE
  
    ok  := FALSE;

	END_IF;

END_FUNCTION
//    
//    pRead 	= pointer to the program
//    nProgNoSrc = FROM_TABLE: program source is not in the program
//                   			buffer but in a table
//                 else:       >= ops.pProgs^.uiProgs ... program is 
//    							out of the buffer itself
//    
//    nProgNo   = program number to be stored, valid < ops.pProgs^.uiProgs
//    
//    pMoved = displacement of the succeeding programs
//             very important to move the instruction pointer in the
//             running interpreter programs
//				only valid if ret_code is C_OK
//
FUNCTION GLOBAL ProgMgr::ProgLoad
	VAR_INPUT
		pRead 	: pSubPrgHead;
		nProgSrc 	: UDINT;
		nProgNo 	: UDINT;
		bDoNotLink 	: BOOL;
    bBTnoRun    : BOOL; // := FALSE;
	END_VAR
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
VAR
	pPrgObj			: ^MerkerEx;
	Paras			: CmdStruct;	// parameter buffer
	Results			: Results;		// result buffer
	nProgNoTemp		: UDINT;			// program number temp. prog
END_VAR

  ok  := FALSE;

	// test if the size is ok, minimun is 4
	IF pRead^.udLng  < MIN_PROG_SIZE THEN
		RETURN;
	END_IF;

	pPrgObj		:= GetProgramObj(nProgNo);

	IF nProgSrc <> FROM_TABLE THEN	// CRC should be tested
		IF 	pRead^.udLng >= sizeof(SubPrgHead) &
			pRead^.udCRC <> GetProgramChkSum(pRead) THEN
			// wrong CRC of the (transmitted) program
			RETURN;
		END_IF;

		// exchange the memory blocks, the source will be freed later
		Paras.uiCmd	:= MerkerEx::EXCHANGE_DATA_PTR;
		nProgNoTemp	:= nProgNo+MAX_IP_PROGS;
		Paras.aPara[0]	:= GetProgramObj(nProgNoTemp)$DINT;
		pPrgObj^.NewInst(#Paras, #Results);
		// free the source data block
		FreeProgram(nProgNoTemp);
	ELSE
		IF pPrgObj^.m_udLength <= MIN_PROG_SIZE+
				(NewSubPrgHead.subProgHead)$UDINT THEN	// CRC is correct, from table
			// reserve memory for new program
			IF AllocProg(pRead^.udLng, nProgNo) = FALSE THEN
				RETURN;
			END_IF;

			// copy new program into memory
			_MEMCPY(GetProgram(nProgNo), pRead, pRead^.udLng);
		END_IF;

		// when loading from a temporary program, the linking
		// is already done, with tables not
		IF !!bDoNotLink & LinkVarias(nProgNo) = FALSE THEN
			RETURN;
		END_IF;

	END_IF;

#if 0 // vor 02.01.170, SA32171: Checksumme wurde vor dem Linken berechnet
	// even for temp. progs the checksum has to be recalculated
	SetProgramChkSum(nProgNo, bBTnoRun);
#endif  

  IF bDoNotLink THEN
    ok := TRUE;
  ELSE
    ok := LinkAllProgs(nProgNo);
  END_IF;      

	// even for temp. progs the checksum has to be recalculated
  // ab 02.02.170, SA32171, Checksumme wird nach dem Linken berechnet
	SetProgramChkSum(nProgNo, bBTnoRun);

END_FUNCTION
